# 《2019-2021美团技术年货》

## 后端| 2021 - 1

### 1. 如何优雅地记录操作日志？1
（阅读时长：1小时）

- 1. 操作日志的使用场景
- 2. 实现方式

    - 2.1 使用 Canal 监听数据库记录操作日志
    - 2.2 通过日志文件的方式记录

        - 问题一：操作人如何记录
        - 问题二：操作日志如何和系统日志区分开
        - 问题三：如何生成可读懂的日志文案

    - 2.3 通过 LogUtil 的方式记录日志
    - 2.4 方法注解实现操作日志

- 3. 优雅地支持 AOP 生成动态的操作日志

    - 3.1 动态模板

- 4. 代码实现解析

    - 4.1 代码结构

      上面的操作日志主要是通过一个 AOP 拦截器实现的，整体主要分为 AOP 模块、日 志解析模块、日志保存模块、Starter 模块；组件提供了 4 个扩展点，分别是：自定 义函数、默认处理人、业务保存和查询；业务可以根据自己的业务特性定制符合自己 业务的逻辑。


	- 4.2 模块介绍

		- 4.2.1 AOP 拦截逻辑
		- 4.2.2 解析逻辑

			- 1. 模板解析
			- 2. 解析核心类
			- 3. 日志上下文实现
			- 4. 默认操作人逻辑
			- 5. 自定义函数逻辑

	- 4.2.3 日志持久化逻辑

### 2. 基于 SSD 的 Kafka 应用层缓存架构设计与实现	 29
（阅读时长：20分钟）

- 1. Kafka 在美团数据平台的现状

    -  ● 集群规模：节点数达 6000+，集群数 100+。
    - ● 集群承载：Topic 数 6 万 +，Partition 数 41 万 +。
    - ● 处理的消息规模：目前每天处理消息总量达 8 万亿，峰值流量为 1.8 亿条 / 秒
    - ● 提供的服务规模：目前下游实时计算平台运行了 3 万 + 作业，而这其中绝大多数的数据源均来自 Kafka。

- 2. Kafka 线上痛点分析 & 核心目标

    - 1. 原理分析

    综上所述，Kafka 对于单一读写请求均拥有很好的吞吐和延迟。处理写请求时，数据写入 PageCache 后立即返回，数据通过异步方式批量刷入磁盘，既保证了多数写请求都能有较低的延迟，同时批量顺序刷盘对磁盘更加友好。处理读请求时，实时消费的作业可以直接从 PageCache 读取到数据，请求延迟较小，同时 ZeroCopy 机制 能够减少数据传输过程中用户态与内核态的切换，大幅提升了数据传输的效率。


		- 1. 对于 Produce 请求
		- 2. 对于 Consume 请求

			- ZeroCopy

		- 3. 多个 Consumer竞争 PageCache 资源问题分析

			- PageCache

	- 2. 线上数据统计

		- TP99

	- 3. 痛点分析总结

- 3. 预期目标

    - 保证实时消费作业不会由于 PageCache 竞争而被延迟消费作业影响

- 4. 解决方案

    - 1. 为什么选择 SSD
    - 2. 架构决策

        - 1. 备选方案一：基于操作系统内核层实现
        - 2. 备选方案二：Kafka 应用内部实现

    - 3. 新架构设计

        - 1. 概述
        - 2. 关键优化点

            - 1. LogSegment 同步

                - 1. 同步方式
                - 2. 同步限速

            - 2. 日志追加刷盘策略优化

    - 4. 方案测试

        - 1. 测试目标
        - 2. 测试场景描述
        - 3. 测试内容及重点关注指标
        - 4. 测试结果

            - 1. 从单 Broker 请求延迟角度看
            - 2. 从延迟作业对实时作业的影响方面看

- 5. 总结与未来展望

### 3. 美团图数据库平台建设及业务实践 41
（阅读时长：1小时）

- 1. 前言

    - ● 图谱挖掘
    - ● 安全风控
    - ● 链路分析
    - ● 组织架构

- 2. 图数据库选型

    - 1. 五点考虑

        - (A) 项目开源，暂不考虑需付费的图数据库；
        - (B) 分布式架构设计，具备良好的可扩展性；
        - © 毫秒级的多跳查询延迟；
        - (D)支持千亿量级点边存储；
        - (E) 具备批量从数仓导入数据的能力。

    - 2. 三类数据库

        - 1. 第一类：Neo4j[3]、ArangoDB[4]、Virtuoso[5]、TigerGraph[6]、RedisGraph[7]。
        - 2. 第二类：JanusGraph[8]、HugeGraph[9]。
        - 3. 第三类：DGraph[10]、NebulaGraph[11]。

            - 使用 RAFT 保证数据读写的强一致性

    - 3. 性能对比

- 3. NebulaGraph 架构

    - 1. NebulaGraph 架构设计

        - 1. Meta Service
        - 2. 存储计算分离
        - 3. 无状态计算层
        - 4. Shared-nothing 分布式存储层

            - RocksDB 实现的 Store Engine

    - 2.  台 48U192G 物理机搭建的集群上灌入 10 亿美食图谱数据对 NebulaGraph 的功能进行了验证

- 4. 图数据库平台建设

    - 一站式图数据库自助管理平台

        - 1. 数据应用层
        - 2. 数据存储层
        - 3. 数据生产层
        - 4. 支撑平台

    - 4.1 高可用模块设计
    - 4.2 每小时百亿量级数据导入模块设计
    - 4.3 实时写入多集群数据同步模块设计
    - 4.4 图可视化模块设计

- 5. 业务实践

    - 5.1 智能助理
    - 5.2 搜索召回
    - 5.3 图谱推荐理由
    - 5.4 代码依赖分析

- 6. 总结与展望

### 4. OCTO 2.0：美团基于 Service Mesh 的服务治理系统详解	 60
（阅读时长：30分钟）

- 1. 整体架构

    - 1. Service Mesh

        - 1. 定义

        服务网格是一个基础设施层，用于处理服务间通信。云原生应用有着复杂的服务拓扑，服务网格保证请求在这些拓扑中可靠地穿梭。在实际应用当中，服务网格通常是由一系列轻量级的网络代理组成的，它们与应用程序部署在一起，但对应用程序透明。


	- 2. Istio

		- 1. istio是什么？

		  Istio 是一个与Kubernetes紧密结合的适用于云原生场景的Service Mesh形态的用于服务治理的开放平台。
		  

	- 3. Envoy

		- 1. 概念

		  Envoy 是一个为云原生应用设计的开源边缘与服务代理
		  

		- 2. 主要特性

			- 1. 基于现代 C++ 开发的 L4/L7 高性能代理。
			- 2. 透明代理。
			- 3. 流量管理。支持路由、流量复制、分流等功能。
			- 4. 治理特性。支持健康检查、熔断、限流、超时、重试、故障注入。
			- 5. 多协议支持。支持 HTTP/1.1，HTTP/2，GRPC，WebSocket 等协议代理与治理。
			- 6. 负载均衡。加权轮询、加权最少请求、Ring hash、Maglev、随机等算法支持。支持区域感知路由、故障转移等特性。
			- 7. 动态配置 API。提供健壮的管控代理行为的接口，实现 Envoy 动态配置热更新。
			- 8. 可观察性设计。提供七层流量高可观察性，原生支持分布式追踪。
			- 9. 支持热重启。可实现 Envoy 的无缝升级。
			- 10. 自定义插件能力。Lua 与多语言扩展沙箱 WebAssembly。

- 2. Mesh 功能

    - 2.1 流量劫持

        - 1. OCTO 2.0 并未采用 Istio 的原生方案
        - 2.  Unix Domain Socket 直连方式来实现业务进程和OCTO-Proxy 之间的流量转发

    - 2.2 服务订阅
    - 2.3 无损热重启

        - 2.3.1 流量损失场景
        - 2.3.2 适配方案

    - 2.4 数据面运维

        - 2.4.1 LEGO 运维方案
        - 2.4.2 云原生运维方案

- 3. 未来规划

    - 1. 运维、发布和稳定性建设朝云原生化方向探索
    - 2. 支持公司内部 Http 服务的 Mesh 化，降低对中心化网关的依赖
    - 3. 全链路 mTLS 支持

### 5. GraphQL 及元数据驱动架构在后端 BFF 中的实践	 71
（阅读时长：1小时20分钟）

- 1. BFF 的由来

- 2. BFF 背景下的核心矛盾

    - 特点一：外部依赖多、场景间取数存在差异、用户体验要求高
    - 特点二：展示逻辑多、场景之间存在差异，共性个性逻辑耦合

- 3. BFF 应用模式分析

    - 3.1 后端 BFF 模式

        - 1）展示服务颗粒度设计问题
        - 2）数据图划分问题
        - 3）展示服务内部复杂性 + 模型扩散问题

    - 3.2 前端 BFF 模式

- 4. 基于 GraphQL 及元数据的信息聚合架构设计

    - 4.1 整体思路
    - 4.2 核心设计

        - 4.2.1 取数展示分离
        - 4.2.2 查询模型归一

            - 1）查询接口设计的难点
            - 2）查询模型归一化设计

        - 4.2.3 元数据驱动架构

- 5. 针对 GraphQL 的优化实践

    - 5.1 使用简化

        - 1）GraphQL 直接使用问题
        - 2）取数接口标准化
        - 3）聚合编排自动化

    - 5.2 性能优化

        - 5.2.1 GraphQL 性能问题
        - 5.2.2 GraphQL 编译优化

            - 1）GraphQL 语言原理概述
            - 2）Schema 及 Query 编译缓存

        - 5.2.3 GraphQL 执行引擎优化

            - 1）GraphQL 执行机制及问题
            - 2）类型转换优化

        - 5.2.4 GraphQL-DataLoader 调度优化

            - 1）DataLoader 基本原理
            - 2）DataLoader 调度问题
            - 3）DataLoader 调度优化

- 6. 新架构对研发模式的影响

    - 6.1 聚焦业务的开发模式
    - 6.2 研发流程升级

- 7. 总结

### 6. 速度与压缩比如何兼得？压缩算法在构建部署中的优化	 103

- 背景

  通常而言，服务发布平台的构建部署的流程（镜像部署除外）会经过构建（同步代码 -> 编译 -> 打包 -> 上传）、部署（下载包 -> 解压到目标机器 -> 重启服务）等步 骤。以美团内部的发布平台 Plus 为例，最近我们发现一些发布项在构建产物打包压 缩的过程中耗时比较久。


- 方案对比

    - 准备场景数据
    - 发布项的包大小分析

        -  数据大的情况下计算结果会比小数据误差小很多。
        -  能够覆盖绝大多数应用场景。
        -  效果对比明显，可以看到是否有明显的提升。

    - gzip

        - 文件格式

    - Brotli
    - Zstd

        - Zstd 全称叫 Zstandard，是一个提供高压缩比的快速压缩算法，主要实现的编程语
        - 言为 C，是 Facebook 的 Yann Collet 于 2016 年发布的，Zstd 采用了有限状态
        - 熵（Finite State Entropy，缩写为 FSE）编码器。该编码器是由 Jarek Duda 基于
        - ANS 理论开发的一种新型熵编码器，提供了非常强大的压缩速度 / 压缩率的折中方案
        - （事实上也的确做到了“鱼”和“熊掌”兼得）。Z

    - 官方 Benchmark 数据对比
    - LZ4
    - Pigz
    - ISA-L Acceleration Version

- 使用

    - 压缩时间

- Pzstd
- Pied Piper (Middle-out compression)
- 兼容性
- 选型

    - 对比数据

        - 解压缩时间对比

    - 评分策略

- 压缩平均节省了 90% 的时间。

### 7. 百亿规模 API 网关服务 Shepherd 的设计与实现	 121

- 一、背景介绍

    - 1.1 API网关是什么？
    - 1.2 为什么要做Shepherd API网关？
    - 1.3 使用Shepherd带来的收益是什么？

- 二、技术设计与实现

    - 2.1 整体架构
    - 2.2 高可用设计
    - 2.3 易用性设计
    - 2.4 可扩展性设计

- 三、未来规划

    - 3.1 云原生架构演进
    - 3.2 静态网站托管
    - 3.3 组件市场

### 8. TensorFlow 在推荐系统中的分布式训练优化实践	 142

- 1. 背景

    - 所有参数都是用 Variable 表达，对于百亿以上的稀疏参数开辟了大量的内存，造成了资源的浪费；
    - ● 只支持百级别 Worker 的分布式扩展，对上千 Worker 的扩展性较差；
    - ● 由于不支持大规模稀疏参数动态添加、删除，增量导出，导致无法支持 OnlineLearning；
    - ● 大规模集群运行时，会遇到慢机和宕机；由于框架层不能处理，导会致任务运行异常。

- 2. 大规模训练优化挑战

    - 2.1 业务迭代带来的挑战
    - 2.2 系统负载分析

        - 2.2.1 问题分析工具链
        - 2.2.2 业务视角的负载分析

- 3. 优化实践

    - 3.1 大规模稀疏参数介绍
    - 3.2 分布式负载均衡优化
    - 3.3 通信优化

        - 3.3.1 Memory Registration 优化
        - 3.3.2 RDMA 静态分配器
        - 3.3.3 Multi RequestBuffer 与 CQ 负载均衡
        - 3.3.4 Send-Driven & Rendezvous-Bypass

    - 3.4 延迟优化

        - 3.4.1 稀疏域参数聚合
        - 3.4.2 Embedding 流水线优化

    - 3.5 单实例 PS 并发优化

        - 3.5.1 高性能的 HashTable
        - 3.5.2 HashTable BucketPool

    - 3.6 单位算力吞吐优化

- 4. 大规模稀疏算法建模
- 5. 总结与展望

### 9. 美团 Serverless 平台 Nest 的探索与实践	 165

- 1. 背景

Serverless 一词于 2012 年被提出，2014 年由于亚马逊的 AWS Lambda 无服务器
计算服务的兴起，而被大家广泛认知。Serverless 通常被直译成“无服务器”，无服
务器计算是可以让用户在不考虑服务器的情况下构建并运行应用程序。使用无服务器
计算，应用程序仍在服务器上运行，但所有服务器管理工作均由 Serverless 平台负
责。如机器申请、代码发布、机器宕机、实例扩缩容、机房容灾等都由平台帮助自动
完成，业务开发只需考虑业务逻辑的实现即可。


- 2. 快速验证，落地 MVP 版本

    - 2.1 技术选型

        - 2.1.1 演进路线
        - 2.1.2 基础设施
        - 2.1.3 开发语言

    - 2.2 架构设计
    - 2.3 流程设计
    - 2.4 函数触发
    - 2.5 函数执行
    - 2.6 弹性伸缩

- 3. 优化核心技术，保障业务稳定性

    - 3.1 弹性伸缩优化
    - 3.2 冷启动优化
    - 3.3 高可用保障

        - 3.3.1 平台高可用
        - 3.3.2 业务高可用

    - 3.4 容器稳定性优化

- 4. 完善生态，落实收益

    - 4.1 提供研发工具
    - 4.2 融合技术生态
    - 4.3 开放平台能力
    - 4.4 支持合并部署

- 5. 落地场景、收益

    - 5.1 落地场景
    - 5.2 落地收益

- 6. 未来规划

### 10. 算法平台在线服务体系的演进与实践	 185

- 0. 写在前面
- 1. 图灵平台介绍

    - ● 机器学习平台：提供模型训练、任务调度、模型评估和模型调优等功能，基于DAG 实现拖拽式的可视化模型训练。
    - ● 特征平台：提供在线和离线特征生产、特征抽取和特征聚合等功能，并推送到在线的特征库，提供高性能的特征获取服务。
    - ● 图灵在线服务：Online Serving，以下简称图灵 OS，为特征获取、数据预处理、模型和算法策略的线上部署及高性能计算提供统一的平台化解决方案。
    - ● AB 实验平台：提供事前的 AA 分组，事中的 AB 分流和事后的效果评估等功能，覆盖 AB 实验的完整生命周期。

- 2. 图灵 OS 的建设背景
- 3. 图灵 OS 1.0

    - 3.1 图灵 OS 1.0 介绍

        - 3.1.1 特征获取
        - 3.1.2 模型计算
        - 3.1.3 算法计算

    - 3.2 图灵 OS 1.0 遗留问题

- 4. 图灵 OS 2.0

    - 4.1 标准化轻量级 SDK
    - 4.2 算法插件化
    - 4.3 数据通道
    - 4.4 算法编排
    - 4.5 多模式集成
    - 4.6 图灵沙箱
    - 4.7 统一回放平台
    - 4.8 性能压测及调优

- 5. 图灵 OS 2.0 建设成果

    - 5.1 算法研发流程
    - 5.2 图灵 OS 2.0 使用汇总

- 6. 总结及未来展望

### 11. 美团终端消息投递服务 Pike 的演进之路	 207

- 1. Pike 的前世今生

    - 1.1 Pike 1.0 的诞生背景
    - 1.2 Pike 1.0 的工作流程
    - 1.3 Pike 1.0 的优势
    - 1.4 Pike 1.0 的痛点

        - 1.4.1 代码结构耦合
        - 1.4.2 账号体系混乱
        - 1.4.3 推送连接不稳定
        - 1.5 Pike 2.0 的诞生

- 2. Pike 2.0 架构设计

    - 2.1 设计思想
    - 2.2 整体架构

        - 2.2.1 Pike 接口层
        - 2.2.2 Pike 通道层
        - 2.2.3 TNTunnel 通道层

- 3. Pike 2.0 工作机制

    - 3.1 PikeClient 生命周期
    - 3.2 PikeClient 工作模式

        - 3.2.1 共享通道模式
        - 3.2.2 独立通道模式

    - 3.3 PikeClient 保活机制

        - 3.3.1 心跳探测
        - 3.3.2 重连机制
        - 3.3.3 通道巡检

- 4. Pike 2.0 新增特性

    - 4.1 聚合消息

        - 4.1.1 设计思想
        - 4.1.2 方案流程

    - 4.2 消息保序

        - 4.2.1 粘性会话

          粘性会话指的是同一客户端连接上的消息固定转发至某一
          特定的业务方机器处理，客户端断连重连后，保持新连接上的消息仍转发至该业务
          机器。


		- 4.2.2 时序一致性

- 5. Pike 2.0 稳定性保障

    - 5.1 Pike 2.0 监控体系
    - 5.2 Pike 2.0 个案用户追踪

- 6. Pike 2.0 建设成果
- 7. 总结与未来展望

### 12. 新一代 CTR 预测服务的 GPU 优化实践	 227

- 1. 背景

- 2. CTR 模型 GPU 推理的挑战

    - 2.1 应用层的挑战
    - 2.2 框架层的挑战
    - 2.3 硬件层的挑战

- 3. 优化手段

    - 3.1 算子融合

        - 3.1.1 TF-TVM 自动切图优化
        - 3.1.2 计算图等价替换

    - 3.2 CPU-GPU 数据传输优化
    - 3.3 高频子图手工优化
    - 3.4 CPU-GPU 分流

- 4. 压测性能分析
- 5. 整体架构
- 6. 不足之处与未来规划

### 13. 美团弹性伸缩系统的技术演进与落地实践	 241

- 前言
- 一、弹性伸缩系统演进

    - 弹性伸缩 1.0 架构
    - 弹性伸缩 2.0 架构

- 二、挑战与应对之策

    - 2.1 技术挑战

        - 2.1.1 弹性调度
        - 2.1.2 库存管控

            - 2.1.2.1 多租户管理
            - 2.1.2.2 常态 - 资源保障
            - 2.1.2.3 应急 - 资源保障

    - 2.2 推广思路
    - 2.3 运营难题

        - 2.3.1 配置问题
        - 2.3.2 启动问题
        - 2.3.3 性能问题

- 三、业务赋能场景

    - 3.1 节假日扩缩容
    - 3.2 日常高峰期扩容
    - 3.3 应急资源保障
    - 3.4 服务链路扩缩容

- 四、弹性伸缩未来规划

## 后端| 2020 - 263

### 1. Java线程池实现原理及其在美团业务中的实 263

- 一、写在前面

    - 1.1 线程池是什么
    - 1.2 线程池解决的问题是什么

- 二、线程池核心设计与实现

    - 2.1 总体设计
    - 2.2 生命周期管理
    - 2.3 任务执行机制

        - 2.3.1 任务调度
        - 2.3.2 任务缓冲
        - 2.3.3 任务申请
        - 2.3.4 任务拒绝

    - 2.4 Worker 线程管理

        - 2.4.1 Worker 线程
        - 2.4.2 Worker 线程增加
        - 2.4.3 Worker 线程回收
        - 2.4.4 Worker 线程执行任务

- 三、线程池在业务中的实践

    - 3.1 业务背景

        - 场景 1：快速响应用户请求
        - 场景 2：快速处理批量任务

    - 3.2 实际问题及方案思考

        - 1. 能否不用线程池 ?
        - 2. 追求参数设置合理性？
        - 3. 线程池参数动态化？

    - 3.3 动态化线程池

        - 3.3.1 整体设计
        - 3.3.2 功能架构

    - 3.4 实践总结

### 2. 美团万亿级KV存储架构与实践 294

- 1. 美团点评 KV 存储发展历程
- 2. 内存 KV Squirrel 架构和实践

    - 1. 高可用架构

        - 1. 宏观

            - Squirrel 节点容灾

                - 通过上述方案，我们把从库的摘除时间从 30 秒降低到了 5 秒

            - Squirrel 跨地域容灾

        - 2. 微观

            - 1. 端到端的高成功率问题

                - 1. 数据迁移造成超时抖动。
                -  2. 持久化造成超时抖动。
                -  3. 热点 Key 请求导致单节点过载。

            - 2. 解决方案

                - 1. Squirrel 智能迁移
                - 2. Squirrel 持久化重构
                - 3. Squirrel 热点 Key

- 3. 持久化 KV Cellar 架构和实践

    - 1. Cellar 节点容灾
    - 2. Cellar 跨地域容灾
    - 3. Cellar 强一致
    - 4. Cellar 智能迁移
    - 5. Cellar 快慢列队
    - 6. Cellar 热点 Key

- 4. 发展规划和业界趋势

### 3. Java中9种常见的CMSGC问题分析与解决-315

- 1. 写在前面

    - 1.1 引言
    - 1.2 概览

- 2. GC 基础

    - 2.1 基础概念
    - 2.2 JVM 内存划分
    - 2.3 分配对象
    - 2.4 收集对象

        - 2.4.1 识别垃圾
        - 2.4.2 收集算法

    - 2.5 收集器

        - 2.5.1 分代收集器
        - 2.5.2 分区收集器
        - 2.5.3 常用收集器
        - 2.5.4 其他收集器

    - 2.6 常用工具

        - 2.6.1 命令行终端
        - 2.6.2 可视化界面

- 3. GC 问题判断

    - 3.1 判断 GC 有没有问题？

        - 3.1.1 设定评价标准

          一次停顿的时间不超过应用服务的 TP9999，GC 的吞吐量不小于99.99%


		- 3.1.2 读懂 GC Cause

	- 3.2 判断是不是 GC 引发的问题？
	- 3.3 问题分类导读

		- 3.3.1 Mutator 类型
		- 3.3.2 GC 问题分类
		- 3.3.3 排查难度

- 4. 常见场景分析与解决

    - 4.1 场景一：动态扩容引起的空间震荡

        - 4.1.1 现象
        - 4.1.2 原因
        - 4.1.3 策略
        - 4.1.4 小结

    - 4.2 场景二：显式 GC 的去与留

        - 4.2.1 现象
        - 4.2.2 原因
        - 4.2.3 策略
        - 4.2.4 小结

    - 4.3 场景三：MetaSpace 区 OOM

        - 4.3.1 现象
        - 4.3.2 原因
        - 4.3.3 策略
        - 4.3.4 小结

    - 4.4 场景四：过早晋升
    - 4.5 场景五：CMS Old GC 频繁
    - 4.6 场景六：单次 CMS Old GC 耗时长
    - 4.7 场景七：内存碎片 & 收集器退化
    - 4.8 场景八：堆外内存 OOM
    - 4.9 场景九：JNI 引发的 GC 问题

- 5. 总结

    - 5.1 处理流程（SOP）

- 6. 写在最后

### 4. 美团配送A/B评估体系建设实践-382

- 1. A/B 平台简介
- 2. 为什么要强调评估体系建设

    - 2.1 分流业务场景需要
    - 2.2 业务决策的重要依据

- 3.A/B 评估体系构建

    - 3.1 权威完备的指标体系

        - 3.1.1 整体架构
        - 3.1.2 数据集成
        - 3.1.3 数据基建
        - 3.1.4 元数据管理
        - 3.1.5 模型配置

    - 3.2 科学权威的评估方式

        - 3.2.1 假设检验

            - 3.2.1.1 两个假设
            - 3.2.1.2 两类错误
            - 3.2.1.3 T 检验
            - 3.2.1.4 利用 P 值决策

        - 3.2.2 基于假设检验的科学评估

            - 3.2.2.1 AA 分组
            - 3.2.2.2 A/B 效果评估
            - 3.2.2.3 技术实现

### 5. 新一代垃圾回收器ZGC的探索与实践-396

- 1. GC 之痛

    - CMS 与 G1 停顿时间瓶颈

- 2. ZGC 原理

    - 全并发的 ZGC
    - ZGC 关键技术

        - 着色指针
        - 读屏障

    - ZGC 并发处理演示

- 3. ZGC 调优实践

    - 调优基础知识

        - 理解 ZGC 重要配置参数
        - 理解 ZGC 触发时机

            - ZGC 的核心特点是并发，GC 过程中一直有新的对象产生
            - ZGC 有多种 GC 触发机制，总结如下

        - 理解 ZGC 日志
        - 理解 ZGC 停顿原因

    - 调优案例

        - 案例一：秒杀活动中流量突增，出现性能毛刺
        - 案例二：压测时，流量逐渐增大到一定程度后，出现性能毛刺
        - 案例三： 单次 GC 停顿时间 30ms，与预期停顿 10ms 左右有较大差距
        - 案例四：服务启动后，运行时间越长，单次 GC 时间越长，重启后恢复

- 4. 升级 ZGC 效果

    - 延迟降低
    - 吞吐下降

- 总结

### 6. 设计模式在外卖营销业务中的实践-416

### 7. 美团命名服务的挑战与演进	 438

- 一、MNS 1.0 简介
- 二、MNS 1.0 遇到的问题和挑战
- 三、MNS 2.0

    - 1. 整体架构
    - 2. 演进成果

        - 2.1 流量洪峰 & 平行扩展
        - 2.2 推送风暴 & 性能提升
        - 2.3 融入 Service Mesh
        - 2.4 无损迁移
        - 2.5 演进总结

- 四、命名服务对业务的赋能

    - 4.1 单元化 & 泳道
    - 4.2 平滑发布 & 弹性伸缩
    - 4.3 服务数据

- 五、未来展望

### 8. 美团 MySQL 数据库巡检系统的设计与应用	 459

- 一、背景
- 二、设计原则
- 三、系统架构

    - 1. 执行层
    - 2. 存储层
    - 3. 应用层

- 四、巡检项目
- 五、成果
- 六、未来规划

### 9. Kubernetes 如何改变美团的云基础设施？	 468

- 一、背景与现状
- 二、OpenStack 到 Kubernetes 转变的障碍和收益

    - 2.1 容器化的过程和障碍
    - 2.2 容器化过程的挑战和应对策略

        - 2.2.1 复杂灵活、动态和可配置的调度策略
        - 2.2.2 精细化的资源调度和运营
        - 2.2.3 应用稳定性的提升和治理

            - 2.2.3.1 容器复用
            - 2.2.3.2 Numa 感知与绑定
            - 2.2.3.3 其他稳定性优化

        - 2.2.4 平台型业务容器化
        - 2.2.5 业务资源优先级保障
        - 2.2.6 云原生架构的落地

    - 2.3 基础设施迁移后的收益

- 三、运营大规模 Kubernetes 集群的挑战和应对策略

    - 3.1 核心组件优化与升级
    - 3.2 平台化与运营效率
    - 3.3 风险控制和可靠性保障

- 四、总结与未来展望

    - 4.1 经验心得
    - 4.2 未来展望

### 10. 基本功 | Java 即时编译器原理解析及实践	 486
（阅读时长：1小时41分）

- 一、导读
- 二、Java 的执行过程

    - 1. JVM 中的编译器
    - 2. 分层编译
    - 3. 即时编译的触发

- 三、编译优化

    - 1. 中间表达形式（Intermediate Representation）

        - C1 中的中间表达形式
        - Sea-of-Nodes IR
        - Phi And Region Nodes
        - Global Value Numbering

    - 2. 方法内联

        - 方法内联的条件
        - 虚函数内联

    - 3. 逃逸分析

        - 锁消除
        - 栈上分配
        - 标量替换
        - 部分逃逸分析

    - 4. Loop Transformations
    - 5. 窥孔优化与寄存器分配

- 四、实践

    - 1. 编译相关的重 * 要参数
    - 2. 通过 JITwatch 分析编译日志
    - 3. 使用 Graal 编译器

        - 使用 Graal 编译器后性能表现
        - Graal 编译器的问题

- 五、总结

### 11. MyBatis 版本升级引发的线上告警回顾及原理分析	 519

- 背景
- 报警原因定位
- 详细分析

    - MyBatis 升级 3.2.4 版本的官方 Release 公告
    - 以版本 3.2.3 为例，MyBatis 构建 SQL 语句过程的原理分析
    - 以版本 3.2.4 为例，相比版本 3.2.3，MyBatis 构建 SQL 语句过程的变化分析

- 总结

### 12. 复杂环境下落地 Service Mesh 的挑战与实践	 535
（阅读时长：30分）

- 一、美团服务治理建设进展

    - 1.1 服务治理发展史
    - 1.2 服务治理体系的困境

- 二、服务治理体系优化的思路与挑战

    - 2.1 优化思路
    - 2.2 复杂性挑战

- 三、美团落地 Service Mesh 的解决方案

    - 3.1 整体架构
    - 3.2 兼容性解决方案
    - 3.3 异构性解决方案
    - 3.4 规模化解决方案

        - 3.4.1 开源 Istio 问题分析
        - 3.4.2 措施一：横向数据分片
        - 3.4.3 措施二：纵向分层订阅
        - 3.4.4 措施三：集中式健康检测

    - 3.5 交易型场景困境下的解决方案

        - 3.5.1 业务属性分析
        - 3.5.2 精细化运营体系建设
        - 3.5.3 通信性能优化
        - 3.5.4 流量多级保护

- 四、总结

### 13. C++ 服务编译耗时优化原理及实践 - 549
（阅读时长：20分）

- 一、背景
- 二、编译原理及分析

    - 2.1 编译原理介绍
    - 2.2 C++ 编译特点

- 三、服务问题分析

    - 3.1 编译展开分析
    - 3.2 头文件依赖分析
    - 3.3 编译耗时结果分段统计
    - 3.4 分析工具建设

- 四、优化方案与实践

    - 4.1 通用编译加速方案
    - 4.2 代码优化方案与实践
    - 4.3 优化效果
    - 4.4 守住优化成果

- 五、总结

### 14. 速度与压缩比如何兼得？压缩算法在构建部署中的优化	 572

### 15. 美团 OCTO 万亿级数据中心计算引擎技术解析	 590
（阅读时长：20分）

- 一、OCTO 数据中心简介

    - 1.1 系统介绍

        - 1.1.1 OCTO 系统介绍
        - 1.1.2 OCTO 数据中心业务介绍
        - 1.1.3 OCTO 原架构介绍

    - 1.2 问题、目标与挑战

        - 1.2.1 原架构面临的问题
        - 1.2.2 新架构设计的目标
        - 1.2.3 新架构面临的挑战

- 二、计算引擎技术设计解析

    - 2.1 方案选型
    - 2.2 系统设计思路
    - 2.3 技术方案详细解析

        - 2.3.1 数据流解析
        - 2.3.2 计算模式解析
        - 2.3.3 关键技术总结

- 三、优化效果

### 16. Intel PAUSE 指令变化影响到 MySQL 的性能，该如何解决？	 599
（阅读时长：10分）

- 1. 背景
- 2. 性能问题分析

    - 2.1 Grantly 与 Purley CPU 性能差异

- 3.CPU 性能跟踪

    - 3.1 定位热点函数
    - 3.2 ut_delay 和 PAUSE 之间的关联与性能影响

        - 3.2.1 MySQL ut_delay 实现
        - 3.2.2 PAUSE 指令周期的演变
        - 3.2.3 Intel 提升 PAUSE 猜想

    - 3.3 PAUSE 导致写瓶颈分析

- 4. 针对 PAUSE 指令和 spin 参数优化与探索

    - 4.1 MySQL spin 参数优化

        - 4.1.1 MySQL 5.7 spin 参数优化

    - 4.2 MySQL8.0 spin 新特性移植

        - 4.2.1 spin_wait_pause_multiplier 移植
        - 4.2.2 spin_wait_pause_multiplier 实现
        - 4.2.3 移植 spin_wait_pause_multiplier patch 优化

    - 4.3 PAUSE 指令周期优化

- 5. 总结

### 17. 美团内部讲座｜周烜：华东师范大学的数据库系统研究	 619
（阅读时长：20分）

- 00 引言
- 01 数据库系统的形态变化

    - 1.1 什么引起了数据库系统的形态变化？

        - 1.1.1 应用需求的变化
        - 1.1.2 软件开发模式的转变
        - 1.1.3 硬件平台的革新

    - 1.2 数据库系统的未来发展趋势

- 02 华师大的数据库系统研究

    - 2.1 研究团队
    - 2.2 研究成果

        - 2.2.1 分布式事务
        - 2.2.2 数据库系统解耦合
        - 2.2.3 新硬件

- 03 相关论文列表

## 后端 | 2019 - 651（8小时10分）

### 1. Java 魔法类：Unsafe 应用解析 - 652
（阅读时间：30分钟）

- 前言
- 基本介绍
- 功能介绍

    - 内存操作

        - 使用堆外内存的原因
        - 典型应用

    - CAS

        - 典型应用

    - 线程调度

        - 典型应用

    - Class 相关

        - 典型应用

    - 对象操作

        - 典型应用

    - 数组操作

        - 典型应用

    - 内存屏障

        - 典型应用

    - 系统信息获取

        - 典型应用

### 2. Java 动态追踪技术探究 - 669
（阅读时间：20分钟）

- 从 JSP 说起
- Java 对象行为
- java.lang.instrument.Instrumentation
- 直接操作字节码

    - ASM

    - BTrace

- Arthas
- 尾声：三生万物

### 3. 字节码增强技术探索	 681
（阅读时间：50分钟）

- 1. 字节码

    - 1.1　什么是字节码？
    - 1.2　字节码结构

        - （1）魔数（Magic Number）
        - （2）版本号
        - （3）常量池（Constant Pool）
        - （4）访问标志
        - （5）当前类名
        - （6）父类名称
        - （7）接口信息
        - （8）字段表
        - （9）方法表
        - （10）附加属性表

    - 1.3　字节码操作集合
    - 1.4　操作数栈和字节码
    - 1.5　查看字节码工具

- 2. 字节码增强

    - 2.1　ASM

        - 2.1.1　ASM API

            - 2.1.1.1　核心 API
            - 2.1.1.2　树形 API

        - 2.1.2　直接利用 ASM 实现 AOP
        - 2.1.3　ASM 工具

    - 2.2　Javassist

- 3. 运行时类的重载

    - 3.1　问题引出
    - 3.2　Instrument
    - 3.3　JVMTI & Agent & Attach API
    - 3.4　使用场景

- 4. 总结
- 5. 参考文献

### 4. JVM CPU Profiler 技术原理及源码深度解析	 708
（阅读时间：30分钟）

- CPU Profiler 简介
- JVM Agent 简介

    - JVMTI Agent
    - Java Agent

- CPU Profiler 原理解析

    - Sampling vs Instrumentation
    - 基于 Java Agent + JMX 实现
    - 基于 JVMTI + GetStackTrace 实现
    - SafePoint Bias 问题
    - 基于 JVMTI + AsyncGetCallTrace 实现

- 生成性能火焰图
- HotSpot 的 Dynamic Attach 机制解析

    - 通过 sun.tools 进行 Attach
    - 直接对 HotSpot 进行 Attach

- Attach 补充介绍
- 总结

### 5. Java 动态调试技术原理及实践 731
（阅读时间：50分钟）

- 2.1　Agent 的实现模式

    - 2.1.1　通过 Java Instrumentation API

- 2.2　启动时加载 Agent

    - 2.2.1　参数解析
    - 2.2.2　执行加载操作
    - 2.2.3　instrument 动态链接库

- 2.3　运行时加载 Agent

    - 2.3.1　AttachListener
    - 2.3.2　运行时加载 Agent 的实现
    - 2.3.3　load 命令的实现

- 3.1　动态字节码修改的限制
- 3.2　重定义类字节码的实现细节
- 4.1　Java-debug-tool 整体架构
- 4.2　Java-debug-tool 的字节码增强方案

    - 4.2.1　字节码增强
    - 4.2.2　Advice 的工作方式

- 4.3　Java-debug-tool 的命令设计与实现

    - 4.3.1　命令执行
    - 4.3.2 获取方法执行视图

- 4.4　Java-debug-tool 与同类产品对比分析

### 6. 从 ReentrantLock 的实现看 AQS 的原理及应用	 760
（阅读时间：50分钟）

- 1. ReentrantLock

    - 1.1　ReentrantLock 特性概览
    - 1.2　ReentrantLock 与 AQS 的关联

- 2. AQS

    - 2.1　原理概览

        - 2.1.1　AQS 数据结构
        - 2.1.2　同步状态 State

    - 2.2　AQS 重要方法与 ReentrantLock 的关联
    - 2.3　通过 ReentrantLock 理解 AQS

        - 2.3.1　线程加入等待队列

            - 2.3.1.1　加入队列的时机
            - 2.3.1.2　如何加入队列
            - 2.3.1.3　等待队列中线程出队列时机

        - 2.3.2　CANCELLED 状态节点生成
        - 2.3.3　如何解锁
        - 2.3.4　中断恢复后的执行流程
        - 2.3.5　小结

- 3. AQS 应用

    - 3.1　ReentrantLock 的可重入应用
    - 3.2　JUC 中的应用场景
    - 3.3　自定义同步工具

### 7. 美团点评 Kubernetes 集群管理实践 796
（阅读时间：20分钟）

- 背景
- 美团点评集群管理与调度系统
- 架构全览
- 架构介绍
- Kubernetes 管理与实践
- 集群运营现状
- Kubernetes 优化与改造

    - kube-scheduler 性能优化

        - 预选失败中断机制
        - 局部最优解

- kubelet 改造

    - 风险可控性
    - 容器重启策略
    - IP 状态保持
    - 限制驱逐策略
    - 可扩展性

        - 资源调配
        - 增强容器
        - 应用原地升级
        - 镜像分发

- 资源管理与优化
- 优化关键技术

    - 策略优化
    - 在线集群优化

### 8. 美团集群调度系统 HULK 技术演进	 811
（阅读时间：20分钟）

- 一、背景
- 二、HULK2.0 集群调度系统总体架构图
- 三、调度系统痛点、解法

    - 3.1　业务扩缩容异常
    - 3.2　业务定制化需求
    - 3.3　调度策略优化
    - 3.4　重编排问题

- 四、弹性伸缩平台痛点、解法

    - 4.1　多策略决策不一致
    - 4.2　扩缩不幂等
    - 4.3　线上代码多版本
    - 4.4　资源保障问题
    - 4.5　端到端时效问题

- 五、经验总结

### 9. 保障 IDC 安全：分布式 HIDS 集群架构设计	 824
（阅读时间：50分钟）

- 背景
- 需求描述
- 分析需求
- 技术难点
- 架构设计与技术选型

    - CAP 的解释
    - CAP 的选择
    - 满足 CP 的产品选择
    - etcd、ZooKeeper、Consul 对比
    - 选择 etcd
    - etcd Key 的设计
    - etcd 集群管理
    - etcd Cluster 节点扩容
    - 分布式 HIDS 集群架构图
    - 编程语言选择

- 产品架构大方向

    - 产品实现
    - 框架设计

        - 沙箱隔离
        - IConfig
        - Timer、Clock 调度
        - Catcher
        - 抽象接口
        - 限流

            - 网络 IO
            - 磁盘 IO
            - IRetry

        - 事件拆分
        - 监控告警

            - Agent 数量感知，依赖 Watch 数字，实时准确感知。
            - 程序运行状态监控告警
            - 数据采集告警

        - 熔断
        - 灰度管理

            - 数据上报通道
            - 主进程

        - 进程监控

            - 方案选择
            - 系统侵入性比较
            - 兼容性上比较
            - 数据准确性比较

    - 遇到的问题

        - 内核 Netlink 发送数据卡住
        - 疑似“内存泄露”问题

    - 项目进展
    - 总结

### 10. Leaf：美团分布式 ID 生成服务开源 847
（阅读时间：10分钟）

- Leaf 特性
- Leaf 诞生
- Leaf 双 Buffer 优化
- Leaf 动态调整 Step
- MySQL 高可用
- Leaf 监控
- Leaf Snowflake
- 未来规划

### 11. 美团大规模微服务通信框架及治理体系 OCTO 核心组件开源	 854
（阅读时间：5分钟）

- 背景
- 功能特性
- OCTO 整体架构
- OCTO 开源组件

    - 分布式服务通信框架（OCTO-RPC）
    - 服务注册中心（OCTO-NS）
    - 服务治理平台（OCTO-Portal）

- 关于开源
- 未来规划

### 12. 美团下一代服务治理系统 OCTO2.0 的探索与实践	 860
（阅读时间：35分钟）

- 一、OCTO 现状分析
- 二、技术选型及架构设计

    - 2.1　OCTO Mesh 技术选型
    - 2.2　OCTO Mesh 架构设计

- 三、关键设计解析

    - 3.1　大规模系统 Mesh 化系统能力建设
    - 3.2　异构治理系统融合设计
    - 3.3　稳定性保障设计
    - 3.4　运维体系设计

- 四、总结与展望

    - 4.1　经验总结

### 13. XGBoost 缺失值引发的问题及其深度分析	 876
（阅读时间：10分钟）

- 前言

    - 深入理解XGBoost

- 1. 背景
- 2. 执行结果不一致问题排查历程

    - XGBoost4j 中缺失值的处理
    - XGBoost on Spark 中缺失值的处理

- 3. XGBoost on Spark 源码中缺失值引入的不稳定问题
- 4. 问题解决

### 14. Spring Boot 引起的“堆外内存泄漏”排查及经验总结	 885
（阅读时间：20分钟）

- 背景
- 排查过程

    - 1. 使用 Java 层面的工具定位内存区域（堆内内存、Code 区域或者使用 unsafe.allocateMemory 和 DirectByteBuffer 申请的堆外内存）
    - 2. 使用系统层面的工具定位堆外内存

        - 首先，使用了 gperftools 去定位问题
        - 然后，使用 strace 去追踪系统调用
        - 接着，使用 GDB 去 dump 可疑内存
        - 再次，项目启动时使用 strace 去追踪系统调用
        - 最后，使用 jstack 去查看对应的线程

    - 3. 为什么堆外内存没有释放掉呢？

### 15. 美团点评效果广告实验配置平台的设计与实现	 897
（阅读时间：10分钟）

- 一、背景
- 二、方案设计

    - 目标
    - 设计思路
    - 实验分类

        - 水平实验

    - 架构图

- 三、模型设计

    - 1. 分流模型
    - 2. 实验命中模型
    - 3. 回滚模型

- 四、AB 实验实时效果
- 五、总结

### 16. 根因分析初探：一种报警聚类算法在业务系统的落地实施	 908
（阅读时间：30分钟）

- 背景
- 目标
- 设计
- 算法选择
- 算法描述
- 实现

    - 1. 提取报警特征
    - 2. 算法实现

        - （1）提取关键特征
        - （2）聚类算法
        - （3）min_size 选择
        - （4）聚类停止条件

    - 3. 泛化层次结构

- 实验

    - 1. 单依赖故障
    - 2. 无相关的多依赖同时故障
    - 3. 中间件与相关依赖同时故障

- 未来规划

### 17. 全链路压测自动化实践 926
（阅读时间：30分钟）

- 背景与意义
- 系统设计

    - 系统总体设计

        - 链路构建 / 比对
        - 链路治理
        - 压测配置管理
        - 压测验证检查
        - 数据构造
        - 压测计划管理
        - 故障诊断
        - 置信度评估

    - 链路治理模块设计
    - 数据构造模块设计
    - 压测验证模块设计
    - 压测计划管理模块设计

- 案例分享

    - 团队 / 服务注册
    - 链路治理
    - 应用改造与压测配置
    - Quake 准备
    - 数据构造
    - 压测实施

- 总结与展望

### 18. 降低软件复杂性一般原则和方法	 941
（阅读时间：20分钟）

- 一、前言
- 二、如何定义复杂性
- 三、解决复杂性的一般原则
- 四、解决复杂性之日拱一卒

    - 4.1　拒绝战术编程
    - 4.2　设计两次

- 五、解决复杂性之分层

    - 5.1　层次和抽象
    - 5.2　复杂性下沉
    - 5.3　异常处理

- 六、解决复杂性之分模块

    - 6.1　深模块和浅模块
    - 6.2　通用和专用
    - 6.3　信息隐藏
    - 6.4　拆分和合并

- 七、解决复杂性之注释

    - 7.1　注释的误区
    - 7.2　使用注释提升系统可维护性
    - 7.3　使用注释改善系统设计

- 八、后记
- 九、参考文档

*XMind - Trial Version*