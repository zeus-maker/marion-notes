# 《Leecode算法题解题思路》

## 1. 数组

### 1. 数组的特性

- 1. 由相同类型元素组成的有限集合
- 2. 存储地址的计算公式

	- LOC (aij)=LOC(第一个元素)+(aij前面的元素个数)×每个元素占的字节

- 3. 什么是压缩矩阵？
- 4. 什么样的举证可以压缩？
- 5. 什么是稀疏矩阵？

### 2. 数组的解题方法

### 3. 数组的题型归类

- 1. 数组中任意元素求和
- 2. 数组中元素查找
- 3. 数组中元素删除
- 4. 合并数组 
- 5. 数组和树结合的题

### 4. 数组的题型训练

### 5. 数组的应用场景

- 1. 贪吃蛇
- 2. 买卖股票的最佳时机
- 3. 逆波兰

### 记忆模板

- 1. 特性
- 2. 解题方法
- 3. 题型归类
- 4. 题型训练
- 5. 应用场景

## 2. 字符串

### 1. 特性

- 1. 字符串的比较、连接操作（不同编程语言实现方式有所不同）；
- 2. 涉及子串的操作，比如前缀，后缀等；
- 3. 字符串间的匹配操作，如 KMP 算法、BM 算法等。

### 2. 解题方法

### 3. 题型归类

- 1. 反转字符串
- 2. 回文字符串

### 4. 题型训练

### 5. 应用场景

- 1. 正则表达式
- 2. 爬虫

## 3. 链表

### 1. 特性

- 1. 每个节点包含存储数据和下一节点指针
- 2. 插入时间复杂度O(1)，查找O(n)
- 3. 优点：充分利用计算机内存空间，实现内存动态分配
- 4. 缺点：不能随机读取，增加了节点指针域，增大了节点开销
- 5. 链表允许插入和删除任意位置节点，但不允许随机存取
- 6. 链表的类型单向、双向、循环链表

### 2. 解题方法

- 1. 快慢指针
- 2. 递归
- 3. 迭代
- 4. 优先队列

### 3. 题型归类

- 1. 删除链表

	- 1. 快慢指针

- 2. 反转链表
- 3. 链表与树的转化
- 4. 链表与哈希结合
- 5. 跳表
- 6. 合并链表

	- 1. 迭代法

### 4. 题型训练

- 19. 删除链表的倒数第 N 个结点
（20分钟）

	- 1. 暴力解法

		- 1. 定义头结点
		- 2. 获得链表长度
		- 3. for遍历找到删除结点的上一结点
		- 4. cur.next = cur.next.next
		- 5. 返回链表头元素

	- 2. 栈
	- 3. 快慢指针

		- 1. 定义头结点
		- 2. 定义快慢指针指向虚拟头结点
		- 3. 快指针移动n个位置
		- 4. 快慢指针同时移动，移动到快指针指向null
		- 5. cur.next = cur.next.next
		- 6. 返回链表头元素

- 21. 合并两个有序链表
（25分钟）

	- 1. 递归法
	- 2. 迭代法

		- 1. 定义头结点head
		- 2. 定义头结点指针prev=head
		- 3. 判断l1和l2的大小，如果l1<=l2向后移动1位，将prev赋值后移1位
		- 4. 判断l1或者l2是否为null，prev.next = l1 | l2
		- 5. 返回head.next

- 23. 合并K个升序链表
（1小时20分钟）

	- 1. 顺序合并

		- 1. 将K个链表合并变成2个链表的子操作

	- 2. 分治合并

		- 1. 定义left和right的参数
		- 2. left==right返回结点
		- 3. left>right返回null
		- 4. 二分（left + right >> 1）链表递归调用merge，第一个参数right=mid；第二参数left=mid+1

	- 3. 使用优先队列合并

		- 1. 定义优先队列中结点Status类，val是最小的元素，ListNode当前链表
		- 2. 创建一个优先队列PriorityQueue<Status>
		- 3. for in 遍历链表数组，将链表转换成Status放入优先队列
		- 4. 定义头结点，定义头指针tail=head
		- 5. 从priorityQueue取poll元素f，给tail.next=f.ptr赋值
		- 6. 判断Status.next != null，将Status后移一位，放进优先队列

### 5. 应用场景

- 1. LRU和LFU策略
- 2. 病毒检测

## 4. 队列

### 1. 特性

- 1. 先进先出的线性表
- 2. 可以由数组和链表实现
- 3. 只能从队尾插入，对头删除
- 4. 实现广度优先搜索的数据结构

### 2. 解题方法

- 1. 优先队列
- 2. 单调队列

### 3. 题型归类

- 1. 队列与栈
- 2. 滑动窗口

### 4. 题型训练

- 239. 滑动窗口最大值
（1小时20分钟）

	- 方法一：优先队列

		- 1. 定义优先队列pq，元素格式<val, index>
		- 2. for循环将前k个元素放入pq
		- 3. 定义存储最大值的数组ans，第一次放入peek()
		- 4. 往后offer()移动一位元素，判断下标，弹出前面的元素，将优先最大值peek()放入ans
		- 5. 返回ans

	- 方法二：单调队列

		- 1. 解题思路

			- 1.想将我们第一个窗口的所有值存入单调双端队列中，单调队列里面的值为单调递减的。如果发现队尾元素小于要加入的元素，则将队尾元素出队，直到队尾元素大于新元素时，再让新元素入队，目的就是维护一个单调递减的队列。
			- 2.我们将第一个窗口的所有值，按照单调队列的规则入队之后，因为队列为单调递减，所以队头元素必为当前窗口的最大值，则将队头元素添加到数组中。
			- 3.移动窗口，判断当前窗口前的元素是否和队头元素相等，如果相等则出队。
			- 4.继续然后按照规则进行入队，维护单调递减队列。
			- 5.每次将队头元素存到返回数组里。
			- 5.返回数组

	- 方法三：分块 + 预处理

### 5. 应用场景

## 5. 栈

### 1. 特性

- 1. 有局限的线性表
- 2. 只能在表尾进行插入和删除
- 3. 表头称为栈底，表尾称为栈顶
- 4. 栈的操作除了栈顶的插入和删除，还有栈的初始化、判空、取栈顶元素

### 2. 解题方法

### 3. 题型归类

- 1. 回文链表
- 2. 栈与二叉树

### 4. 题型训练

### 5. 应用场景

- 1. 每日温度

## 6. 哈希

### 1. 特性

### 2. 解题方法

### 3. 题型归类

### 4. 题型训练

- 17. 电话号码的字母组合
（30分钟）

### 5. 应用场景

- 1. HashMap和ConcurrentHashMap

## 7. 树

### 1. 特性

- 1. 树是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。
- 2. 它是由 n(n>0)n(n>0) 个有限节点组成一个具有层次关系的集合。
- 3. 特点

	- 每个节点都只有有限个子节点或无子节点；
	- 没有父节点的节点称为根节点；
	- 每一个非根节点有且只有一个父节点；
	- 除了根节点外，每个子节点可以分为多个不相交的子树；
	- 树里面没有环路。

### 2. 解题方法

### 3. 题型归类

- 1. 二叉树的遍历
- 2. 路径总和
- 3. 二叉树的公共祖先
- 4. N叉树

### 4. 题型训练

- 94. 二叉树的中序遍历

	- 方法一：递归
	- 方法二：迭代
	- 方法三：Morris 中序遍历

- 96. 不同的二叉搜索树

- 337. 打家劫舍 III

### 5. 应用场景

## 8. 堆

### 1. 特性

- 1. 最大堆
- 2. 最小堆

### 2. 解题方法

### 3. 题型归类

- 1. 滑动窗口

### 4. 题型训练

### 5. 应用场景

## 9. 图

### 1. 特性

### 2. 解题方法

- 1. 深度优先算法
- 2. 广度优先算法
- 3. Dijkstra 算法
- 4. Bellman-Ford 算法
- 5. Floyd 算法
- 6. Prim 算法
- 7. Kruskal 算法

### 3. 题型归类

- 1. 图克隆
- 2. 课程表
- 3. 最短路径

### 4. 题型训练

### 5. 应用场景

## 10. 排序

### 1. 特性

### 2. 解题方法

### 3. 题型归类

- 1. 几数之和

### 4. 题型训练

### 5. 应用场景

## 11. 查找

### 1. 特性

### 2. 解题方法

### 3. 题型归类

### 4. 题型训练

### 5. 应用场景

## 12. 回溯算法

### 1. 特性

### 2. 解题方法

### 3. 题型归类

- 1. N皇后问题
- 2. 格雷编码

### 4. 题型训练

- 17. 电话号码的字母组合
（45分钟）

	- 1. 深度优先

		- 1. 自顶向下递归实现深搜
		- 2. 定义子问题
		- 3. 当前递归层结合子问题解决原问题

	- 2. 回溯

		- 1. 定义递归出口
		- 2. 当digits="2"时，返回["a", "b", "c"]
		- 3. 当digits="23"时，返回["ad","ae", "af"]
		- 4. 定义数组存储拼接后的元素，作为参数，digits的长度=循环次数，每次循环取不同的数字，然后StringBuffer拼接append返回，删除以拼接后数字

### 5. 应用场景

## 13. 贪心算法

### 1. 特性

- 1. 贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择，就能得到问题的答案。

### 2. 解题方法

### 3. 题型归类

- 1. 跳跃游戏
- 2. 买卖股票
- 3. 分发糖果

### 4. 题型训练

- 11. 盛最多水的容器

- 621. 任务调度器

### 5. 应用场景

## 14. 动态规划
（时间：2小时）

### 记忆模板

- 1. 特性

	- 1. 动态规划常常适用于有【重叠子问题】和【最优子结构】性质的问题，并且记录所有子问题的结果，因此动态规划方法所耗时间往往远少于朴素解法。
	- 2. 动态规划有自底向上和自顶向下两种解决问题的方式。自顶向下即记忆化递归，自底向上就是递推。
	- 3. 使用动态规划解决的问题有个明显的特点，一旦一个子问题的求解得到结果，以后的计算过程就不会修改它，这样的特点叫做无后效性，求解问题的过程形成了一张有向无环图。动态规划只解决每个子问题一次，具有天然剪枝的功能，从而减少计算量。

- 2. 解题方法

	- 1. 暴力法
	- 2. Math.max()

	- 3. 设定3种状态，定义状态转移方程式

- 3. 题型归类

	- 1. 最长回文字串
	- 2. 杨辉三角
	- 3. 打家劫舍
	- 4. 单词拆分

- 4. 题型训练

	- 370，最长公共子串和子序列
	- 5. 最长回文子串

- 5. 应用场景

### leecode官方

- 1. 中级算法

	- 跳跃游戏

	- 不同路径

	  所以我个人理解的动态规划解题的过程，其实就是先手动演算一下枚举出所有子问题的解，然后找前后几项之间的规律，然后递归公式就总结出来了，最后思考下边界条件（这道题边界条件就是当i - 1 < 0 时怎么处理），然后根据公式去理解，原来从原点到位置（i，j）的路径数量就是位置(i-1, j) 和(i, j-1)的路径数量之和！
	  
	  动态规划典型环节：
	  1、初始化：从(0,0)到首行、首列中的任意位置路径只有1条
	  2、状态转移条件：新的一行，或新的一列
	  3、状态转移表达式：pathNum(i, j) = pathNum(i - 1, j) + pathNum(i, j - 1)
	  4、退出条件：从节点(0,0)遍历到节点(m - 1, n - 1)，pathNum(m - 1, n - 1)中即为最终解
	  
	  作者：wkelake
	  链接：https://leetcode-cn.com/leetbook/read/top-interview-questions-medium/xvjigd/?discussion=ejfoaT
	  来源：力扣（LeetCode）
	  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	  

	- 零钱兑换

	- 最长上升子序列

- 2. 高级算法

### Bilibili视频

- 10分钟彻底搞懂“动态规划”算法

	- 1. 穷举法/暴力搜索
	- 2. 记忆化搜索/剪枝
	- 3.改写成迭代形式

- 【动态规划专题班】ACM总冠军、清华+斯坦福大神带你入门动态规划算法

	- 题型特点

		- 1.计数

			- 有多少种方式走到右下角
			- -有多少种方法选出k个数使得和是Sum

		- 2.求最大最小值

			- 从左上角走到右下角路径的最大数字和
			- -最长上升子序列长度

		- 3.求存在性

			- -取石子游戏，先手是否必胜
			- 能不能选出k个数使得和是Sum

	- ●常见动态规划类型

		- -坐标型动态规划(20%)
		- -序列型动态规划(20%)
		- -划分型动态规划(20%)
		- -区间型动态规划(15%)
		- -背包型动态规划(10%)
		- -最长序列型动态规划(5%)
		- -博弈型动态规划(5%)
		- -综合型动态规划(5%)

- 动态规划入门系列课程全集（数学建模清风主讲）

- B站最全的2021蓝桥杯算法课《算法很美》
（36小时）

### 微信读书

- 算法图解

*XMind - Trial Version*