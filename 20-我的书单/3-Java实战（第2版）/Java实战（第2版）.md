# Java实战（第2版）

## 第一部分 基础知识

### 第1章 Java 8、9、10以及11的变化

- 1.1 为什么要关心Java的变化
- 1.2 Java怎么还在变

	- 1.2.1 Java在编程语言生态系统中的位置
	- 1.2.2 流处理
	- 1.2.3 用行为参数化把代码传递给方法
	- 1.2.4 并行与共享的可变数据
	- 1.2.5 Java需要演变

- 1.3 Java中的函数

	- 1.3.1 方法和Lambda作为一等值
	- 1.3.2 传递代码：一个例子
	- 1.3.3 从传递方法到Lambda

- 1.4 流
- 1.5 默认方法及Java模块
- 1.6 来自函数式编程的其他好思想
- 1.7 小结

  ❏ 请记住语言生态系统的思想，以及语言面临的“要么改变，要么衰亡”的压力。虽然Java可能现在非常有活力，但你可以回忆一下其他曾经也有活力但未能及时改进的语言的命运，如COBOL。
  ❏ Java 8中新增的核心内容提供了令人激动的新概念和功能，方便我们编写既有效又简洁的程序。
  ❏ Java 8之前的编程实践并不能很好地利用多核处理器。
  ❏ 函数是一等值。记住方法如何作为函数式值来传递，还有Lambda是怎样写的。
  ❏ Java 8中流的概念使得集合的许多方面得以推广，但流让代码更易读，并允许并行处理流元素。
  ❏ Java对基于大型组件的程序设计以及系统需要不断演化的接口的支持一直都不太好。现在，你可以使用Java 9的模块构建你的系统，使用默认方法支持接口的持续演化，而不影响实现该接口的所有类。
  ❏ 其他来自函数式编程的有趣思想，包括处理null和使用模式匹配。
  

### 第2章 通过行为参数化传递代码

- 2.1 应对不断变化的需求

	- 2.1.1 初试牛刀：筛选绿苹果
	- 2.1.2 再展身手：把颜色作为参数
	- 2.1.3 第三次尝试：对你能想到的每个属性做筛选

- 2.2 行为参数化
- 2.3 对付啰唆

	- 2.3.1 匿名类
	- 2.3.2 第五次尝试：使用匿名类
	- 2.3.3 第六次尝试：使用Lambda表达式
	- 2.3.4 第七次尝试：将List类型抽象化

- 2.4 真实的例子

	- 2.4.1 用Comparator来排序
	- 2.4.2 用Runnable执行代码块
	- 2.4.3 通过Callable返回结果
	- 2.4.4 GUI事件处理

- 2.5 小结

  ❏ 行为参数化就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。
  ❏ 行为参数化可让代码更好地适应不断变化的要求，减轻未来的工作量。
  ❏ 传递代码就是将新行为作为参数传递给方法。但在Java 8之前这实现起来很啰唆。为接口声明许多只用一次的实体类而造成的啰唆代码，在Java 8之前可以用匿名类来减少。
  ❏ Java API包含很多可以用不同行为进行参数化的方法，包括排序、线程和GUI处理。
  

### 第3章 Lambda表达式

- 3.1 Lambda管中窥豹
- 3.2 在哪里以及如何使用Lambda

	- 3.2.1 函数式接口
	- 3.2.2 函数描述符

- 3.3 把Lambda付诸实践：环绕执行模式

	- 3.3.1 第1步：记得行为参数化
	- 3.3.2 第2步：使用函数式接口来传递行为
	- 3.3.3 第3步：执行一个行为
	- 3.3.4 第4步：传递Lambda

- 3.4 使用函数式接口

	- 3.4.1 Predicate
	- 3.4.2 Consumer
	- 3.4.3 Function

- 3.5 类型检查、类型推断以及限制

	- 3.5.1 类型检查
	- 3.5.2 同样的Lambda，不同的函数式接口
	- 3.5.3 类型推断
	- 3.5.4 使用局部变量

- 3.6 方法引用

	- 3.6.1 管中窥豹
	- 3.6.2 构造函数引用

- 3.7 Lambda和方法引用实战

	- 3.7.1 第1步：传递代码
	- 3.7.2 第2步：使用匿名类
	- 3.7.3 第3步：使用Lambda表达式
	- 3.7.4 第4步：使用方法引用

- 3.8 复合Lambda表达式的有用方法

	- 3.8.1 比较器复合
	- 3.8.2 谓词复合
	- 3.8.3 函数复合

- 3.9 数学中的类似思想

	- 3.9.1 积分
	- 3.9.2 与Java 8的Lambda联系起来

- 3.10 小结

  ❏ Lambda表达式可以理解为一种匿名函数：它没有名称，但有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常的列表。
  ❏ Lambda表达式让你可以简洁地传递代码。
  ❏ 函数式接口就是仅仅声明了一个抽象方法的接口。
  ❏ 只有在接受函数式接口的地方才可以使用Lambda表达式。
  ❏ Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的一个实例。
  ❏ Java 8自带一些常用的函数式接口，放在java.util.function包里，包括Predicate <T>、Function<T, R>、Supplier<T>、Consumer<T>和BinaryOperator<T>，如表3-2所述。
  ❏ 为了避免装箱操作，对Predicate<T>和Function<T, R>等通用函数式接口的基本类型特化：IntPredicate、IntToLongFunction等。
  ❏ 环绕执行模式（即在方法所必需的代码中间，你需要执行点儿什么操作，比如资源分配和清理）可以配合Lambda提高灵活性和可重用性。
  ❏ Lambda表达式所需要代表的类型称为目标类型。
  ❏ 方法引用让你重复使用现有的方法实现并直接传递它们。
  ❏ Comparator、Predicate和Function等函数式接口都有几个可以用来结合Lambda表达式的默认方法。
  

## 第二部分 使用流进行函数式数据处理

### 第4章 引入流

- 4.1 流是什么
- 4.2 流简介
- 4.3 流与集合

	- 4.3.1 只能遍历一次
	- 4.3.2 外部迭代与内部迭代

- 4.4 流操作

	- 4.4.1 中间操作
	- 4.4.2 终端操作
	- 4.4.3 使用流

- 4.5 路线图
- 4.6 小结

  ❏ 流是“从支持数据处理操作的源生成的一系列元素”。
  ❏ 流利用内部迭代：迭代通过filter、map、sorted等操作被抽象掉了。
  ❏ 流操作有两类：中间操作和终端操作。
  ❏ filter和map等中间操作会返回一个流，并可以链接在一起。可以用它们来设置一条流水线，但并不会生成任何结果。
  ❏ forEach和count等终端操作会返回一个非流的值，并处理流水线以返回结果。
  ❏ 流中的元素是按需计算的。
  

### 第5章 使用流

- 5.1 筛选

	- 5.1.1 用谓词筛选
	- 5.1.2 筛选各异的元素

- 5.2 流的切片

	- 5.2.1 使用谓词对流进行切片
	- 5.2.2 截短流
	- 5.2.3 跳过元素

- 5.3 映射

	- 5.3.1 对流中每一个元素应用函数
	- 5.3.2 流的扁平化

- 5.4 查找和匹配

	- 5.4.1 检查谓词是否至少匹配一个元素
	- 5.4.2 检查谓词是否匹配所有元素
	- 5.4.3 查找元素
	- 5.4.4 查找第一个元素

- 5.5 归约

	- 5.5.1 元素求和
	- 5.5.2 最大值和最小值

- 5.6 付诸实践

	- 5.6.1 领域：交易员和交易
	- 5.6.2 解答

- 5.7 数值流

	- 5.7.1 原始类型流特化
	- 5.7.2 数值范围
	- 5.7.3 数值流应用：勾股数

- 5.8 构建流

	- 5.8.1 由值创建流
	- 5.8.2 由可空对象创建流
	- 5.8.3 由数组创建流
	- 5.8.4 由文件生成流
	- 5.8.5 由函数生成流：创建无限流

- 5.9 概述
- 5.10 小结

  ❏ 你可以使用filter、distinct、takeWhile (Java 9)、dropWhile (Java 9)、skip和limit对流做筛选和切片。
  ❏ 如果你明确地知道数据源是排序的，那么用takeWhile和dropWhile方法通常比filter高效得多。
  ❏ 你可以使用map和flatMap提取或转换流中的元素。
  ❏ 你可以使用findFirst和findAny方法查找流中的元素。你可以用allMatch、noneMatch和anyMatch方法让流匹配给定的谓词。
  ❏ 这些方法都利用了短路：找到结果就立即停止计算；没有必要处理整个流。
  ❏ 你可以利用reduce方法将流中所有的元素迭代合并成一个结果，例如求和或查找最大元素。
  ❏ filter和map等操作是无状态的，它们并不存储任何状态。reduce等操作要存储状态才能计算出一个值。sorted和distinct等操作也要存储状态，因为它们需要把流中的所有元素缓存起来才能返回一个新的流。这种操作称为有状态操作。❏ 流有三种基本的原始类型特化：IntStream、DoubleStream和LongStream。它们的操作也有相应的特化。
  ❏ 流不仅可以从集合创建，也可从值、数组、文件以及iterate与generate等特定方法创建。
  ❏ 无限流所包含的元素数量是无限的（想象一下所有可能的字符串构成的流）。这种情况是有可能的，因为流中的元素大多数都是即时产生的。使用limit方法，你可以由一个无限流创建一个有限流。
  

### 第6章 用流收集数据

- 6.1 收集器简介

	- 6.1.1 收集器用作高级归约
	- 6.1.2 预定义收集器

- 6.2 归约和汇总

	- 6.2.1 查找流中的最大值和最小值
	- 6.2.2 汇总
	- 6.2.3 连接字符串
	- 6.2.4 广义的归约汇总

- 6.3 分组

	- 6.3.1 操作分组的元素
	- 6.3.2 多级分组
	- 6.3.3 按子组收集数据

- 6.4 分区

	- 6.4.1 分区的优势
	- 6.4.2 将数字按质数和非质数分区

- 6.5 收集器接口

	- 6.5.1 理解Collector接口声明的方法
	- 6.5.2 全部融合到一起

- 6.6 开发你自己的收集器以获得更好的性能

	- 6.6.1 仅用质数做除数
	- 6.6.2 比较收集器的性能

- 6.7 小结

  ❏ collect是一个终端操作，它接受的参数是将流中元素累积到汇总结果的各种方式（称为收集器）。
  ❏ 预定义收集器包括将流元素归约和汇总到一个值，例如计算最小值、最大值或平均值。这些收集器总结在表6-1中。
  ❏ 预定义收集器可以用groupingBy对流中元素进行分组，或用partitioningBy进行分区。
  ❏ 收集器可以高效地复合起来，进行多级分组、分区和归约。
  ❏ 你可以实现Collector接口中定义的方法来开发自己的收集器。
  

### 第7章 并行数据处理与性能

- 7.1 并行流

	- 7.1.1 将顺序流转换为并行流
	- 7.1.2 测量流性能
	- 7.1.3 正确使用并行流
	- 7.1.4 高效使用并行流

- 7.2 分支/合并框架

	- 7.2.1 使用RecursiveTask
	- 7.2.2 使用分支/合并框架的最佳做法
	- 7.2.3 工作窃取

- 7.3 Spliterator

	- 7.3.1 拆分过程
	- 7.3.2 实现你自己的Spliterator

- 7.4 小结

  ❏ 内部迭代让你可以并行处理一个流，而无须在代码中显式使用和协调不同的线程。
  ❏ 虽然并行处理一个流很容易，但是不能保证程序在所有情况下都运行得更快。并行软件的行为和性能有时是违反直觉的，因此一定要测量，确保你并没有把程序拖得更慢。
  ❏ 像并行流那样对一个数据集并行执行操作可以提升性能，特别是要处理的元素数量庞大，或处理单个元素特别耗时的时候。
  ❏ 从性能角度来看，使用正确的数据结构，如尽可能利用原始流而不是一般化的流，几乎总是比尝试并行化某些操作更为重要。
  ❏ 分支/合并框架让你得以用递归方式将可以并行的任务拆分成更小的任务，在不同的线程上执行，然后将各个子任务的结果合并起来生成整体结果。
  ❏ Spliterator定义了并行流如何拆分它要遍历的数据。
  

## 第三部分 使用流和Lambda进行高效编程

### 第8章 Collection API的增强功能

- 8.1 集合工厂

	- 8.1.1 List工厂
	- 8.1.2 Set工厂
	- 8.1.3 Map工厂

- 8.2 使用List和Set

	- 8.2.1 removeIf方法
	- 8.2.2 replaceAll方法

- 8.3 使用Map

	- 8.3.1 forEach方法
	- 8.3.2 排序
	- 8.3.3 getOrDefault方法
	- 8.3.4 计算模式
	- 8.3.5 删除模式
	- 8.3.6 替换模式
	- 8.3.7 merge方法

- 8.4 改进的ConcurrentHashMap

	- 8.4.1 归约和搜索
	- 8.4.2 计数
	- 8.4.3 Set视图

- 8.5 小结

  ❏ Java 9支持集合工厂，使用List.of、Set.of、Map.of以及Map.ofEntries可以创建小型不可变的List、Set和Map。
  ❏ 集合工厂返回的对象都是不可变的，这意味着创建之后你不能修改它们的状态。
  ❏ List接口支持默认方法removeIf、replaceAll和sort。
  ❏ Set接口支持默认方法removeIf。
  ❏ Map接口为常见模式提供了几种新的默认方法，并降低了出现缺陷的概率。
  ❏ ConcurrentHashMap支持从Map中继承的新默认方法，并提供了线程安全的实现。
  

### 第9章 重构、测试和调试

- 9.1 为改善可读性和灵活性重构代码

	- 9.1.1 改善代码的可读性
	- 9.1.2 从匿名类到Lambda表达式的转换
	- 9.1.3 从Lambda表达式到方法引用的转换
	- 9.1.4 从命令式的数据处理切换到Stream
	- 9.1.5 增加代码的灵活性

- 9.2 使用Lambda重构面向对象的设计模式

	- 9.2.1 策略模式
	- 9.2.2 模板方法
	- 9.2.3 观察者模式
	- 9.2.4 责任链模式
	- 9.2.5 工厂模式

- 9.3 测试Lambda表达式

	- 9.3.1 测试可见Lambda函数的行为
	- 9.3.2 测试使用Lambda的方法的行为
	- 9.3.3 将复杂的Lambda表达式分为不同的方法
	- 9.3.4 高阶函数的测试

- 9.4 调试

	- 9.4.1 查看栈跟踪
	- 9.4.2 使用日志调试

- 9.5 小结

  ❏ Lambda表达式能提升代码的可读性和灵活性。
  ❏ 如果你的代码中使用了匿名类，那么尽量用Lambda表达式替换它们，但是要注意二者间语义的微妙差别，比如关键字this，以及变量隐藏。
  ❏ 跟Lambda表达式比起来，方法引用的可读性更好。
  ❏ 尽量使用Stream API替换迭代式的集合处理。
  ❏ Lambda表达式有助于避免使用面向对象设计模式时容易出现的僵化的模板代码，典型的比如策略模式、模板方法、观察者模式、责任链模式，以及工厂模式。
  ❏ 即使采用了Lambda表达式，也同样可以进行单元测试，但是通常你应该关注使用了Lambda表达式的方法的行为。
  ❏ 尽量将复杂的Lambda表达式抽象到普通方法中。
  ❏ Lambda表达式会让栈跟踪的分析变得更为复杂。
  ❏ 流提供的peek方法在分析Stream流水线时，能将中间变量的值输出到日志中，是非常有用的工具。
  

### 第10章 基于Lambda的领域特定语言

- 10.1 领域特定语言

	- 10.1.1 DSL的优点和弊端
	- 10.1.2 JVM中已提供的DSL解决方案

- 10.2 现代Java API中的小型DSL

	- 10.2.1 把Stream API当成DSL去操作集合
	- 10.2.2 将Collectors作为DSL汇总数据

- 10.3 使用Java创建DSL的模式与技巧

	- 10.3.1 方法链接
	- 10.3.2 使用嵌套函数
	- 10.3.3 使用Lambda表达式的函数序列
	- 10.3.4 把它们都放到一起
	- 10.3.5 在DSL中使用方法引用

- 10.4 Java 8 DSL的实际应用

	- 10.4.1 jOOQ
	- 10.4.2 Cucumber
	- 10.4.3 Spring Integration

- 10.5 小结

	- ❏ 引入DSL的主要目的是为了弥补程序员与领域专家之间对程序认知理解上的差异。对于编写实现应用程序业务逻辑的代码的程序员来说，很可能对程序应用领域的业务逻辑理解不深，甚至完全不了解。以一种“非程序员”也能理解的方式书写业务逻辑并不能把领域专家们变成专业的程序员，却使得他们在项目早期就能阅读程序的逻辑并对其进行验证。
	- ❏ DSL的两大主要分类分别是内部DSL（采用与开发应用相同的语言开发的DSL）和外部DSL（采用与开发应用不同的语言开发的DSL）。内部DSL所需的开发代价比较小，不过它的语法会受宿主语言限制。外部DSL提供了更高的灵活性，但是实现难度比较大。
	- ❏ 可以利用JVM上已经存在的另一种语言开发多语言DSL，譬如Scala或者Groovy。这些新型语言通常都比Java更加简洁，也更灵活。然而，要将Java与它们整合在一起使用需要修改构建流程，而这并不是一项小工程，并且Java与这些语言的互操作也远没达到完全无缝的程度。
	- ❏ 由于自身冗长、烦琐以及僵硬的语法，Java并非创建内部DSL的理想语言，然而随着Lambda表达式及方法引用在Java 8中的引入，这种情况有所好转。
	- ❏ 现代Java语言已经以原生API的方式提供了很多小型DSL。这些DSL，譬如Stream和Collectors类中的那些方法，都非常有用，使用起来也极其方便，特别是你需要对集合中的数据进行排序、过滤、转换或者分组的时候，非常值得一试。
	- ❏ 在Java中实现DSL有三种主要模式，分别是方法链接、嵌套函数以及函数序列。每种模式都有其优点和弊端。不过，你可以在一个DSL中整合这三种DSL，尽量地扬长避短，充分发挥各种模式的长处。
	- ❏ 很多Java框架和库都可以通过DSL使用其特性。本章介绍了其中的三种，分别是：jOOQ，一种SQL映射工具；Cucumber，一种基于行为驱动的开发框架；Spring Integration，一种实现企业集成模式的Spring扩展库。

## 第四部分 无所不在的Java

### 第11章 用Optional取代null

- 11.1 如何为缺失的值建模

	- 11.1.1 采用防御式检查减少NullPointerException
	- 11.1.2 null带来的种种问题
	- 11.1.3 其他语言中null的替代品

- 11.2 Optional类入门
- 11.3 应用Optional的几种模式

	- 11.3.1 创建Optional对象
	- 11.3.2 使用map从Optional对象中提取和转换值
	- 11.3.3 使用flatMap链接Optional对象
	- 11.3.4 操纵由Optional对象构成的Stream
	- 11.3.5 默认行为及解引用Optional对象
	- 11.3.6 两个Optional对象的组合
	- 11.3.7 使用filter剔除特定的值

- 11.4 使用Optional的实战示例

	- 11.4.1 用Optional封装可能为null的值
	- 11.4.2 异常与Optional的对比
	- 11.4.3 基础类型的Optional对象，以及为什么应该避免使用它们
	- 11.4.4 把所有内容整合起来

- 11.5 小结

  ❏ null引用在历史上被引入到程序设计语言中，目的是为了表示变量值的缺失。
  ❏ Java 8中引入了一个新的类java.util.Optional，对存在或缺失的变量值进行建模。
  ❏ 你可以使用静态工厂方法Optional.empty、Optional.of以及Optional.ofNullable创建Optional对象。
  ❏ Optional类支持多种方法，比如map、flatMap、filter，它们在概念上与Stream类中对应的方法十分相似。
  ❏ 使用Optional会迫使你更积极地解引用Optional对象，以应对变量值缺失的问题，最终，你能更有效地防止代码中出现不期而至的空指针异常。
  ❏ 使用Optional能帮助你设计更好的API，用户只需要阅读方法签名，就能了解该方法是否接受一个Optional类型的值。
  

### 第12章 新的日期和时间API

- 12.1 LocalDate、LocalTime、LocalDateTime、Instant、Duration以及Period

	- 12.1.1 使用LocalDate和LocalTime
	- 12.1.2 合并日期和时间
	- 12.1.3 机器的日期和时间格式
	- 12.1.4 定义Duration或Period

- 12.2 操纵、解析和格式化日期

	- 12.2.1 使用TemporalAdjuster
	- 12.2.2 打印输出及解析日期-时间对象

- 12.3 处理不同的时区和历法

	- 12.3.1 使用时区
	- 12.3.2 利用和UTC/格林尼治时间的固定偏差计算时区
	- 12.3.3 使用别的日历系统

- 12.4 小结

  ❏ Java 8之前老版的java.util.Date类以及其他用于建模日期和时间的类有很多不一致及设计上的缺陷，包括易变性以及糟糕的偏移值、默认值和命名。
  ❏ 新版的日期和时间API中，日期-时间对象是不可变的。
  ❏ 新的API提供了两种不同的时间表示方式，有效地区分了运行时人和机器的不同需求。
  ❏ 你可以用绝对或者相对的方式操纵日期和时间，操作的结果总是返回一个新的实例，老的日期-时间对象不会发生变化。❏ TemporalAdjuster让你能够用更精细的方式操纵日期，不再局限于一次只能改变它的一个值，并且你还可按照需求定义自己的日期转换器。
  ❏ 你现在可以按照特定的格式需求，定义自己的格式器，打印输出或者解析日期-时间对象。这些格式器可以通过模板创建，也可以自己编程创建，并且它们都是线程安全的。
  ❏ 你可以用相对于某个地区/位置的方式，或者以与UTC/格林尼治时间的绝对偏差的方式表示时区，并将其应用到日期-时间对象上，对其进行本地化。
  ❏ 你现在可以使用不同于ISO-8601标准系统的其他日历系统了。
  

### 第13章 默认方法

- 13.1 不断演进的API

	- 13.1.1 初始版本的API
	- 13.1.2 第二版API

- 13.2 概述默认方法
- 13.3 默认方法的使用模式

	- 13.3.1 可选方法
	- 13.3.2 行为的多继承

- 13.4 解决冲突的规则

	- 13.4.1 解决问题的三条规则
	- 13.4.2 选择提供了最具体实现的默认方法的接口
	- 13.4.3 冲突及如何显式地消除歧义
	- 13.4.4 菱形继承问题

- 13.5 小结

  ❏ Java 8中的接口可以通过默认方法和静态方法提供方法的代码实现。
  ❏ 默认方法的开头以关键字default修饰，方法体与常规的类方法相同。
  ❏ 向发布的接口添加抽象方法不是源码兼容的。
  ❏ 默认方法的出现能帮助库的设计者以后向兼容的方式演进API。
  ❏ 默认方法可以用于创建可选方法和行为的多继承。
  ❏ 我们有办法解决由于一个类从多个接口中继承了拥有相同函数签名的方法而导致的冲突。
  ❏ 类或者父类中声明的方法的优先级高于任何默认方法。如果前一条无法解决冲突，那就选择同函数签名的方法中实现得最具体的那个接口的方法。
  ❏ 两个默认方法都同样具体时，你需要在类中覆盖该方法，显式地选择使用哪个接口中提供的默认方法。
  

### 第14章 Java模块系统

- 14.1 模块化的驱动力：软件的推理

	- 14.1.1 关注点分离
	- 14.1.2 信息隐藏
	- 14.1.3 Java软件

- 14.2 为什么要设计Java模块系统

	- 14.2.1 模块化的局限性
	- 14.2.2 单体型的JDK
	- 14.2.3 与OSGi的比较

- 14.3 Java模块：全局视图
- 14.4 使用Java模块系统开发应用

	- 14.4.1 从头开始搭建一个应用
	- 14.4.2 细粒度和粗粒度的模块化
	- 14.4.3 Java模块系统基础

- 14.5 使用多个模块

	- 14.5.1 exports子句
	- 14.5.2 requires子句
	- 14.5.3 命名

- 14.6 编译及打包
- 14.7 自动模块
- 14.8 模块声明及子句

	- 14.8.1 requires
	- 14.8.2 exports
	- 14.8.3 requires的传递
	- 14.8.4 exports to
	- 14.8.5 open和opens
	- 14.8.6 uses和provides

- 14.9 通过一个更复杂的例子了解更多
- 14.10 小结

  ❏ 关注点隔离和信息隐藏是构造结构良好、易于维护与理解的软件的重要原则。
  ❏ Java 9之前，你可以根据特定的需求，利用包、类以及接口对代码进行模块化，不过以上这些方式都缺乏足够的特性，无法进行有效的封装。
  ❏ “类路径地狱”问题导致我们很难对应用的依赖性进行分析。
  ❏ Java 9之前，JDK还是单体型的结构，导致很高的维护成本并限制了Java的演进。
  ❏ Java 9引入了新的模块系统，它通过module-info.java文件命名模块，指定其依赖性（通过requires）以及导出的公共API（通过exports）。
  ❏ 使用requires子句，你可以指定一个模块对其他模块的依赖。
  ❏ 使用exports子句可以导出模块中的某些包，将其声明为公有类型，提供给其他模块使用。
  ❏ 推荐使用互联网域名的逆序作为模块的命名方式。
  ❏ 位于模块路径上且没有提供module-info文件的JAR文件会被Java 9作为自动模块处理。
  ❏ 自动模块隐式地导出其全部包给其他模块使用。
  ❏ Maven支持按照Java 9模块系统构建的应用。
  

## 第五部分 提升Java的并发性

### 第15章 CompletableFuture及反应式编程背后的概念

- 15.1 为支持并发而不断演进的Java

	- 15.1.1 线程以及更高层的抽象
	- 15.1.2 执行器和线程池
	- 15.1.3 其他的线程抽象：非嵌套方法调用
	- 15.1.4 你希望线程为你带来什么

- 15.2 同步及异步API

	- 15.2.1 Future风格的API
	- 15.2.2 反应式风格的API
	- 15.2.3 有害的睡眠及其他阻塞式操作
	- 15.2.4 实战验证
	- 15.2.5 如何使用异步API进行异常处理

- 15.3 “线框-管道”模型
- 15.4 为并发而生的CompletableFuture和结合器
- 15.5 “发布-订阅”以及反应式编程

	- 15.5.1 示例：对两个流求和
	- 15.5.2 背压
	- 15.5.3 一种简单的真实背压

- 15.6 反应式系统和反应式编程
- 15.7 路线图
- 15.8 小结

  ❏ Java对并发的支持由来已久，并且还在持续演进。通常而言，线程池技术很有帮助，然而如果你有大量可能阻塞的任务，使用它反而会带来麻烦。
  ❏ 方法异步化（在完成它们的工作之前返回）能提升程序的并发度，其可以与用于循环结构的优化进行互补。
  ❏ 使用线框-管道模型可以对异步系统进行可视化。
  ❏ Java 8的CompletableFuture类和Java 9的Flow API都可以通过线框-管道图表示。
  ❏ CompletableFuture类常用于一次性的异步计算。使用结合器可以组合多个异步计算，并且无须担心使用Future时的阻塞风险。
  ❏ Flow API基于“发布-订阅”协议，它与背压一起构成了Java反应式编程的基础。
  ❏ 反应式编程可以帮助实现反应式系统。
  

### 第16章 CompletableFuture：组合式异步编程

- 16.1 Future接口

	- 16.1.1 Future接口的局限性
	- 16.1.2 使用CompletableFuture构建异步应用

- 16.2 实现异步API

	- 16.2.1 将同步方法转换为异步方法
	- 16.2.2 错误处理

- 16.3 让你的代码免受阻塞之苦

	- 16.3.1 使用并行流对请求进行并行操作
	- 16.3.2 使用CompletableFuture发起异步请求
	- 16.3.3 寻找更好的方案
	- 16.3.4 使用定制的执行器

- 16.4 对多个异步任务进行流水线操作

	- 16.4.1 实现折扣服务
	- 16.4.2 使用Discount服务
	- 16.4.3 构造同步和异步操作
	- 16.4.4 将两个CompletableFuture对象整合起来，无论它们是否存在依赖
	- 16.4.5 对Future和CompletableFuture的回顾
	- 16.4.6 高效地使用超时机制

- 16.5 响应CompletableFuture的completion事件

	- 16.5.1 对最佳价格查询器应用的优化
	- 16.5.2 付诸实践
	- 16.6 路线图

- 16.7 小结

  ❏ 执行比较耗时的操作时，尤其是那些依赖一个或多个远程服务的操作，使用异步任务可以改善程序的性能，加快程序的响应速度。
  ❏ 你应该尽可能地为客户提供异步API。使用CompletableFuture类提供的特性，你能够轻松地实现这一目标。
  ❏ CompletableFuture类还提供了异常管理的机制，让你有机会抛出/管理异步任务执行中发生的异常。
  ❏ 将同步API的调用封装到一个CompletableFuture中，你能够以异步的方式使用其结果。
  ❏ 如果异步任务之间相互独立，或者它们之间某一些的结果是另一些的输入，那么你可以将这些异步任务构造或者合并成一个。
  ❏ 你可以为CompletableFuture注册一个回调函数，在Future执行完毕或者它们计算的结果可用时，针对性地执行一些程序。
  

### 第17章 反应式编程

- 17.1 反应式宣言

	- 17.1.1 应用层的反应式编程
	- 17.1.2 反应式系统

- 17.2 反应式流以及Flow API

	- 17.2.1 Flow类
	- 17.2.2 创建你的第一个反应式应用
	- 17.2.3 使用Processor转换数据
	- 17.2.4 为什么Java并未提供Flow API的实现

- 17.3 使用反应式库RxJava

	- 17.3.1 创建和使用Observable
	- 17.3.2 转换及整合多个Observable

- 17.4 小结

  ❏ 反应式编程背后的基本思想已经有二三十年的历史了，不过由于现代应用处理大量数据的需求以及用户预期的改变，它又再次出现在聚光灯下，变得炙手可热。
  ❏ 反应式编程思想的正式提出是在反应式宣言中，它指出反应式软件必须具备四个相互关联的特性：响应性、韧性、弹性以及消息驱动。
  ❏ 反应式编程原则通过微调，既可以用于构建单一应用，也可以用于设计反应式系统，整合多个应用。
  ❏ 反应式应用基于反应式流承载的一个或多个事件流的异步处理。由于反应式流在开发反应式应用中的角色如此重要，Netflix、Pivotal、Lightbend以及Red Hat等多家公司成立了联盟，致力于推动反应式概念的标准化，试图打破不同反应式库之间的互操作性障碍。
  ❏ 由于反应式流异步处理的天然特征，它们往往都自带背压机制。背压可以避免处理速度慢的消费方被高速的消息生产方压垮。
  ❏ 反应式设计及其标准流程已经正式引入了Java。Java 9的Flow API定义了四个核心接口：Publisher、Subscriber、Subscription以及Processor。
  ❏ 大多数情况下，这些接口不需要开发者直接去实现，它们主要作为实现反应式语义的第三方库的通用接口。
  ❏ 应用最广泛的反应式库是RxJava，它（除了Java 9 Flow API中定义的那些基本特性之外）额外提供了很多便利而强大的操作。譬如，使用它提供的操作，你可以很便利地对单一反应式流中的元素进行转换和过滤，还可以整合和聚集多个流。
  

## 第六部分 函数式编程以及Java未来的演进

### 第18章 函数式的思考

- 18.1 实现和维护系统

	- 18.1.1 共享的可变数据
	- 18.1.2 声明式编程
	- 18.1.3 为什么要采用函数式编程

- 18.2 什么是函数式编程

	- 18.2.1 函数式Java编程
	- 18.2.2 引用透明性
	- 18.2.3 面向对象的编程和函数式编程的对比
	- 18.2.4 函数式编程实战

- 18.3 递归和迭代
- 18.4 小结

  ❏ 从长远看，减少共享的可变数据结构能帮助你降低维护和调试程序的代价。
  ❏ 函数式编程支持无副作用的方法和声明式编程。
  ❏ 函数式方法可以由它的输入参数及输出结果进行判断。
  ❏ 如果一个函数使用相同的参数值调用，总是返回相同的结果，那么它是引用透明的。采用递归可以取代迭代式的结构，比如while循环。
  ❏ 相对于Java语言中传统的递归，“尾-递”可能是一种更好的方式，它开启了一扇门，让我们有机会最终使用编译器进行优化。
  

### 第19章 函数式编程的技巧

- 19.1 无处不在的函数

	- 19.1.1 高阶函数
	- 19.1.2 柯里化

- 19.2 持久化数据结构

	- 19.2.1 破坏式更新和函数式更新的比较
	- 19.2.2 另一个使用Tree的例子
	- 19.2.3 采用函数式的方法

- 19.3 Stream的延迟计算

	- 19.3.1 自定义的Stream
	- 19.3.2 创建你自己的延迟列表

- 19.4 模式匹配

	- 19.4.1 访问者模式
	- 19.4.2 用模式匹配力挽狂澜

- 19.5 杂项

	- 19.5.1 缓存或记忆表
	- 19.5.2 “返回同样的对象”意味着什么
	- 19.5.3 结合器

- 19.6 小结

  ❏ 一等函数是可以作为参数传递，可以作为结果返回，同时还能存储在数据结构中的函数。
  ❏ 高阶函数接受至少一个或者多个函数作为输入参数，或者返回另一个函数的函数。Java中典型的高阶函数包括comparing、andThen和compose。
  ❏ 柯里化是一种帮助你模块化函数和重用代码的技术。
  ❏ 持久化数据结构在其被修改之前会对自身前一个版本的内容进行备份。因此，使用该技术能避免不必要的防御式复制。
  ❏ Java语言中的Stream不是自定义的。
  ❏ 延迟列表是Java语言中让Stream更具表现力的一个特性。延迟列表让你可以通过辅助方法（supplier）即时地创建列表中的元素，辅助方法能帮忙创建更多的数据结构。
  ❏ 模式匹配是一种函数式的特性，它能帮助你解包数据类型。它可以被看成是Java语言中switch语句的一种泛化。
  ❏ 遵守“引用透明性”原则的函数，其计算结构可以进行缓存。
  ❏ 结合器是一种函数式的思想，它指的是将两个或多个函数或者数据结构进行合并。
  

### 第20章 面向对象和函数式编程的混合：Java和Scala的比较

- 20.1 Scala简介

	- 20.1.1 你好，啤酒
	- 20.1.2 基础数据结构：List、Set、Map、Tuple、Stream以及Option

- 20.2 函数

	- 20.2.1 Scala中的一等函数
	- 20.2.2 匿名函数和闭包
	- 20.2.3 柯里化

- 20.3 类和trait

	- 20.3.1 更加简洁的Scala类
	- 20.3.2 Scala的trait与Java 8的接口对比

- 20.4 小结

  ❏ Java和Scala都是整合了面向对象编程和函数式编程特性的编程语言，它们都运行于JVM之上，在很多时候可以相互操作。
  ❏ Scala支持对集合的抽象，支持处理的对象包括List、Set、Map、Stream和Option，这些和Java非常类似。不过，除此之外Scala还支持元组。
  ❏ Scala为函数提供了更加丰富的特性，这方面比Java做得好。Scala支持：函数类型、可以不受限制地访问本地变量的闭包，以及内置的柯里化表单。
  ❏ Scala中的类可以提供隐式的构造器、getter方法以及setter方法。
  ❏ Scala还支持trait，即一种同时包含了字段和默认方法的接口。
  

### 第21章 结论以及Java的未来

- 21.1 回顾Java 8的语言特性

	- 21.1.1 行为参数化（Lambda以及方法引用）
	- 21.1.2 流
	- 21.1.3 CompletableFuture
	- 21.1.4 Optional
	- 21.1.5 Flow API
	- 21.1.6 默认方法

- 21.2 Java 9的模块系统
- 21.3 Java 10的局部变量类型推断
- 21.4 Java的未来

	- 21.4.1 声明处型变
	- 21.4.2 模式匹配
	- 21.4.3 更加丰富的泛型形式
	- 21.4.4 对不变性的更深层支持
	- 21.4.5 值类型

- 21.4.5 值类型
- 21.6 写在最后的话

*XMind - Trial Version*