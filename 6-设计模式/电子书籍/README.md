# 《秒懂设计模式》

## 第1章 初探

### 1.1封装

### 1.2继承

### 1.3多态

### 1.4计算机与外设

## 创建型

### 第2章 单例

- 2.1孤独的太阳
- 2.2饿汉造日
- 2.3懒汉的队伍
- 2.4大道至简

### 第3章原型

- 3.1原件与副本
- 3.2卡顿的游戏
- 3.3细胞分裂.
- 3.4克隆工厂
- 3.5深拷贝与浅拷贝
- 3.6克隆的本质

### 第4章工厂方法

- 4.1工厂的多元化与专业化

	- 1. new对象的缺点

		- 客户端与实例化过程强耦合

	- 2. 什么是工厂方法模式

		- 工厂方法模式是基于多元化产品的构造方法发展而来的，它开辟了产品多元化的生产模式，不同的产品可以交由不同的专业工厂来生产

- 4.2游戏角色建模

	- 1. 不同的

		- 1. 外形
		- 2. 轨迹

	- 2. 相同的

		- 例如一对用来描述位置状态的坐标，以及一个展示（绘制）方法，以便将自己绘制到相应的地图位置上

	- 3. 抽象定义

		- 飞机类Airplane和坦克类Tank都继承了敌人抽象类Enemy

- 4.3简单工厂不简单

	- 1. 敌人随机坐标
	- 2. 简单工厂复用公用逻辑
	- 3. 缺点

		- 违反开闭原则
		- 例如对于那段对产品种类的判断逻辑，如果有新的敌人类加入，我们就需要再修改简单工厂。随着生产方式不断多元化，工厂类就得被不断地反复修改，严重缺乏灵活性与可扩展性

- 4.4制定工业制造标准

	- 1. 针对复杂多变的生产需求，我们需要对产品制造的相关代码进行合理规划与分类，将简单工厂的制造方法进行拆分，构建起抽象化、多态化的生产模式。
	- 2. 显而易见，多态化后的工厂多样性不言而喻，每个工厂的生产策略或方式都具备自己的产品特色，不同的产品需求都能找到相应的工厂来满足，即便没有，我们也可以添加新工厂来解决，以确保游戏系统具有良好的兼容性和可扩展性。

- 4.5劳动分工

	- 工厂方法模式的各角色定义如下

		- ● Product（产品）：所有产品的顶级父类，可以是抽象类或者接口。对应本章例程中的敌人抽象类。
		- ● ConcreteProduct（子产品）：由产品类Product派生出的产品子类，可以有多个产品子类。对应本章例程中的飞机类、坦克类以及关底Boss类。
		- ● Factory（工厂接口）：定义工厂方法的工厂接口，当然也可以是抽象类，它使顶级工厂制造方法抽象化、标准统一化。
		- ● ConcreteFactory（工厂实现）：实现了工厂接口的工厂实现类，并决定工厂方法中具体返回哪种产品子类的实例。

- 博客文章

	- 浅谈简单工厂，工厂方法，抽象工厂的区别和使用

		- 1. 简单工厂

			- 1. 角色

				- 1.工厂：简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。  
				- 2.抽象产品 ：简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。
				- 3.具体产品：是简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。

			- 2. 代码设计

				- 1. 喝饮料
				- 2. 饮料（抽象产品）

					- 可乐（具体产品）
					- 雪碧（具体产品）

				- 3. 饮料工厂（工厂）

			- 3. 代码实现
			- 4. 优缺点

				- 简单工厂的优点：

					-  1. 一个调用者想创建一个对象，只要知道其名称就可以了。 
					- 2. 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
					-  3. 屏蔽产品的具体实现，调用者只关心产品的接口。

				- 简单工厂的缺点：

					- 1. 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

		- 2. 工厂方法

			- 1. 定义

				- 定义一个创建对象的接口，让实现这个接口的的类去决定实例化具体的类。工厂方法让类的实例化推迟到实现接口的子类中进行。

			- 2. 角色

				- 1. 抽象产品
				- 2. 具体产品
				- 3. 抽象工厂
				- 4. 具体工厂

			- 3. 设计思路

				- 1. 喝不同厂商的饮料
				- 2. 可乐（抽象产品）

					- 百事可乐（具体产品）
					- 可口可乐（具体产品）

				- 3. 可乐公司（抽象工厂）

					- 百事可乐（具体工厂）
					- 可口可乐（具体工厂）

		- 3. 抽象工厂

			- 1. 产品等级和产品族
			- 2. 抽象工厂解决的是横向的产品族，工厂方法解决的是向的产品等级
			- 3. 角色

				- 1. 抽象工厂（多个）
				- 2. 具体工厂
				- 3. 抽象产品（多个）
				- 4. 具体产品 

			- 4. 代码设计

				- 1. 品牌（抽象工厂）

					- 1. 苹果（具体工厂）
					- 2. 小米（具体工厂）
					- ...

				- 2. 手机（抽象产品1）

					- 1. 苹果手机（具体产品1）
					- 2. 小米手机（具体产品1）
					- ....

				- 3. 电脑（抽象产品2）

					- 1. 苹果电脑（具体产品2）
					- 2. 小米电脑（具体产品2）
					- ...

				- 4. 使用者

	- 使用IDEA绘制UML类图

### 第5章抽象工厂

抽象工厂模式提供了另一种思路，将各种产品分门别类，基于此来规划各种工厂的制造接口，最终确立产品制造的顶级规范，使其与具体产品彻底脱钩。


- 5.1品牌与系列

	- 我们可以基于产品品牌与系列进行生产线规划，按品牌划分A工厂与B工厂。具体以汽车工厂举例，A品牌汽车有轿车、越野车、跑车3个系列的产品，同样地，B品牌汽车也包括以上3个系列的产品，如此便形成了两个产品族，分别由A工厂和B工厂负责生产，每个工厂都有3条生产线，分别生产这3个系列的汽车

- 5.2产品规划

	- 1. 星际争霸游戏
	- 2. 兵种

		- 兽族
		- 人族

- 5.3生产线规划

	- 1. 抽象兵工厂接口定义了3个等级兵种的制造标准

- 5.4分而治之

	- 抽象工厂模式的各角色定义如下

		- ● AbstractProduct1、AbstractProduct2（抽象产品1、抽象产品2）：产品系列的抽象类，图中一系产品与二系产品分别代表同一产品族的多个产品系列，对应本章例程中的初级、中级、高级兵种抽象类。
		- ● ProductA1、ProductB1、ProductA2、ProductB2（产品A1、产品B1、产品A2、产品B2）：继承自抽象产品的产品实体类，其中ProductA1与ProductB1代表A族产品与B族产品的同一产品系列，类似于本章例程中人类族与外星怪兽族的初级兵种，之后的产品实体类以此类推。
		- ● AbstractFactory（抽象工厂接口）：各族工厂的高层抽象，可以是接口或者抽象类。抽象工厂对各产品系列的制造标准进行规范化定义，但具体返回哪个族的产品由具体族工厂决定，它并不关心。
		- ● ConcreteFactoryA、ConcreteFactoryB（工厂A实现、工厂B实现）：继承自抽象工厂的各族工厂，需实现抽象工厂所定义的产品系列制造方法，可以扩展多个工厂实现。对应本章例程中的人类兵工厂与外星母巢。
		- ● Client（客户端）：产品的使用者，只关心制造出的产品系列，具体是哪个产品族由工厂决定。

### 第6章建造者

- 6.1建造步骤的重要性
- 6.2地产开发商的困惑
- 6.3建筑施工方
- 6.4工程总监
- 6.5项目实施
- 6.6工艺与工序

## 结构篇

### 第7章门面

- 7.1一键操作
- 7.2亲自下厨的烦扰
- 7.3化繁为简
- 7.4整合共享

### 第8章组合

- 8.1叉树结构
- 8.2文件系统
- 8.3目录树展示
- 8.4自相似性的涌现

### 第9章装饰器

- 9.1室内装潢
- 9.2从素面朝天到花容月貌
- 9.3化妆品的多样化
- 9.4无处不在的装饰器
- 9.5自由嵌套

### 第10章适配器

- 10.1跨越鸿沟靠适配
- 10.2插头与插孔的冲突
- 10.3通用适配
- 10.4专属适配
- 10.5化解难以调和的矛盾

### 第11章享元

- 11.1 马赛克
- 11.2游戏地图
- 11.3卡顿的加载过程
- 11.4图件共享
- 11.5万变不离其宗

### 第12章代理.

- 12.1 4S店
- 12.2访问互联网
- 12.3互联网代理
- 12.4万能的动态代理
- 12.5业务增强与管控

### 第13章桥接

- 13.1基础建设
- 13.2形与色的纠葛
- 13.3架构产业链
- 13.4笛卡儿积
- 13.5多姿多彩的世界

## 行为篇

### 第14章模板方法

- 14.1生存技能
- 14.2生存法则
- 14.3项目管理模板
- 14.4虚实结合

### 第15章迭代器

- 15.1物以类聚，
- 15.2循环往复
- 15.3遍历标准化
- 15.4分离迭代器
- 15.5鱼与熊掌兼得

### 第16章责任链

- 16.1简单的生产线
- 16.2工作流程拆分
- 16.3踢皮球
- 16.4架构工作流
- 16.5让业务飞一会儿

### 第17章策略

- 菜鸟教程

  在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。
  在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。
  

	- 意图

		- 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
		- 那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为

	- 主要解决

		- 在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

	- 何时使用

		- 一个系统有许多许多类，而区分它们的只是他们直接的行为。

	- 如何解决

		- 将这些算法封装成一个一个的类，任意地替换。

	- 关键代码

		- 实现同一个接口。

	- 应用实例

		-  1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。
		-  2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。
		-  3、JAVA AWT 中的 LayoutManager。

	- 优点

		- 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。

	- 缺点

		-  1、策略类会增多。 2、所有策略类都需要对外暴露。

	- 使用场景

		-  1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 
		- 2、一个系统需要动态地在几种算法中选择一种。
		-  3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。

	- 注意事项

	  ：
	  

		- 如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。

	- 角色说明

		- ● Strategy（策略接口）
		- ● ConcreteStrategyA、ConcreteStrategyB、ConcreteStrategyC……（策略实现）
		- ● Context（系统环境）

	- 代码设计

		- 使用计算器
		- 1. 定义两数计算（策略接口）

			- 1. 加法策略（策略实现）
			- 2. 减法策略（策略实现）
			- 3. 乘法策略（策略实现）

		- 2. 根据不同算法获得具体策略（系统环境）

- 17.1“ 顽固不化”的系统
- 17.2游戏卡带
- 17.3万能的USB接口
- 17.4即插即用

	- ● Strategy（策略接口）：定义通用的策略规范标准，包含在系统环境中并声明策略接口标准。对应本章例程中的USB接口USB
	- ● ConcreteStrategyA、ConcreteStrategyB、ConcreteStrategyC……（策略实现）：实现了策略接口的策略实现类，可以有多种不同的策略实现，但都得符合策略接口定义的规范。对应本章例程中的USB键盘类Keyboard、USB鼠标类Mouse、USB摄像头类Camera。
	- ● Context（系统环境）：包含策略接口的系统环境，对外提供更换策略实现的方法setStrategy()以及执行策略的方法executeStrategy()，其本身并不关心执行的是哪种策略实现。对应本章例程中的计算机主机类Computer。

### 第18章状态

- 18.1事物的状态
- 18.2简单的二元态
- 18.3交通灯的状态
- 18.4状态响应机制

### 第19章备忘录

- 19.1时光流逝
- 19.2覆水难收
- 19.3破镜重圆
- 19.4历史回溯.

### 第20章中介

- 20.1简单直接交互
- 20.2构建交互平台
- 20.3多态化沟通，
- 20.4星形拓扑

### 第21章命令

- 21.1对电灯的控制
- 21.2开关命令
- 21.3霓虹灯闪烁
- 21.4物联网
- 21.5万物兼容

### 第22章访问者

- 22.1多样化的商品
- 22.2多变的计价方法
- 22.3泛型购物车
- 22.4访问与接待
- 22.5数据与算法

### 第23章观察者

- 23.1观察者很忙
- 23.2反客为主
- 23.3订阅与发布.

### 第24章解释器

- 24.1语言与表达式
- 24.2语义树
- 24.3接口与终极表达式
- 24.4非终极表达式
- 24.5语法规则

## 第25章终道

### 25.1单一职责

### 25.2开闭原则

### 25.3里氏替换

### 25.4接口隔离

### 25.5依赖倒置

### 25.6迪米特法则

### 25.7设计的最高境界

*XMind - Trial Version*