# 【Marion精选文章思维导图】

## 腾讯技术工程

### 1. 肝货！万字长文助你上手DDD
（阅读时间：2小时）

- 1.背景
- 2.DDD概要与实践感悟

	- 2.1 复杂性

		- 规模：指的是系统所支持的功能点，以及功能点与功能点之间的的关系。DDD通过子领域，限界上下文，聚合等模式对问题进行拆分和归类，不断收窄问题域，保证聚合边界内所解决的问题集合足够收敛和可控。
		- 结构：指的是系统架构。系统架构是否分层；若分层，每层划分的职责边界是否清晰；架构的基本管理单元是什么，它决定了架构演进时的复杂度。DDD通过分层架构，独立出领域层，且架构中的每层都有清晰的职责。整体架构的基本管理单元是聚合，它是一个完整的、自治的管理单元，当需要进行服务拆分时，可以直接以聚合作为基本单元进行拆分。
		- 变化：指的是系统响应需求变化的能力。快速响应变化的有效手段是分离不易变逻辑和易变逻辑，"以不变应万变"。而通过分层架构独立的领域层正是不易变的逻辑。领域层是对领域知识的封装，其提供的领域服务具有经验性和前瞻性，是对领域内稳定的领域规则的表达。而领域层以外的应用层和基础设施层则是易变逻辑的封装。保证核心的独立和稳定，通过在调整应用层和基础设施层来实现快速响应需求变化。

	- 2.2 领域驱动

		- 思维模式转变
		- 协同方式转变
		- 精炼循环

	- 2.3 怎么才算DDD？

		- 构建出产品、领域专家和研发同学认知一致且便于交流的模型，并且模型与实现紧密绑定；
		- 模型逐步演进，反复消化和精炼；
		- 模型蕴含领域知识，足够稳定。

- 3.问题空间&解空间

	- 3.1 问题空间&解空间
	- 3.2 示例-学生管理系统的问题空间

- 4.领域驱动设计统一过程（DDDRUP）
- 5.全局分析阶段

	- 5.1 形成统一语言
	- 5.2 价值需求分析
	- 5.3 业务需求分析

		- 5.3.1 业务流程、业务场景、业务服务和业务规则

			- 业务流程：表示的是一个完整的、端对端的服务过程。
			- 业务场景：按阶段性的业务目标划分业务流程，就可以获得业务场景。在示例-SMS中，老师修改成绩就分为了老师“提交申请单”，以及教务员“同意申请单”两个场景。
			- 业务服务：角色主动向目标系统发起服务请求完成一次完整的功能交互，以实现业务目标。角色可以用户、策略（定时任务）或者其他系统，完整则强调的是业务服务的执行序列的所有步骤都应该是连续且不可中断的。业务服务是业务需求分析最核心，也是最基础的单元，而业务流程和业务场景是为了更好地分析出业务服务。在示例-SMS中的“同意申请单”场景中包含了两个业务服务：教务员“同意申请单”和系统“邮件通知”教务员。
			- 业务规则：指对业务服务约束的描述，用于控制业务服务的对外行为。业务规则是业务服务正确性的基础。常见的业务规则有：a) 意如“若… , 就….” 的需求描述，比如示例-SMS中可提炼出“若成绩录入时间间隔超过一周，不予修改”；b) 具有事务性的操作。

		- 5.3.2 子领域

		  通过业务流程、业务场景和业务服务的梳理，基本可以分析出业务需求所需要的业务服务。然而，业务服务粒度太细，而问题空间又太大，我们需要找一个更粗粒度的业务单元，来帮助我们对业务服务进行聚类，一方面可以降低管理过多细粒度业务服务导致的额外复杂度，另一方面可以帮助领域专家和开发团队分析问题和设计方案时不至于陷入到业务细节中。而这个更粗粒度的业务单元就是子领域。
		  

			- 子领域的作用：

				- 划分问题空间，作为业务服务分类的边界；
				- 用于分辨问题空间的核心问题和次要问题。

			- 子领域的分类：

				- 核心子领域：能够体现系统愿景，具有产品差异化和核心竞争力的业务服务；
				- 通用子领域：包含的内容缺乏领域个性，具有较强的通用性，例如权限管理和邮件管理；
				- 支撑子领域：包含的内容多为“定制开发”，其为核心子领域的功能提供了支撑。

			- 子领域的功能分类策略：问题空间应该分为哪些子领域，需要团队对目标系统整体进行探索，并根据功能分类策略进行分解。

				- 业务职能：当目标系统运用于企业的生产和管理时，与目标系统业务有关的职能部门往往会影响目标系统的子领域划分，并形成一种简单的映射关系。这是康威定律的一种运用。
				- 业务产品：当目标系统为客户提供诸多具有业务价值的产品时，可以按照产品的内容与方向进行子领域划分。
				- 业务环节：对贯穿目标系统的核心业务流程进行阶段划分，然后按照划分出来的每个环节确定子领域。（这也是我们最常用的策略）
				- 业务概念：捕捉目标系统中一目了然的业务概念，将其作为子领域。

- 6.架构映射阶段

	- 6.1 限界上下文的定义和特征

		- 6.1.1 限界上下文的定义

		  
		  限界上下文是语义和语境的边界。在问题空间，统一语言形成了团队对领域概念的统一表达，子领域形成了领域概念之间的边界。而在解空间，限界上下文可以看做是统一语言+子领域的融合体，统一语言需要在限界上下文内才具有明确的业务含义。
		  
		  以电商购物场景为例。在进行商品下单后，系统会生成一个订单；在用户付款完成后，系统也会生成一个订单；到了物流派送流程，系统还会生成一个订单。虽然这三个步骤中的领域概念都叫订单，但是他们的关注点/职责却不同：商品订单关注的是商品详情，支付订单关注的是支付金额和分润情况，物流订单关注的是收货地址。也就是说，商品、支付和物流分别为三个限界上下文，而订单作为统一语言需要在特定的限界上下文内，我们才能够明确其关注点/负责的职责。
		  
		  

		- 6.1.2 限界上下文的特征

			- 最小完备：限界上下文在履行属于自己的业务能力时，拥有的领域知识是完整的，无须针对自己的信息去求助别的限界上下文。
			- 自我履行：限界上下文能够根据自己拥有的知识来完成业务能力。自我履行体现了限界上下文纵向切分业务能力的特征。
			- 稳定空间：限界上下文必须防止和减少外部变化带来的影响。
			- 独立进化：指减少限界上下文内部变化对外界产生的影响。

	- 6.2 限界上下文的识别

		- 6.2.1 按业务维度识别

			- 1. 归类

				- 语义相关性：存在相同或相似的领域概念，对应于业务服务描述的名词，如果不同的业务服务操作了相同或相似的对象，即可认为它们存在语义相关性。
				- 功能相关性：体现领域行为的相关性，业务服务是否服务于同一个业务目标。

			- 2. 归纳

			  归纳是对归类后的限界上下文进行命名。给限界上下文命名的过程，实际上也是对归类是否合理的再一次复查。限界上下文的命名同样需要遵循单一职责原则，它只能代表唯一的最能体现其特征的领域概念。倘若归类不合理，命名就会变得困难，这时候我们就需要反思（遵循知识消化循环）归类是否合理，并重新设计归类。
			  

			- 3. 边界梳理

			  归类和归纳之后，限界上下文的边界基本已经确定，边界梳理则是根据限界上下文特征（最小完备、自我履行、稳定空间和独立进化）以及子领域进行微调（当然也不排除大调）。
			  

				- 为什么需要根据子领域进行限界上下文边界的调整？限界上下文和子领域的关系是什么？
				- 理想的限界上下文与子领域的关系是一一对应的。上文提到，子领域是领域专家根据领域经验选择合适的功能分类策略进行划分，这个过程不会牵扯对业务服务的分析，体现的是领域专家对行业的洞见和深刻认识，可见获取子领域是一个自顶向下的过程。而限界上下文则是对业务服务进行归类、归纳、梳理和调整，最终形成一个个的边界，这是一个自下而上的过程。理想情况下，两者应该是双向奔赴的，自顶向下得到的子领域和自下而上得到的限界上下文能够完美契合！但是，现实哪有这么理想呢！所以一般情况下都需要我们进行调整，力求这两者能够一一对应。
				- 这里就再cue一下知识消化循环。优秀的领域专家划分出来的子领域，往往能够实现与限界上下文的一一对应。这就是经验的力量！那经验是怎么来的呢？我认为是领域专家经历了无数个知识消化循环之后沉淀下来的。领域专家一开始也是小白，划分出来的子领域在映射为限界上下文之后发现不同限界之间可能存在语义重叠，角色在不同限界上下文之中履行的职责可能很相似，于是他们通过知识消化循环，不断调整限界上下文的边界，然后又通过限界上下文调整子领域。慢慢地，稳定、可复用的子领域就被沉淀下来了。因此，识别限界上下文不是一个单向的过程，而是一个根据子领域调整限界上下文，然后又根据限界上下文调整子领域的循环的过程。

		- 6.2.2 验证

			- 正交原则

				- 正交性：如果两个或更多事物中的一个发生变化，不会影响其他事物，这些事物就是正交的。要破坏变化的传递性，就要保证每个限界上下文对外提供的业务服务不能出现雷同。

			- 奥卡姆剃刀原理

				- “如无必要，勿增实体”。这是避免过度设计的良方，同样也是我们识别限界上下文的原则。如果对识别出来的限界上下文的准确性依然心存疑虑，比较务实的做法是保证限界上下文具备一定的粗粒度。遵循该原则，意味着当我们没有寻找到必须切分限界上下文的必要证据时，就不要增加新的限界上下文。

	- 6.3 上下文映射

	  
	  限界上下文封装了分离的业务能力，上下文映射则建立了限界上下文之间的关系。上下文映射提供了各种模式（防腐层、开放主机服务、发布语言、共享内核、合作者、客户方/供应方、分离方式、遵奉者、大泥球），本质是在控制变化在限界上下文之间传递所产生的影响。
	  
	  下文将提供服务的限界上下文称为“上游”上下文（U表示），消费服务的限界上下文称为“下游”上下文（D表示）。
	  
	  

		- 6.3.1 防腐层

			- 引入防腐层的目的是为了隔离耦合。防腐层往往位于下游，通过它隔离上游上下文发生的变化。

		- 6.3.2 开放主机服务（OHS）
		- 6.3.3 发布语言（PL）

		  
		  发布语言是一种公共语言，用于两个限界上下文之间的模型转换。防腐层和开放主机服务都是访问领域模型时建立的一层包装，前者针对发起调用的下游（通过基础设施层体现），后者针对响应请求的上游（通过应用层+远程服务），以避免上下游之间的通信集成将各自的领域模型引入进来，造成彼此之间的强耦合。因此，防腐层和开放主机服务操作的对象都不应该是各自的领域模型，这正是引入发布语言的原因。（对于熟悉云API的小伙伴就会发现，其实云API根据我们定义的接口生成对应的Request对象和Response对象，并集成在云API的SDK中，这些对象就是发布语言）。
		  
		  
		  一般情况下，发布语言根据开放主机服务的服务契约进行定义。
		  
		  
		  说到这里，我们惊讶地发现防腐层，开放主机服务和发布语言可以完美联动！
		  
		  

		- 6.3.4 共享内核

		  
		  共享内核指将限界上下文中的领域模型直接暴露给其他限界上下文使用。注意，这会削弱了限界上下文边界的控制力。上面我们讲述的防腐层、开放主机服务以及发布语言无不传达一种思想，限界上下文不能直接暴露自己的领域模型或直接访问其他限界上下文的领域模型，一定要有隔离层！
		  
		  但是，在特定的场景下，共享内核不见得不是一种合理的方式。任何软件设计决策都要考量成本与收益，只有收益高于成本，决策才是合理的。一般对于一些领域通用的值对象是相对稳定的，这些类型通常属于通用子领域，会被系统中几乎所有的限界上下文复用，那么这些领域模型就适合使用共享内核的方式。共享内核的收益不言而喻，而面临的风险则是共享的领域模型可能产生的变化。
		  
		  

		- 6.3.5 合作者

		  合作关系指的是协作的限界上下文由不同的团队负责，且这些团队之间具有要么一起成功，要么一起失败的强耦合关系。合作者模式要求参与的团队一起做计划、一起提交代码、一起开发和部署，采用持续集成的方式保证两个限界上下文的集成度与一致性，避免因为其中一个团队的修改影响集成点的失败。
		  

		- 6.3.6 客户方/供应方

		  
		  当一个限界上下文单向地为另一个限界上下文提供服务时，它们对应的团队就形成了客户方/供应方模式。这是最为常见的团队协作模式，客户方作为下游团队，供应方作为上游团队，二者协作的主要内容包括：
		  下游团队对上游团队提出的服务
		  上游团队提供的服务采用什么样的协议与调用方式
		  下游团队针对上游服务的测试策略
		  上游团队给下游团队承诺的交付日期
		  当上游服务的协议或调用方式发生变更时，如何控制变更
		  

		- 6.3.7 分离方式

		  分离方式的团队协作模式是指两个限界上下文之间没有一丁点关系。如果此时双方使用到了相似/相同的领域模型，则可以通过拷贝的方式解决，保证限界上下文之间的物理隔离！
		  

		- 6.3.8 遵奉者

		  
		  当上游的限界上下文处于强势地位，且上游团队响应不积极时，我们可以采用遵奉者模式。即下游严格遵从上游团队的模型，以消除复杂的转换逻辑。
		  
		  当下游团队选择“遵奉”于上游团队设计的模型时，意味着：
		  可以直接复用上游上下文的模型（好的）；
		  减少了两个限界上下文之间模型的转换成本（好的）；
		  使得下游限界上下文对上游产生了模型上的强依赖（坏的）。
		  

		- 6.3.9 大泥球

		  
		  一定要避免制造大泥球！大泥球的特点：
		  越来越多的聚合因为不合理的关联和依赖导致交叉污染；
		  对大泥球的维护牵一发而动全身；
		  强调“个人英雄主义”，只有个别“超人”能够理清逻辑。
		  

	- 6.4 示例-SMS的限界上下文及其映射

		- 成绩上下文
		- 课程上下文
		- 审批上下文
		- 权限上下文
		- 邮件上下文

- 7.领域建模阶段

  领域建模阶段由领域分析建模，领域设计建模和领域实现建模组成。在正式讲解建模活动前，先了解一下什么是模型驱动设计。
  

	- 7.1 模型驱动设计

	  
	  模型是一种知识形式，它对知识进行了选择性的简化和有意的结构化，从而解决信息超载的问题。模型便于人们理解信息的意义，并专注核心问题。
	  
	  
	  建模过程一般由分析活动、设计活动和实现活动组成。每一次建模活动都是一次对知识的提炼和转换，并产生相应的模型，即分析模型、设计模型和实现模型。
	  
	  
	  建模过程并非是分析、设计和实现单向的前后串行过程，而是相互影响，不断切换和递进的关系。模型驱动设计的建模过程是：分析中蕴含了设计，设计中夹带了实现，甚至实现后还要回溯到设计和分析的一种迭代的、螺旋上升的演进过程。
	  
	  
	  根据分解问题的视角不同，我们日常建立的模型可以大致分为以下三类：
	  
	  数据模型：将问题空间抽取出来的概念视为数据信息，在求解过程中关注数据实体的样式和它们之间的关系，由此建立的模型就是数据模型。
	  服务模型：将每个问题视为目标系统为客户端提供的服务，在求解过程就会关注客户端发起的请求以及服务返回的响应，由此建立的模型就是服务模型。
	  领域模型：围绕问题空间的业务需求，在求解过程中力求提炼出表达领域知识的逻辑概念，由此建立的模型就是领域模型。
	  

		- 7.1.1 领域模型驱动设计

		  
		  一个优秀的领域模型应该具备以下的特征（我们也可以说具备这些特征的模型就是领域模型）：
		  
		  运用统一语言来表达领域中的概念；
		  蕴含业务活动和规则等领域知识；
		  对领域知识进行适度的提炼和抽象；
		  由一个迭代的演进过程建立；
		  有助于产品、领域专家和开发同学进行交流。
		  
		  领域建模阶段目的便是建立领域模型。领域模型由领域分析模型、领域设计模型以及领域实现模型共同组成，它们也分别是领域分析建模、领域设计建模和领域实现建模三个建模活动的产物。
		  
		  
		  值得注意的是，领域模型并非由开发团队单方面输出的产物，而是由产品、领域专家和开发团队共同协作的结果。领域专家通过领域模型能够判断系统所支持的领域能力，以及由此编排出来的上层业务能力；开发团队通过领域模型能够形成基本的代码框架（包括架构分层，每层需要定义的接口，接口的命名等）。同理，领域模型的调整，也意味着领域知识或业务规则的变化，也预示着系统所支持的业务能力和代码实现同样需要作出改变。
		  
		  

	- 7.2 领域分析建模

	  
	  领域分析建模：在限界上下文内，以“领域”为中心，提炼业务服务中的领域概念，确定领域概念之间的关系，最终形成领域分析模型。领域分析模型描述了各个限界上下文中的领域概念，以及领域概念之间的关系。
	  
	  下面讲述如何通过“快速建模法”来构建领域分析模型。
	  

		- 7.2.1 名词建模
		- 7.2.2 动词建模

		  
		  识别动词并不是为领域模型对象分配职责、定义方法，而是将识别出来的动词当做一个领域行为，然后看它是否产生了影响管理、法律或财务的过程数据。若存在，则将这些过程数据作为领域概念放到领域分析模型中。注意，这里的过程数据是要求会对企业运营和管理产生影响的数据，比如示例-SMS系统中老师提交修改申请，就会产生申请单这个过程数据，而请求流水记录、任务执行记录都不属于过程数据。
		  动词建模通过分析领域行为是否产生过程数据来找到隐藏的领域概念，弥补了名词建模的不足。
		  
		  
		  特别地，对于会产生领域事件的动词，一般可以抽象出一个已完成该动作的状态。
		  
		  

		- 7.2.3 提取隐式概念
		- 7.2.4 归纳抽象

		  
		  对于有定语修饰的名词，要注意分辨它们是类型的差异，还是值的差异。如配送地址和家庭地址，订单状态和商品状态。如果是值的差异，类型相同，应归并为一个领域概念（如，配送地址和家庭地址）；而类型不同，则不能合并（如，订单状态和商品状态）。
		  
		  
		  特别地，当定语修饰的名词中，定语表示的是不同的限界上下文，且名词相同时（即名称相同、含义不同的领域概念），我们应该尽可能调整命名，确保含义不同的领域概念的名称不同，以避免不必要的歧义和沟通上的误解。比如：商品的订单和库存的订单在特定限界上下文内都可以命名为order，但是如果把库存的订单改为库存的配送单delivery效果会更好。
		  
		  
		  

		- 7.2.5 确认关系

		  
		  根据业务需求和领域知识，判断领域概念之间是否存在关联。且对于1:N, N:1, M:N的关联关系，我们需要判断是否可以为这些关联关系定义一个新的类型，比如作品与读者存在1:N的关系，我们可以定义“订阅”这个概念来描述这种关系。
		  
		  
		  注意，我们需要尽量避免对象中的双向关系，即对象A关联对象B，而对象B关联对象A。当两个对象存在双向关系时，会为管理他们的生命周期带来额外的复杂度。我们应该规定一个遍历方向，来表明一个方向的关联比另一个方向的关联更有意义且更重要，比如示例SMS中，成绩会关联课程（成绩实例中包含课程ID），而课程不会关联成绩。当然，当双向关系是领域的一个概念时，我们还是应该保留它。
		  
		  

		- 7.2.6 示例-SMS的领域分析模型

		  通过名词建模，动词建模和归纳抽象后，可提炼出以下领域对象：成绩（Result）、绩点（gpa）、总成绩（total result）、总绩点（total gpa）、学年（school year）、学期（semester）、课程（course）、学分（credit）、申请单（application receipt），邮件（mail），排名（rank），申请单状态（application receipt status）
		  

	- 7.3 领域设计建模

		- 7.3.1 设计要素

		  
		  领域驱动设计强调以“领域”为核心驱动力。设计领域模型时应该尽量避免陷入到技术实现的细节约束中。但很多时候我们又不得不去思考一些非领域相关的问题：
		  
		  领域模型对象在身份上是否存在明确的差别？
		  领域模型对象的加载以及对象间的关系如何处理？
		  领域模型对象如何实现数据的持久化？
		  领域模型对象彼此之间如何做到弱依赖地完成状态的变更通知？
		  
		  为了解答上述的四个问题，DDD提供了很多的设计要素，它们能够帮助我们在不陷入到具体技术细节的情况下进行领域模型的设计。
		  
		  

			- 7.3.1.1 实体
			- 7.3.1.2 值对象
			- 7.3.1.3 聚合

			  
			  聚合的基本特征：
			  
			  聚合是包含了实体和值对象的一个边界。
			  聚合内包含的实体和值对象形成一棵树，只有实体才能作为这棵树的根。
			  外部对象只允许持有聚合根的引用，以起到边界控制作用。
			  聚合作为一个完整的领域概念整体，其内部会维护这个领域概念的完整性。
			  由聚合根统一对外提供履行该领域概念职责的行为方法，实现内部各个对象之间的行为协作。
			  

			- 7.3.1.4 工厂

			  
			  聚合中的工厂：一个类或方法只要封装了聚合对象的创建逻辑，都可以认为是工厂。表现形式如下：
			  
			  引入专门的聚合工厂（尤其适合需要通过访问外部资源来完成创建的复杂创建逻辑）
			  聚合自身担任工厂（简单工厂模式）
			  服务契约对象或装配器（assembler）担任工厂（负责将外部请求对象DTO转换为实体）
			  使用构建者组装聚合
			  
			  注意！这里工厂创建的基本单元是聚合，而非实体，注意与实体中的创建行为区分。
			  
			  

			- 7.3.1.5 资源库

			  
			  资源库是对数据访问的一种业务抽象，用于解耦领域层与外部环境，使领域层变得更为纯粹。资源库可以代表任何可以获取资源的仓库，例如网络或其他硬件环境，而不局限于数据库。
			  
			  
			  一个聚合对应一个资源库。领域驱动设计引入资源库，主要目的是管理聚合的生命周期。资源库负责聚合记录的查询与状态变更，即“增删改查”操作。资源库分离了聚合的领域行为和持久化行为，保证了领域模型对象的业务纯粹性。
			  
			  
			  值得注意的是，资源库的操作单元是聚合。当我们定义资源库的接口时，接口的入参应该为聚合的根实体。如果要访问聚合内的非根实体，也只能通过资源库获得整个聚合后，将根实体作为入口，在内存中访问封装在聚合边界内的非根实体对象。
			  
			  

			- 7.3.1.6 领域服务

			  
			  聚合通过聚合根的领域行为对外提供服务，而领域服务则是对聚合根的领域行为的补充。因此，我们应该尽量优先通过聚合根的领域行为来满足业务服务。
			  
			  
			  那什么场景下我们会需要用到领域服务呢？有如下两个：
			  
			  生命周期管理。为了避免领域知识的泄露，应用服务不会直接引用聚合生命周期相关的服务（工厂、资源库接口），而聚合根实体一般不会依赖资源库接口，此时就需要领域服务进行组合对外暴露。
			  依赖外部资源。为了保证聚合的稳定性，聚合根实体不会依赖防腐层接口。因此，当聚合对外暴露的服务需要设计外部资源访问时，就需要通过领域服务来完成。
			  

			- 7.3.1.7 领域事件

			  
			  领域事件属于领域层的领域模型对象，由限界上下文中的聚合发布，感兴趣的聚合（同一限界上下文/不同限界上下文）可以进行消费。而当一个事件由应用层发布，则该事件为应用事件。
			  
			  
			  引入领域事件首要目的是更好地跟踪实体状态的变更，并在状态变更时，通过事件消息的通知完成领域模型对象之间的协作。
			  
			  
			  领域事件的特征：
			  
			  领域事件代表了领域的概念；
			  领域事件是已经发生的事实（表示事件的名称应该是过去时，比如Committed）；
			  领域事件是不可变的领域对象；
			  领域事件会基于某个条件而触发。
			  
			  领域事件的用途：
			  
			  发布状态变更；
			  发布业务流程中的阶段性成果；
			  异步通信。
			  
			  领域事件应该包含：
			  
			  身份标识，即事件ID，为通用类型的身份标识；
			  事件发生的时间戳，便于记录和跟踪；
			  属性需要针对订阅者的需求，在增强事件和反向查询之间进行权衡。增强事件指属性中包含订阅者所需的所有数据；反向查询则是属性包含事件ID，当订阅者需要数据时通过事件ID进行反向查询。
			  

		- 7.3.2 设计聚合

			- 7.3.2.1 设计的经验法则
			- 7.3.2.2 设计步骤

				- 1. 理顺对象图

				  聚合本质是一个高内聚的边界，因此我们可以根据领域对象之间关系的强弱来定义出聚合的边界。对象间的关系由强到弱可以分为：泛化关系，关联关系和依赖关系。其中关联关系和依赖关系在 7.3.2.1 小节已讲述，而泛化关系可以理解为是继承关系（即父子关系）。
				  

					- 泛化关系

					  
					  虽然泛化关系是强耦合关系，但是根据对业务理解的视角不同，会产生不同的设计：
					  
					  整体视角：调用者并不关心特化的子类之间的差异，而是将整个继承体系视为一个整体。此时应以泛化的父类作为聚合根。
					  独立视角：调用这只关注具体的特化子类，体现了概念的独立性，此时应以特化的子类作为独立的聚合根。
					  

					- 关联关系

					  
					  关联关系
					  
					  
					  上述提到过，聚合间的关联关系会涉及聚合A对聚合B的生命周期管理，这其实是一个比较宽松的约束。那聚合内实体的关联关系应该是怎么样的呢？生命周期一致的、共存亡的，当主实体被销毁时，从实体也随之会被销毁。比如商品实体和商品明细实体。而在示例-SMS中，成绩和总成绩会被定义为两个聚合，原因是总成绩在成绩锁定后被统计，随后将不再发生改变，可见两者不存在上述的共存亡的关联关系。
					  
					  
					  PS: 实际上根据关联关系来区分边界的方法同样适用于限界上下文的边界划分。比如示例-SMS中的课程和成绩生命周期不同，先有课程，后有成绩；而且成绩锁定后，课程被撤销也不会对成绩有影响，因此就可以定义出课程上下文和成绩上下问。
					  
					  

					- 依赖关系

					  
					  依赖关系
					  
					  依赖关系主要体现的是实体间的职责委派和创建行为，可以分到不同的聚合边界。
					  
					  

		- 7.3.3 设计服务

		  这里的服务是对应用服务、领域服务、领域行为（实体提供的方法）和端口（资源库接口、防腐层接口）的统称。
		  

			- 7.3.3.1 分解任务

			  业务服务包含若干个组合服务，组合服务包含若干个原子服务。领域行为和端口都可以认为是原子服务。
			  

			- 7.3.3.2 分配职责

			  
			  应用服务：匹配业务服务，提供满足业务需求的服务接口。应用服务自身并不包含任何领域逻辑，仅负责协调领域模型对象，通过它们的领域能力组合完整一个完整的应用目标。
			  
			  
			  领域服务：匹配组合服务，执行业务功能，若原子任务为无状态行为或独立变化的行为，也可以匹配领域服务。控制多个聚合与端口之间的协作，由它来承担组合任务的执行。
			  
			  
			  领域行为：匹配原子服务，提供业务功能的业务实现。强调无状态和独立变化，由实体提供。
			  
			  
			  端口：匹配原子服务，抽象对外资源的访问，主要的端口包括资源库接口和防腐层接口。
			  
			  

		- 7.3.4 示例-SMS的领域设计模型

	- 7.4 领域实现建模

	  领域实现建模关注的并非是如何进行代码实现，而是如何验证代码实现的正确性，保证实现的高质量。
	  

		- 7.4.1 领域模型与测试金字塔

		  领域模型中的服务包括了应用服务、领域服务、领域行为和端口。其中通过Provider（面向服务行为）、Resource（面向服务资源）、Subscriber（面向事件）、Controller（面向视图模型）对外进行暴露的，我们称为远程服务。
		  

		- 7.4.2 测试驱动开发

		  
		  领域实现建模提倡的是测试驱动开发的编程思想，即要求开发者在进行逻辑实现前，优先进行测试用例的编写，站在调用者角度而非实现者角度去思考接口。
		  
		  
		  在上述测试金字塔中，开发者需要关注的是单元测试（不依赖任何外部资源的测试就是单元测试）。在领域设计建模阶段，我们对业务服务/应用服务进行分解，定义出了领域行为和领域服务。对于领域行为，由于其不依赖外部资源，因此我们可以直接编写单元测试；而对于领域服务，其可能会通过端口访问外部资源，此时我们需要对端口进行mock，以隔离外部资源对领域逻辑验证的干扰。特别地，单元测试一定要覆盖所有对业务规则的验证，这是保证领域行为和领域服务正确性的基础。
		  
		  
		  单元测试编码规范：
		  
		  测试类的命名应与被测试类保持一致，为“被测类名称+Test后缀”。
		  测试方法表达业务或业务规则为目的。
		  测试方法体遵循Given-When-Then模式。Given: 为要测试的方法提供准备，包括创建被测试对象，为调用方法准备输入参数实参等；When: 调用被测试的方法，遵循单一职责原则，在一个测试方法的When部分，应该只有一条语句对被测方法进行调用；Then: 对被测方法调用后的结果进行预期验证。
		  

- 8.分层架构与代码骨架

	- 8.1 分层架构

	  
	  代码架构分层是经典DDD四层：用户接口层，应用层，领域层和基础设施层。
	  
	  
	  需要注意的的地方是：
	  
	  用户接口层根据通信方式的不同，区分开了Provider（面向服务行为）、Subscriber（面向事件）、Controller（面向视图模型&资源） 、Task（面向策略/定时任务）。
	  基础设施层单独划分了 infranstructure-impl模块。为了保证领域层的纯洁性，DDD通过依赖倒置把访问外部系统（数据库，第三方系统）的服务的实现都下放到了基础设施层，而 infranstructure-impl模块 则是对这些实现进行了归集。这样做的好处有两个：第一，依赖关系明确，（infransturcture-impl —> domain，application）, （interface、application、domain —> infranstructure）；第二，拆分服务更便捷。当我们需要部分领域独立拆分出来的时候，在实现层面就只需要关注 infransturcture-impl模块 即可。
	  Infranstructure-impl模块依赖应用层的原因是应用层可能会抽象出防腐层接口，需要infranstruct-impl为其提供实现。
	  

	- 8.2 代码骨架

		- 8.2.1 用户接口层
		- 8.2.2 应用层
		- 8.2.3 领域层
		- 8.2.4 基础设施实现层

- 9.杂谈

	- 9.1 DDD与微服务

	  
	  微服务拆解指的是把一个单体服务拆分为粒度“足够小”的多个服务，而这里的“足够小”是一个主观的，没有任何标准的定义。尽管如此，我们对“微”这个词还是有一些基本要求的：足够内聚，足够独立，足够完备，这才使得拆分出来的微服务收益大于投入，试想如果一个微服务提供的业务功能会牵扯到与其他众多微服务的协作，那岂不是芭比Q了。
	  
	  
	  而上述我们对微服务的基本要求，实际上与限界上下文的特征（最小完备，自我履行，稳定空间，独立进化）不谋而合，因此，我们可以把限界上下文映射为微服务。我在日常实践中，都是将限界上下文和微服务的关系进行一一对应的，但这不是绝对的！限界上下文是站在领域角度给出的逻辑边界，而微服务的设计往往还要考虑物理边界，以及实际的质量需求（性能，可用性，安全性等），比如当我们采用的是CQRS架构，领域模型会被分为命令模型和查询模型，虽然它们同属一个限界上下文，但是它们往往是物理隔离的。因此，限界上下文只能作为微服务拆分的指导，而拆分过程中需要考虑质量需求，架构设计等技术因素。
	  
	  

	- 9.2 事务

		- 9.2.1 本地事务
		- 9.2.2 Saga事务

- 10. 参考

### 2. 千万同时在线直播聊天室架构演进

- 聊天室概述

	- 1500w在线的挑战

- 聊天室1.0架构

	- 消息框架选型：读扩散
	- longpolling机制
	- 无状态cache的设计

- 聊天室2.0架构

	- 分布式在线统计
	- 流量隔离vipsect
	- 自动柔性下的流量把控

- 成果

### 3. 聚焦！分布式唯一 ID 生成方案

- 1. 分布式唯一 ID 特性
- 2. 常用分布式唯一 ID 生成方案

	- 2.1. UUID
	- 2.2. 数据库自增 ID
	- 2.3. Redis 生成 ID
	- 2.4. Zookeeper 生成 ID
	- 2.5. Snowflake 算法

- 3. 数据库号段模式

	- 3.1. 号段模式介绍
	- 3.2. 美团 Leaf-segment 方案
	- 3.3. 滴滴 Tingid 方案
	- 3.4. 微信序列号生成方案

- 4. 雪花模式

	- 4.1. 雪花模式介绍
	- 4.2. 美团 Leaf-snowflake 方案
	- 4.3. 百度 UidGenerator 方案
	- 4.4. 基于多时间线改进的雪花算法

### 4. 后台服务架构高性能设计之道

- 前言
- 1 无锁化

	- 1.1 串行无锁
	- 1.2 结构无锁

- 2 零拷贝

	- 2.1 内存映射
	- 2.2 零拷贝

- 3 序列化

	- 3.1 分类
	- 3.2 性能指标
	- 3.3 选型考量

- 4 池子化

	- 4.1 内存池
	- 4.2 线程池
	- 4.3 连接池
	- 4.4 对象池

- 5 并发化

	- 5.1 请求并发
	- 5.2 冗余请求

- 6 异步化

	- 6.1 调用异步化
	- 6.2 流程异步化

- 7 缓存

	- 7.1 缓存的使用场景
	- 7.2 缓存的分类
	- 7.3 缓存的模式
	- 7.4 缓存的回收策略
	- 7.5 缓存的崩溃与修复
	- 7.6 缓存的一些好实践

- 8 分片

	- 8.1 分片策略
	- 8.2 二级索引
	- 8.3 路由策略
	- 8.4 动态平衡
	- 8.5 分库分表
	- 8.6 任务分片

- 9 存储

	- 9.1 读写分离
	- 9.2 动静分离
	- 9.3 冷热分离
	- 9.4 重写轻读
	- 9.5 数据异构

- 10 队列

	- 10.1 应用场景
	- 10.2 应用分类

- 总结

## 美团技术团队

### 3. CompletableFuture原理与实践-外卖商家端API的异步化

- 0 背景
- 1 为何需要并行加载
- 2 并行加载的实现方式

	- 2.1 同步模型
	- 2.2 NIO异步模型
	- 2.3 为什么会选择CompletableFuture？

- 3 CompletableFuture使用与原理

	- 3.1 CompletableFuture的背景和定义

		- 3.1.1 CompletableFuture解决的问题
		- 3.1.2 CompletableFuture的定义

	- 3.2 CompletableFuture的使用

		- 3.2.1 零依赖：CompletableFuture的创建
		- 3.2.2 一元依赖：依赖一个CF
		- 3.2.3 二元依赖：依赖两个CF
		- 3.2.4 多元依赖：依赖多个CF

	- 3.3 CompletableFuture原理

		- 3.3.1 CompletableFuture的设计思想
		- 3.3.2 整体流程

- 4 实践总结

	- 4.1 线程阻塞问题

		- 4.1.1 代码执行在哪个线程上？

	- 4.2 线程池须知

		- 4.2.1 异步回调要传线程池
		- 4.2.2 线程池循环引用会导致死锁
		- 4.2.3 异步RPC调用注意不要阻塞IO线程池

	- 4.3 其他

		- 4.3.1 异常处理
		- 4.3.2 沉淀的工具方法介绍

- 5 异步化收益
- 6 参考文献

### 4. Java系列 | 远程热部署在美团的落地实践

- 1 前言

	- 1.1 什么是热部署
	- 1.2 为什么我们需要热部署

		- 1.2.1 开发自测场景
		- 1.2.2 联调场景

	- 1.3 热部署难在哪
	- 1.4 Sonic可以做什么
	- 1.5 Sonic远程热部署落地推广的实践经验

- 2 整体设计方案

	- 2.1 Sonic结构

	  Sonic插件由4大部分组成，包括脚本端、插件端、Agent端，以及Sonic服务端。脚本端负责自动化构建Sonic启动参数、服务启动等集成工作；IDEA插件端集成环境为开发者提供更便捷的热部署服务；Agent端随项目启动负责热部署的功能实现；服务端则负责收集热部署信息、失败上报等统计工作。
	  

	- 2.2 走进Agent

		- 2.2.1 Instrumentation类常用API
		- 2.2.2 Instrument简介
		- 2.2.3 启动时和运行时加载Instrument Agent过程

	- 2.3 那些年JVM和HotSwap之间的“相爱相杀”
	- 2.4 Sonic如何解决Instrumentation的局限性

- 3 Sonic热部署技术解析

	- 3.1 Sonic整体架构模型
	- 3.2 Sonic功能流转
	- 3.3 文件监听
	- 3.4 JVM Class Reload
	- 3.5 Spring Bean重载
	- 3.6 Spring XML重载
	- 3.7 MyBatis 热部署

- 4 总结

	- 4.1 热部署功能一览
	- 4.2 IDE插件集成
	- 4.3 推广使用情况

### 5. 知识图谱可视化技术在美团的实践与探索

知识图谱可视化可以更直观地查看和分析知识图谱的数据。本文主要介绍了美团平台在布局策略、视觉降噪、交互功能、可视化叙事、3D图谱可视化等方面的一些实践和探索，同时沉淀出了uni-graph图可视化解决方案，并支持了美团的很多业务场景，包括美团大脑、图数据库、智能IT运维、组件依赖分析、行业领域图谱等。希望能对从事知识图谱可视化方向的同学有所帮助或启发。


- 1 知识图谱可视化基本概念

	- 1.1 知识图谱技术的简介
	- 1.2 知识图谱可视化的简介

- 2 场景分析与架构设计

	- 2.1 场景需求分析
	- 2.2 技术选型与架构设计

- 3 技术挑战与方案设计

	- 3.1 布局策略

		- 提取数据特征优化布局
		- 层级数据布局方案
		- 布局参数配置化
		- 图数据库可视化-布局样式参数调整
		- 服务链路可视化-平铺层布局参数调整

	- 3.2 视觉降噪

		- 文字处理
		- 边处理

			- 多边散列排布
			- 多类型可调节边

	- 3.3 交互功能

		- 路径锁定
		- 聚焦展现

	- 3.4 美团大脑可视化

		- 多屏适配方案
		- 现场效果
		- 动画脚本自动化
		- 美团大脑功能交互

	- 3.5 可视化叙事的探索

		- 扫光效果
		- 动效节奏调试

	- 3.6 3D可视化场景的探索

		- 节点样式优化
		- 3D动效

- 4 落地场景
- 5 未来展望

	- 交互场景
	- 效果呈现
	- 工具能力

## 字节跳动技术团队

### 5. 实战！如何从零搭建10万级 QPS 大流量、高并发优惠券系统

- 1. 需求背景
- 2. 需求拆解及技术选型

	- 需求拆解

	  ￼
	  

	- 系统选型及中间件

		- 存储

			- MySQL

		- 缓存

			- Redis

		- 消息队列

			- RocketMQ

		- 系统框架

			- kitex

- 3. 系统开发与实践

	- 系统设计实现
	- 系统整体架构

	  ￼
	  

	- 数据结构 ER 图

	  ￼
	  

	- 核心逻辑实现

		- 发券

			- 1. 如何解决幂等问题？

		- 券过期

- 4. 大流量、高并发场景下的问题及解决方案

	- 存储瓶颈及解决方案

		- 瓶颈

		  
		  在系统架构中，我们使用了 MySQL、Redis 作为存储组件。我们知道，单个服务器的 I/O 能力终是有限的，在实际测试过程中，能够得到如下的数据：
		  
		  单个 MySQL 的每秒写入在 4000 QPS 左右，超过这个数字，MySQL 的 I/O 时延会剧量增长。
		  MySQL 单表记录到达了千万级别，查询效率会大大降低，如果过亿的话，数据查询会成为一个问题。
		  Redis 单分片的写入瓶颈在 2w 左右，读瓶颈在 10w 左右
		  

		- 解决方案

		  读写分离。在查询券模板、查询券记录等场景下，我们可以将 MySQL 进行读写分离，让这部分查询流量走 MySQL 的读库，从而减轻 MySQL 写库的查询压力。
		  分治。在软件设计中，有一种分治的思想，对于存储瓶颈的问题，业界常用的方案就是分而治之：流量分散、存储分散，即：分库分表。
		  发券，归根结底是要对用户的领券记录做持久化存储。对于 MySQL 本身 I/O 瓶颈来说，我们可以在不同服务器上部署 MySQL 的不同分片，对 MySQL 做水平扩容，这样一来，写请求就会分布在不同的 MySQL 主机上，这样就能够大幅提升 MySQL 整体的吞吐量。
		  给用户发了券，那么用户肯定需要查询自己获得的券。基于这个逻辑，我们以 user_id 后四位为分片键，对用户领取的记录表做水平拆分，以支持用户维度的领券记录的查询。
		  每种券都有对应的数量，在给用户发券的过程中，我们是将发券数记录在 Redis 中的，大流量的情况下，我们也需要对 Redis 做水平扩容，减轻 Redis 单机的压力。
		  
		  

		- 容量预估

		  
		  基于上述思路，在要满足发券 12w QPS 的需求下，我们预估一下存储资源。
		  
		  
		  a. MySQL 资源
		  
		  
		  在实际测试中，单次发券对 MySQL 有一次非事务性写入，MySQL 的单机的写入瓶颈为 4000，据此可以计算我们需要的 MySQL 主库资源为：
		  
		  120000/4000 = 30
		  
		  b. Redis 资源
		  
		  
		  假设 12w 的发券 QPS，均为同一券模板，单分片的写入瓶颈为 2w，则需要的最少 Redis 分片为：
		  
		  120000/20000 = 6
		  

	- 热点库存问题及解决方案

		- 问题

		  大流量发券场景下，如果我们使用的券模板为一个，那么每次扣减库存时，访问到的 Redis 必然是特定的一个分片，因此，一定会达到这个分片的写入瓶颈，更严重的，可能会导致整个 Redis 集群不可用。
		  

		- 解决方案

		  
		  热点库存的问题，业界有通用的方案：即，扣减的库存 key 不要集中在某一个分片上。如何保证这一个券模板的 key 不集中在某一个分片上呢，我们拆 key（拆库存）即可。如图：
		  
		  
		  

		- 建券
		- 库存扣减

	- 券模板获取失败问题及解决方案

		- 问题
		- 解决方案

- 5. 服务治理

  
  系统开发完成后，还需要通过一系列操作保障系统的可靠运行。
  
  超时设置。优惠券系统是一个 RPC 服务，因此我们需要设置合理的 RPC 超时时间，保证系统不会因为上游系统的故障而被拖垮。例如发券的接口，我们内部执行时间不超过 100ms，因此接口超时我们可以设置为 500ms，如果有异常请求，在 500ms 后，就会被拒绝，从而保障我们服务稳定的运行。
  监控与报警。对于一些核心接口的监控、稳定性、重要数据，以及系统 CPU、内存等的监控，我们会在 Grafana 上建立对应的可视化图表，在春节活动期间，实时观测 Grafana 仪表盘，以保证能够最快观测到系统异常。同时，对于一些异常情况，我们还有完善的报警机制，从而能够第一时间感知到系统的异常。
  限流。优惠券系统是一个底层服务，实际业务场景下会被多个上游服务所调用，因此，合理的对这些上游服务进行限流，也是保证优惠券系统本身稳定性必不可少的一环。
  资源隔离。因为我们服务都是部署在 docker 集群中的，因此为了保证服务的高可用，服务部署的集群资源尽量分布在不同的物理区域上，以避免由集群导致的服务不可用。
  

- 6. 系统压测及实际表现

	- 注意事项
	- 结论
	- 系统的业务思考

- 7. 总结

  
  从零搭建一个大流量、高并发的优惠券系统，首先应该充分理解业务需求，然后对需求进行拆解，根据拆解后的需求，合理选用各种中间件；本文主要是要建设一套优惠券系统，因此会使用各类存储组件和消息队列，来完成优惠券的存储、查询、过期操作；
  
  
  在系统开发实现过程中，对核心的发券、券过期实现流程进行了阐述，并针对大流量、高并发场景下可能遇到的存储瓶颈、热点库存、券模板缓存获取超时的问题提出了对应的解决方案。其中，我们使用了分治的思想，对存储中间件进行水平扩容以解决存储瓶颈；采取库存拆分子库存思路解决热点库存问题；引入本地缓存解决券模板从 Redis 获取超时的问题。最终保证了优惠券系统在大流量高并发的情景下稳定可用；
  
  
  除开服务本身，我们还从服务超时设置、监控报警、限流、资源隔离等方面对服务进行了治理，保障服务的高可用；
  
  
  压测是一个新服务不可避免的一个环节，通过压测我们能够对服务的整体情况有个明确的了解，并且压测期间暴露的问题也会是线上可能遇到的，通过压测，我们能够对新服务的整体情况做到心里有数，对服务上线正式投产就更有信心了。
  

### 6. 2022 春节抖音视频红包系统设计与实现

- 1. 我们做了什么

	- 业务背景
	- 业务玩法

		- B2C 红包
		- C2C 红包

	- 红包领取
	- 卫视春晚演示视频

- 2. 我们碰到的一些问题

	- 通用红包系统的设计
	- 大流量补贴的发放处理
	- 红包领取方案的选型
	- 稳定性容灾
	- 资金安全保证
	- 红包系统的压测

- 3. 我们怎么做的

	- 1. 通用红包系统的设计

		- 划分原则

			- 功能内聚，每个系统只处理一个任务，方便之后系统的开发和迭代，以及问题的排查
			- API 网关层只进行简单的 proxy 处理
			- 异步任务拆解
			- 读写分离，将红包的核心操作和红包的查询分成两个服务

		- 划分模块

			- 红包网关服务
			- 红包核心服务
			- 红包查询服务
			- 红包异步服务
			- 红包基础服务
			- 红包对账服务

		- 整体架构

	- 2. 大流量补贴的发放处理

		- 同步奖励发放
		- 异步奖励发放

			- 但是在异步的方式中，整个补贴的入账预估需要 10min，而用户在 APP 界面感知到发券后可能马上就会开始使用用补贴来发放视频红包，或者会去红包挂件查看自己已经领取的红包补贴，而此时补贴还未在红包系统中入账。

		- 最终方案

			- 1. 在用户使用红包补贴进行视频红包发放时，我们会先对该补贴进行一个入库操作，入库成功后才可以用这个补贴进行红包发放

	- 3. 红包领取方案的选型

		- 悲观锁方案
		- 红包预拆分方案
		- 最终方案

			- 红包 redis 限流

			  为尽可能少的减少 DB 锁冲突，首先会按照红包单号进行限流，每次允许剩余红包个数*1.5 的请求量通过。被限流返回特殊错误码，前端最多轮训 10 次，在请求量过多的情况下通过这种方式来慢慢处理
			  
			  

			- 内存排队

			  除了 redis 限流外，为了减少 DB 锁，我们在领取流程中加个一个红包内存锁，对于单个红包，只有获取到内存锁的请求才能继续去请求 DB，从而将 DB 锁的冲突迁移到内存中提前处理，而内存资源相对于 DB 资源来说是非常廉价的，在请求量过大时，我们可以水平扩容。
			  为了实现内存锁，我们进行了几个改动。首先需要保证同一个红包请求能打到同一个 tce 实例上，这里我们对网关层路由进行了调整，在网关层调用下游服务时，会按照红包单号进行路由策略，保证同一单号的请求打到同一个实例上。另外我们在红包系统的 core 服务中基于 channel 实现了一套内存锁，在领取完成后会释放该红包对应的内存锁。另外为了防止锁的内存占用过大或者未及时释放，我们起了一个定时任务去定期地处理。
			  
			  

			- 转账异步化

			  从接口耗时来看，转账是一个耗时较长的操作，本身涉及和第三方支付机构交互，会有跨机房请求，响应延时较长，将转账异步化可以降低领取红包接口的时延，提高服务性能和用户体验
			  另外从用户感知来看，用户更关注的是领取红包的点击开后是否领取成功，至于余额是否同步到账用户其实感知没那么强烈，另外转账本身也是有一个转账中到转账成功的过程，将转账异步化对于用户的感知基本没有影响
			  
			  

	- 4. 稳定性容灾

		- 接口限流
		- 业务降级

			- 核心依赖降级
			- 非核心依赖降级

		- 多重机制保证状态机的推进

	- 5. 资金安全保证

		- 交易幂等

			- 另外红包系统的补贴发放接口是幂等的，外部同一个单号多次请求发放补贴，我们需要保证只会发一张券

				- 1. 一个单号一张券

			- 同一个外部单号更换了 uid，就可能会导致两个请求分别打到不同的数据库实例上，导致唯一索引失效，造成资损

				- 1. 什么情况下会更换uid?

			- 我们又额外的引入一个以补贴发放外部单号作为分片键的数据库来解决这个风险

				- 1. 同一订单只会请求同一分片数据库

		- B2C 红包核对
		- C2C 红包核对

		  在 C2C 链路中，整个主要从用户发起支付，到用户领取转账以及最后红包过期退款。在支付，转账，退款这三个流程都需要进行相应的核对。同时，还需要保证用户的红包发放金额大于等于红包转账金额+红包退款金额，这里大于等于是因为红包从发放成功到退款成功整个周期会在 24h 以上，另外可能存在转账在途的这种订导致会有多笔退款单，如果要求严格等于的话具体对账时机没法控制。
		  

	- 6. 红包系统的压测

	  
	  前面提到过，红包系统的链路包含有多个接口，发领查等，需要模拟用户的真实行为来进行压测才能得到系统的真实性能。这里我们使用了压测平台的脚本压测方式来进行压测。
	  
	  
	  首先需要对整个压测链路整个改造，和上下游沟通是否可以压测，不能压测的需要进行相应的 mock 处理。另外对于存储服务，数据库，redis 和 mq 都要确保压测标的正确传递，否则可能会影响到线上。
	  
	  
	  改造完压测链路后，需要构造相应的压测脚本，对于 B2C 和 C2C 分为两个脚本。
	  
	  

		- B2C 红包链路压测
		- C2C 红包链路压测

- 4. 后续规划

	- 服务 Set 化

### 7. 抖音支付十万级 TPS 流量发券实践

- 背景
- 抖音支付营销系统简介
- 挑战
- 方案

	- 性能保障
	- 异步发券-提升接口响应速度
	- 双层本地队列-提升处理能力，平滑流量
	- 库存扣减优化-减热点，降压力
	- 优雅退出-完善系统鲁棒性
	- 兜底补偿-保证最终一致性
	- 绿色通道-提升用户体验

- 资金防控

	- 幂等校验
	- 用户维度领取限制
	- 券批次组互斥
	- 库存防超卖

- 风控平台接入
- 数据监控与核对
- 总结
- 后续规划

## 苏三说技术

### Redis

- 一口气说出 Redis 16 个常见使用场景

- Redis夺命16问

### RPC

- openFeign夺命连环9问

## 网络文章

### 2. 深入浅出 HTTPS (详解版)

- 今日头条链接

- HTTP 概述

	- HTTP 是什么？
	- HTTP 发展史

		- 创世纪
		- HTTP/0.9
		- HTTP/1.0
		- TTP/1.1
		- HTTP/2
		- HTTP/3

	- 与 HTTP 相关的各种概念和协议

		- 浏览器
		- Web 服务器
		- TCP/IP
		- DNS
		- URI/URL
		- CDN
		- HTTPS
		- 代理
		- 小结

	- 总结

- SSL/TLS

  SSL/TLS是位于TCP/IP 7层协议中的会话层，用于认证用户和服务器，加解密数据以及维护数据的完整性，确保数据在传输过程中不会被修改。
  
  SSL 有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 TLS1.0 实际上就是 SSLv3.1。
  
  到今天 TLS 已经发展出了三个版本，分别是 2006 年的 1.1、2008 年的 1.2 和去年（2018）的 1.3，每个新版本都紧跟密码学的发展和互联网的现状，持续强化安全和性能，已经成为了信息安全领域中的权威标准。
  
  目前应用的最广泛的 TLS 是 1.2，而之前的协议（TLS1.1/1.0、SSLv3/v2）都已经被认为是不安全的，各大浏览器即将在 2020 年左右停止支持，所以接下来的讲解都针对的是 TLS1.2。
  
  TLS 由记录协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用了对称加密、非对称加密、身份认证等许多密码学前沿技术。浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件）。
  
  SSL/TLS分为对称加密和非对称加密两种方式。
  

- 对称加密

	- 对称加密是指加密和解密都用同一份密钥。

- 非对称加密

	- 非对称加密对应于一对密钥，称为私钥和公钥，用私钥加密后需要用公钥解密，用公钥加密后需要用私钥解密。
	- 对称加密的优点是运算速度快，缺点是互联网环境下无法将密钥安全的传送给对方。非对称加密的优点是可以安全的将公钥传递给对方，但是运算速度慢。

- 数字签名与证书

  
  黑客虽然拿不到会话密钥，无法破解密文，但可以通过窃听收集到足够多的密文，再尝试着修改、重组后发给网站。因为没有完整性保证，服务器只能“照单全收”，然后他就可以通过服务器的响应获取进一步的线索，最终就会破解出明文。
  
  另外，黑客也可以伪造身份发布公钥。如果你拿到了假的公钥，混合加密就完全失效了。你以为自己是在和“某宝”通信，实际上网线的另一端却是黑客，银行卡号、密码等敏感信息就在“安全”的通信过程中被窃取了。
  
  
  所以，在机密性的基础上还必须加上完整性、身份认证等特性，才能实现真正的安全。
  
  
  

- 摘要算法

  
  实现完整性的手段主要是摘要算法（Digest Algorithm），也就是常说的散列函数、哈希函数（Hash Function）。
  
  你可以把摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。
  
  换一个角度，也可以把摘要算法理解成特殊的“单向”加密算法，它只有算法，没有密钥，加密后的数据无法解密，不能从摘要逆推出原文。
  
  摘要算法实际上是把数据从一个“大空间”映射到了“小空间”，所以就存在“冲突”（collision，也叫碰撞）的可能性，就如同现实中的指纹一样，可能会有两份不同的原文对应相同的摘要。好的摘要算法必须能够“抵抗冲突”，让这种可能性尽量地小。
  
  因为摘要算法对输入具有“单向性”和“雪崩效应”，输入的微小不同会导致输出的剧烈变化，所以也被 TLS 用来生成伪随机数（PRF，pseudo random function）。
  
  你一定在日常工作中听过、或者用过 MD5（Message-Digest 5）、SHA-1（Secure Hash Algorithm 1），它们就是最常用的两个摘要算法，能够生成 16 字节和 20 字节长度的数字摘要。但这两个算法的安全强度比较低，不够安全，在 TLS 里已经被禁止使用了。
  
  目前 TLS 推荐使用的是 SHA-1 的后继者：SHA-2。
  
  SHA-2 实际上是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。
  

- 完整性
- 数字签名
- 数字证书和 CA
- HTTPS 建立连接
- TLS 协议的组成

	- 记录协议（Record Protocol）规定了 TLS 收发数据的基本单位：记录（record）。它有点像是 TCP 里的 segment，所有的其他子协议都需要通过记录协议发出。但多个记录数据可以在一个 TCP 包里一次性发出，也并不需要像 TCP 那样返回 ACK。
	- 警报协议（Alert Protocol）的职责是向对方发出警报信息，有点像是 HTTP 协议里的状态码。比如，protocol_version 就是不支持旧版本，bad_certificate 就是证书有问题，收到警报后另一方可以选择继续，也可以立即终止连接。
	- 握手协议（Handshake Protocol）是 TLS 里最复杂的子协议，要比 TCP 的 SYN/ACK 复杂的多，浏览器和服务器会在握手过程中协商 TLS 版本号、随机数、密码套件等信息，然后交换证书和密钥参数，最终双方协商得到会话密钥，用于后续的混合加密系统。
	- 最后一个是变更密码规范协议（Change Cipher Spec Protocol），它非常简单，就是一个“通知”，告诉对方，后续的数据都将使用加密保护。那么反过来，在它之前，数据都是明文的。

- CDHE 握手过程
- RSA 握手过程
- 双向认证

*XMind - Trial Version*