# 【精选文章】

## 1. 肝货！万字长文助你上手DDD
（阅读时间：2小时）

### 1.背景

### 2.DDD概要与实践感悟

- 2.1 复杂性

	- 规模：指的是系统所支持的功能点，以及功能点与功能点之间的的关系。DDD通过子领域，限界上下文，聚合等模式对问题进行拆分和归类，不断收窄问题域，保证聚合边界内所解决的问题集合足够收敛和可控。
	- 结构：指的是系统架构。系统架构是否分层；若分层，每层划分的职责边界是否清晰；架构的基本管理单元是什么，它决定了架构演进时的复杂度。DDD通过分层架构，独立出领域层，且架构中的每层都有清晰的职责。整体架构的基本管理单元是聚合，它是一个完整的、自治的管理单元，当需要进行服务拆分时，可以直接以聚合作为基本单元进行拆分。
	- 变化：指的是系统响应需求变化的能力。快速响应变化的有效手段是分离不易变逻辑和易变逻辑，"以不变应万变"。而通过分层架构独立的领域层正是不易变的逻辑。领域层是对领域知识的封装，其提供的领域服务具有经验性和前瞻性，是对领域内稳定的领域规则的表达。而领域层以外的应用层和基础设施层则是易变逻辑的封装。保证核心的独立和稳定，通过在调整应用层和基础设施层来实现快速响应需求变化。

- 2.2 领域驱动

	- 思维模式转变
	- 协同方式转变
	- 精炼循环

- 2.3 怎么才算DDD？

	- 构建出产品、领域专家和研发同学认知一致且便于交流的模型，并且模型与实现紧密绑定；
	- 模型逐步演进，反复消化和精炼；
	- 模型蕴含领域知识，足够稳定。

### 3.问题空间&解空间

- 3.1 问题空间&解空间
- 3.2 示例-学生管理系统的问题空间

### 4.领域驱动设计统一过程（DDDRUP）

### 5.全局分析阶段

- 5.1 形成统一语言
- 5.2 价值需求分析
- 5.3 业务需求分析

	- 5.3.1 业务流程、业务场景、业务服务和业务规则

		- 业务流程：表示的是一个完整的、端对端的服务过程。
		- 业务场景：按阶段性的业务目标划分业务流程，就可以获得业务场景。在示例-SMS中，老师修改成绩就分为了老师“提交申请单”，以及教务员“同意申请单”两个场景。
		- 业务服务：角色主动向目标系统发起服务请求完成一次完整的功能交互，以实现业务目标。角色可以用户、策略（定时任务）或者其他系统，完整则强调的是业务服务的执行序列的所有步骤都应该是连续且不可中断的。业务服务是业务需求分析最核心，也是最基础的单元，而业务流程和业务场景是为了更好地分析出业务服务。在示例-SMS中的“同意申请单”场景中包含了两个业务服务：教务员“同意申请单”和系统“邮件通知”教务员。
		- 业务规则：指对业务服务约束的描述，用于控制业务服务的对外行为。业务规则是业务服务正确性的基础。常见的业务规则有：a) 意如“若… , 就….” 的需求描述，比如示例-SMS中可提炼出“若成绩录入时间间隔超过一周，不予修改”；b) 具有事务性的操作。

	- 5.3.2 子领域

	  通过业务流程、业务场景和业务服务的梳理，基本可以分析出业务需求所需要的业务服务。然而，业务服务粒度太细，而问题空间又太大，我们需要找一个更粗粒度的业务单元，来帮助我们对业务服务进行聚类，一方面可以降低管理过多细粒度业务服务导致的额外复杂度，另一方面可以帮助领域专家和开发团队分析问题和设计方案时不至于陷入到业务细节中。而这个更粗粒度的业务单元就是子领域。
	  

		- 子领域的作用：

			- 划分问题空间，作为业务服务分类的边界；
			- 用于分辨问题空间的核心问题和次要问题。

		- 子领域的分类：

			- 核心子领域：能够体现系统愿景，具有产品差异化和核心竞争力的业务服务；
			- 通用子领域：包含的内容缺乏领域个性，具有较强的通用性，例如权限管理和邮件管理；
			- 支撑子领域：包含的内容多为“定制开发”，其为核心子领域的功能提供了支撑。

		- 子领域的功能分类策略：问题空间应该分为哪些子领域，需要团队对目标系统整体进行探索，并根据功能分类策略进行分解。

			- 业务职能：当目标系统运用于企业的生产和管理时，与目标系统业务有关的职能部门往往会影响目标系统的子领域划分，并形成一种简单的映射关系。这是康威定律的一种运用。
			- 业务产品：当目标系统为客户提供诸多具有业务价值的产品时，可以按照产品的内容与方向进行子领域划分。
			- 业务环节：对贯穿目标系统的核心业务流程进行阶段划分，然后按照划分出来的每个环节确定子领域。（这也是我们最常用的策略）
			- 业务概念：捕捉目标系统中一目了然的业务概念，将其作为子领域。

### 6.架构映射阶段

- 6.1 限界上下文的定义和特征

	- 6.1.1 限界上下文的定义

	  
	  限界上下文是语义和语境的边界。在问题空间，统一语言形成了团队对领域概念的统一表达，子领域形成了领域概念之间的边界。而在解空间，限界上下文可以看做是统一语言+子领域的融合体，统一语言需要在限界上下文内才具有明确的业务含义。
	  
	  以电商购物场景为例。在进行商品下单后，系统会生成一个订单；在用户付款完成后，系统也会生成一个订单；到了物流派送流程，系统还会生成一个订单。虽然这三个步骤中的领域概念都叫订单，但是他们的关注点/职责却不同：商品订单关注的是商品详情，支付订单关注的是支付金额和分润情况，物流订单关注的是收货地址。也就是说，商品、支付和物流分别为三个限界上下文，而订单作为统一语言需要在特定的限界上下文内，我们才能够明确其关注点/负责的职责。
	  
	  

	- 6.1.2 限界上下文的特征

		- 最小完备：限界上下文在履行属于自己的业务能力时，拥有的领域知识是完整的，无须针对自己的信息去求助别的限界上下文。
		- 自我履行：限界上下文能够根据自己拥有的知识来完成业务能力。自我履行体现了限界上下文纵向切分业务能力的特征。
		- 稳定空间：限界上下文必须防止和减少外部变化带来的影响。
		- 独立进化：指减少限界上下文内部变化对外界产生的影响。

- 6.2 限界上下文的识别

	- 6.2.1 按业务维度识别

		- 1. 归类

			- 语义相关性：存在相同或相似的领域概念，对应于业务服务描述的名词，如果不同的业务服务操作了相同或相似的对象，即可认为它们存在语义相关性。
			- 功能相关性：体现领域行为的相关性，业务服务是否服务于同一个业务目标。

		- 2. 归纳

		  归纳是对归类后的限界上下文进行命名。给限界上下文命名的过程，实际上也是对归类是否合理的再一次复查。限界上下文的命名同样需要遵循单一职责原则，它只能代表唯一的最能体现其特征的领域概念。倘若归类不合理，命名就会变得困难，这时候我们就需要反思（遵循知识消化循环）归类是否合理，并重新设计归类。
		  

		- 3. 边界梳理

		  归类和归纳之后，限界上下文的边界基本已经确定，边界梳理则是根据限界上下文特征（最小完备、自我履行、稳定空间和独立进化）以及子领域进行微调（当然也不排除大调）。
		  

			- 为什么需要根据子领域进行限界上下文边界的调整？限界上下文和子领域的关系是什么？
			- 理想的限界上下文与子领域的关系是一一对应的。上文提到，子领域是领域专家根据领域经验选择合适的功能分类策略进行划分，这个过程不会牵扯对业务服务的分析，体现的是领域专家对行业的洞见和深刻认识，可见获取子领域是一个自顶向下的过程。而限界上下文则是对业务服务进行归类、归纳、梳理和调整，最终形成一个个的边界，这是一个自下而上的过程。理想情况下，两者应该是双向奔赴的，自顶向下得到的子领域和自下而上得到的限界上下文能够完美契合！但是，现实哪有这么理想呢！所以一般情况下都需要我们进行调整，力求这两者能够一一对应。
			- 这里就再cue一下知识消化循环。优秀的领域专家划分出来的子领域，往往能够实现与限界上下文的一一对应。这就是经验的力量！那经验是怎么来的呢？我认为是领域专家经历了无数个知识消化循环之后沉淀下来的。领域专家一开始也是小白，划分出来的子领域在映射为限界上下文之后发现不同限界之间可能存在语义重叠，角色在不同限界上下文之中履行的职责可能很相似，于是他们通过知识消化循环，不断调整限界上下文的边界，然后又通过限界上下文调整子领域。慢慢地，稳定、可复用的子领域就被沉淀下来了。因此，识别限界上下文不是一个单向的过程，而是一个根据子领域调整限界上下文，然后又根据限界上下文调整子领域的循环的过程。

	- 6.2.2 验证

		- 正交原则

			- 正交性：如果两个或更多事物中的一个发生变化，不会影响其他事物，这些事物就是正交的。要破坏变化的传递性，就要保证每个限界上下文对外提供的业务服务不能出现雷同。

		- 奥卡姆剃刀原理

			- “如无必要，勿增实体”。这是避免过度设计的良方，同样也是我们识别限界上下文的原则。如果对识别出来的限界上下文的准确性依然心存疑虑，比较务实的做法是保证限界上下文具备一定的粗粒度。遵循该原则，意味着当我们没有寻找到必须切分限界上下文的必要证据时，就不要增加新的限界上下文。

- 6.3 上下文映射

  
  限界上下文封装了分离的业务能力，上下文映射则建立了限界上下文之间的关系。上下文映射提供了各种模式（防腐层、开放主机服务、发布语言、共享内核、合作者、客户方/供应方、分离方式、遵奉者、大泥球），本质是在控制变化在限界上下文之间传递所产生的影响。
  
  下文将提供服务的限界上下文称为“上游”上下文（U表示），消费服务的限界上下文称为“下游”上下文（D表示）。
  
  

	- 6.3.1 防腐层

		- 引入防腐层的目的是为了隔离耦合。防腐层往往位于下游，通过它隔离上游上下文发生的变化。

	- 6.3.2 开放主机服务（OHS）
	- 6.3.3 发布语言（PL）

	  
	  发布语言是一种公共语言，用于两个限界上下文之间的模型转换。防腐层和开放主机服务都是访问领域模型时建立的一层包装，前者针对发起调用的下游（通过基础设施层体现），后者针对响应请求的上游（通过应用层+远程服务），以避免上下游之间的通信集成将各自的领域模型引入进来，造成彼此之间的强耦合。因此，防腐层和开放主机服务操作的对象都不应该是各自的领域模型，这正是引入发布语言的原因。（对于熟悉云API的小伙伴就会发现，其实云API根据我们定义的接口生成对应的Request对象和Response对象，并集成在云API的SDK中，这些对象就是发布语言）。
	  
	  
	  一般情况下，发布语言根据开放主机服务的服务契约进行定义。
	  
	  
	  说到这里，我们惊讶地发现防腐层，开放主机服务和发布语言可以完美联动！
	  
	  

	- 6.3.4 共享内核

	  
	  共享内核指将限界上下文中的领域模型直接暴露给其他限界上下文使用。注意，这会削弱了限界上下文边界的控制力。上面我们讲述的防腐层、开放主机服务以及发布语言无不传达一种思想，限界上下文不能直接暴露自己的领域模型或直接访问其他限界上下文的领域模型，一定要有隔离层！
	  
	  但是，在特定的场景下，共享内核不见得不是一种合理的方式。任何软件设计决策都要考量成本与收益，只有收益高于成本，决策才是合理的。一般对于一些领域通用的值对象是相对稳定的，这些类型通常属于通用子领域，会被系统中几乎所有的限界上下文复用，那么这些领域模型就适合使用共享内核的方式。共享内核的收益不言而喻，而面临的风险则是共享的领域模型可能产生的变化。
	  
	  

	- 6.3.5 合作者

	  合作关系指的是协作的限界上下文由不同的团队负责，且这些团队之间具有要么一起成功，要么一起失败的强耦合关系。合作者模式要求参与的团队一起做计划、一起提交代码、一起开发和部署，采用持续集成的方式保证两个限界上下文的集成度与一致性，避免因为其中一个团队的修改影响集成点的失败。
	  

	- 6.3.6 客户方/供应方

	  
	  当一个限界上下文单向地为另一个限界上下文提供服务时，它们对应的团队就形成了客户方/供应方模式。这是最为常见的团队协作模式，客户方作为下游团队，供应方作为上游团队，二者协作的主要内容包括：
	  下游团队对上游团队提出的服务
	  上游团队提供的服务采用什么样的协议与调用方式
	  下游团队针对上游服务的测试策略
	  上游团队给下游团队承诺的交付日期
	  当上游服务的协议或调用方式发生变更时，如何控制变更
	  

	- 6.3.7 分离方式

	  分离方式的团队协作模式是指两个限界上下文之间没有一丁点关系。如果此时双方使用到了相似/相同的领域模型，则可以通过拷贝的方式解决，保证限界上下文之间的物理隔离！
	  

	- 6.3.8 遵奉者

	  
	  当上游的限界上下文处于强势地位，且上游团队响应不积极时，我们可以采用遵奉者模式。即下游严格遵从上游团队的模型，以消除复杂的转换逻辑。
	  
	  当下游团队选择“遵奉”于上游团队设计的模型时，意味着：
	  可以直接复用上游上下文的模型（好的）；
	  减少了两个限界上下文之间模型的转换成本（好的）；
	  使得下游限界上下文对上游产生了模型上的强依赖（坏的）。
	  

	- 6.3.9 大泥球

	  
	  一定要避免制造大泥球！大泥球的特点：
	  越来越多的聚合因为不合理的关联和依赖导致交叉污染；
	  对大泥球的维护牵一发而动全身；
	  强调“个人英雄主义”，只有个别“超人”能够理清逻辑。
	  

- 6.4 示例-SMS的限界上下文及其映射

	- 成绩上下文
	- 课程上下文
	- 审批上下文
	- 权限上下文
	- 邮件上下文

### 7.领域建模阶段

领域建模阶段由领域分析建模，领域设计建模和领域实现建模组成。在正式讲解建模活动前，先了解一下什么是模型驱动设计。


- 7.1 模型驱动设计

  
  模型是一种知识形式，它对知识进行了选择性的简化和有意的结构化，从而解决信息超载的问题。模型便于人们理解信息的意义，并专注核心问题。
  
  
  建模过程一般由分析活动、设计活动和实现活动组成。每一次建模活动都是一次对知识的提炼和转换，并产生相应的模型，即分析模型、设计模型和实现模型。
  
  
  建模过程并非是分析、设计和实现单向的前后串行过程，而是相互影响，不断切换和递进的关系。模型驱动设计的建模过程是：分析中蕴含了设计，设计中夹带了实现，甚至实现后还要回溯到设计和分析的一种迭代的、螺旋上升的演进过程。
  
  
  根据分解问题的视角不同，我们日常建立的模型可以大致分为以下三类：
  
  数据模型：将问题空间抽取出来的概念视为数据信息，在求解过程中关注数据实体的样式和它们之间的关系，由此建立的模型就是数据模型。
  服务模型：将每个问题视为目标系统为客户端提供的服务，在求解过程就会关注客户端发起的请求以及服务返回的响应，由此建立的模型就是服务模型。
  领域模型：围绕问题空间的业务需求，在求解过程中力求提炼出表达领域知识的逻辑概念，由此建立的模型就是领域模型。
  

	- 7.1.1 领域模型驱动设计

	  
	  一个优秀的领域模型应该具备以下的特征（我们也可以说具备这些特征的模型就是领域模型）：
	  
	  运用统一语言来表达领域中的概念；
	  蕴含业务活动和规则等领域知识；
	  对领域知识进行适度的提炼和抽象；
	  由一个迭代的演进过程建立；
	  有助于产品、领域专家和开发同学进行交流。
	  
	  领域建模阶段目的便是建立领域模型。领域模型由领域分析模型、领域设计模型以及领域实现模型共同组成，它们也分别是领域分析建模、领域设计建模和领域实现建模三个建模活动的产物。
	  
	  
	  值得注意的是，领域模型并非由开发团队单方面输出的产物，而是由产品、领域专家和开发团队共同协作的结果。领域专家通过领域模型能够判断系统所支持的领域能力，以及由此编排出来的上层业务能力；开发团队通过领域模型能够形成基本的代码框架（包括架构分层，每层需要定义的接口，接口的命名等）。同理，领域模型的调整，也意味着领域知识或业务规则的变化，也预示着系统所支持的业务能力和代码实现同样需要作出改变。
	  
	  

- 7.2 领域分析建模

  
  领域分析建模：在限界上下文内，以“领域”为中心，提炼业务服务中的领域概念，确定领域概念之间的关系，最终形成领域分析模型。领域分析模型描述了各个限界上下文中的领域概念，以及领域概念之间的关系。
  
  下面讲述如何通过“快速建模法”来构建领域分析模型。
  

	- 7.2.1 名词建模
	- 7.2.2 动词建模

	  
	  识别动词并不是为领域模型对象分配职责、定义方法，而是将识别出来的动词当做一个领域行为，然后看它是否产生了影响管理、法律或财务的过程数据。若存在，则将这些过程数据作为领域概念放到领域分析模型中。注意，这里的过程数据是要求会对企业运营和管理产生影响的数据，比如示例-SMS系统中老师提交修改申请，就会产生申请单这个过程数据，而请求流水记录、任务执行记录都不属于过程数据。
	  动词建模通过分析领域行为是否产生过程数据来找到隐藏的领域概念，弥补了名词建模的不足。
	  
	  
	  特别地，对于会产生领域事件的动词，一般可以抽象出一个已完成该动作的状态。
	  
	  

	- 7.2.3 提取隐式概念
	- 7.2.4 归纳抽象

	  
	  对于有定语修饰的名词，要注意分辨它们是类型的差异，还是值的差异。如配送地址和家庭地址，订单状态和商品状态。如果是值的差异，类型相同，应归并为一个领域概念（如，配送地址和家庭地址）；而类型不同，则不能合并（如，订单状态和商品状态）。
	  
	  
	  特别地，当定语修饰的名词中，定语表示的是不同的限界上下文，且名词相同时（即名称相同、含义不同的领域概念），我们应该尽可能调整命名，确保含义不同的领域概念的名称不同，以避免不必要的歧义和沟通上的误解。比如：商品的订单和库存的订单在特定限界上下文内都可以命名为order，但是如果把库存的订单改为库存的配送单delivery效果会更好。
	  
	  
	  

	- 7.2.5 确认关系

	  
	  根据业务需求和领域知识，判断领域概念之间是否存在关联。且对于1:N, N:1, M:N的关联关系，我们需要判断是否可以为这些关联关系定义一个新的类型，比如作品与读者存在1:N的关系，我们可以定义“订阅”这个概念来描述这种关系。
	  
	  
	  注意，我们需要尽量避免对象中的双向关系，即对象A关联对象B，而对象B关联对象A。当两个对象存在双向关系时，会为管理他们的生命周期带来额外的复杂度。我们应该规定一个遍历方向，来表明一个方向的关联比另一个方向的关联更有意义且更重要，比如示例SMS中，成绩会关联课程（成绩实例中包含课程ID），而课程不会关联成绩。当然，当双向关系是领域的一个概念时，我们还是应该保留它。
	  
	  

	- 7.2.6 示例-SMS的领域分析模型

	  通过名词建模，动词建模和归纳抽象后，可提炼出以下领域对象：成绩（Result）、绩点（gpa）、总成绩（total result）、总绩点（total gpa）、学年（school year）、学期（semester）、课程（course）、学分（credit）、申请单（application receipt），邮件（mail），排名（rank），申请单状态（application receipt status）
	  

- 7.3 领域设计建模

	- 7.3.1 设计要素

	  
	  领域驱动设计强调以“领域”为核心驱动力。设计领域模型时应该尽量避免陷入到技术实现的细节约束中。但很多时候我们又不得不去思考一些非领域相关的问题：
	  
	  领域模型对象在身份上是否存在明确的差别？
	  领域模型对象的加载以及对象间的关系如何处理？
	  领域模型对象如何实现数据的持久化？
	  领域模型对象彼此之间如何做到弱依赖地完成状态的变更通知？
	  
	  为了解答上述的四个问题，DDD提供了很多的设计要素，它们能够帮助我们在不陷入到具体技术细节的情况下进行领域模型的设计。
	  
	  

		- 7.3.1.1 实体
		- 7.3.1.2 值对象
		- 7.3.1.3 聚合

		  
		  聚合的基本特征：
		  
		  聚合是包含了实体和值对象的一个边界。
		  聚合内包含的实体和值对象形成一棵树，只有实体才能作为这棵树的根。
		  外部对象只允许持有聚合根的引用，以起到边界控制作用。
		  聚合作为一个完整的领域概念整体，其内部会维护这个领域概念的完整性。
		  由聚合根统一对外提供履行该领域概念职责的行为方法，实现内部各个对象之间的行为协作。
		  

		- 7.3.1.4 工厂

		  
		  聚合中的工厂：一个类或方法只要封装了聚合对象的创建逻辑，都可以认为是工厂。表现形式如下：
		  
		  引入专门的聚合工厂（尤其适合需要通过访问外部资源来完成创建的复杂创建逻辑）
		  聚合自身担任工厂（简单工厂模式）
		  服务契约对象或装配器（assembler）担任工厂（负责将外部请求对象DTO转换为实体）
		  使用构建者组装聚合
		  
		  注意！这里工厂创建的基本单元是聚合，而非实体，注意与实体中的创建行为区分。
		  
		  

		- 7.3.1.5 资源库

		  
		  资源库是对数据访问的一种业务抽象，用于解耦领域层与外部环境，使领域层变得更为纯粹。资源库可以代表任何可以获取资源的仓库，例如网络或其他硬件环境，而不局限于数据库。
		  
		  
		  一个聚合对应一个资源库。领域驱动设计引入资源库，主要目的是管理聚合的生命周期。资源库负责聚合记录的查询与状态变更，即“增删改查”操作。资源库分离了聚合的领域行为和持久化行为，保证了领域模型对象的业务纯粹性。
		  
		  
		  值得注意的是，资源库的操作单元是聚合。当我们定义资源库的接口时，接口的入参应该为聚合的根实体。如果要访问聚合内的非根实体，也只能通过资源库获得整个聚合后，将根实体作为入口，在内存中访问封装在聚合边界内的非根实体对象。
		  
		  

		- 7.3.1.6 领域服务

		  
		  聚合通过聚合根的领域行为对外提供服务，而领域服务则是对聚合根的领域行为的补充。因此，我们应该尽量优先通过聚合根的领域行为来满足业务服务。
		  
		  
		  那什么场景下我们会需要用到领域服务呢？有如下两个：
		  
		  生命周期管理。为了避免领域知识的泄露，应用服务不会直接引用聚合生命周期相关的服务（工厂、资源库接口），而聚合根实体一般不会依赖资源库接口，此时就需要领域服务进行组合对外暴露。
		  依赖外部资源。为了保证聚合的稳定性，聚合根实体不会依赖防腐层接口。因此，当聚合对外暴露的服务需要设计外部资源访问时，就需要通过领域服务来完成。
		  

		- 7.3.1.7 领域事件

		  
		  领域事件属于领域层的领域模型对象，由限界上下文中的聚合发布，感兴趣的聚合（同一限界上下文/不同限界上下文）可以进行消费。而当一个事件由应用层发布，则该事件为应用事件。
		  
		  
		  引入领域事件首要目的是更好地跟踪实体状态的变更，并在状态变更时，通过事件消息的通知完成领域模型对象之间的协作。
		  
		  
		  领域事件的特征：
		  
		  领域事件代表了领域的概念；
		  领域事件是已经发生的事实（表示事件的名称应该是过去时，比如Committed）；
		  领域事件是不可变的领域对象；
		  领域事件会基于某个条件而触发。
		  
		  领域事件的用途：
		  
		  发布状态变更；
		  发布业务流程中的阶段性成果；
		  异步通信。
		  
		  领域事件应该包含：
		  
		  身份标识，即事件ID，为通用类型的身份标识；
		  事件发生的时间戳，便于记录和跟踪；
		  属性需要针对订阅者的需求，在增强事件和反向查询之间进行权衡。增强事件指属性中包含订阅者所需的所有数据；反向查询则是属性包含事件ID，当订阅者需要数据时通过事件ID进行反向查询。
		  

	- 7.3.2 设计聚合

		- 7.3.2.1 设计的经验法则
		- 7.3.2.2 设计步骤

			- 1. 理顺对象图

			  聚合本质是一个高内聚的边界，因此我们可以根据领域对象之间关系的强弱来定义出聚合的边界。对象间的关系由强到弱可以分为：泛化关系，关联关系和依赖关系。其中关联关系和依赖关系在 7.3.2.1 小节已讲述，而泛化关系可以理解为是继承关系（即父子关系）。
			  

				- 泛化关系

				  
				  虽然泛化关系是强耦合关系，但是根据对业务理解的视角不同，会产生不同的设计：
				  
				  整体视角：调用者并不关心特化的子类之间的差异，而是将整个继承体系视为一个整体。此时应以泛化的父类作为聚合根。
				  独立视角：调用这只关注具体的特化子类，体现了概念的独立性，此时应以特化的子类作为独立的聚合根。
				  

				- 关联关系

				  
				  关联关系
				  
				  
				  上述提到过，聚合间的关联关系会涉及聚合A对聚合B的生命周期管理，这其实是一个比较宽松的约束。那聚合内实体的关联关系应该是怎么样的呢？生命周期一致的、共存亡的，当主实体被销毁时，从实体也随之会被销毁。比如商品实体和商品明细实体。而在示例-SMS中，成绩和总成绩会被定义为两个聚合，原因是总成绩在成绩锁定后被统计，随后将不再发生改变，可见两者不存在上述的共存亡的关联关系。
				  
				  
				  PS: 实际上根据关联关系来区分边界的方法同样适用于限界上下文的边界划分。比如示例-SMS中的课程和成绩生命周期不同，先有课程，后有成绩；而且成绩锁定后，课程被撤销也不会对成绩有影响，因此就可以定义出课程上下文和成绩上下问。
				  
				  

				- 依赖关系

				  
				  依赖关系
				  
				  依赖关系主要体现的是实体间的职责委派和创建行为，可以分到不同的聚合边界。
				  
				  

	- 7.3.3 设计服务

	  这里的服务是对应用服务、领域服务、领域行为（实体提供的方法）和端口（资源库接口、防腐层接口）的统称。
	  

		- 7.3.3.1 分解任务

		  业务服务包含若干个组合服务，组合服务包含若干个原子服务。领域行为和端口都可以认为是原子服务。
		  

		- 7.3.3.2 分配职责

		  
		  应用服务：匹配业务服务，提供满足业务需求的服务接口。应用服务自身并不包含任何领域逻辑，仅负责协调领域模型对象，通过它们的领域能力组合完整一个完整的应用目标。
		  
		  
		  领域服务：匹配组合服务，执行业务功能，若原子任务为无状态行为或独立变化的行为，也可以匹配领域服务。控制多个聚合与端口之间的协作，由它来承担组合任务的执行。
		  
		  
		  领域行为：匹配原子服务，提供业务功能的业务实现。强调无状态和独立变化，由实体提供。
		  
		  
		  端口：匹配原子服务，抽象对外资源的访问，主要的端口包括资源库接口和防腐层接口。
		  
		  

	- 7.3.4 示例-SMS的领域设计模型

- 7.4 领域实现建模

  领域实现建模关注的并非是如何进行代码实现，而是如何验证代码实现的正确性，保证实现的高质量。
  

	- 7.4.1 领域模型与测试金字塔

	  领域模型中的服务包括了应用服务、领域服务、领域行为和端口。其中通过Provider（面向服务行为）、Resource（面向服务资源）、Subscriber（面向事件）、Controller（面向视图模型）对外进行暴露的，我们称为远程服务。
	  

	- 7.4.2 测试驱动开发

	  
	  领域实现建模提倡的是测试驱动开发的编程思想，即要求开发者在进行逻辑实现前，优先进行测试用例的编写，站在调用者角度而非实现者角度去思考接口。
	  
	  
	  在上述测试金字塔中，开发者需要关注的是单元测试（不依赖任何外部资源的测试就是单元测试）。在领域设计建模阶段，我们对业务服务/应用服务进行分解，定义出了领域行为和领域服务。对于领域行为，由于其不依赖外部资源，因此我们可以直接编写单元测试；而对于领域服务，其可能会通过端口访问外部资源，此时我们需要对端口进行mock，以隔离外部资源对领域逻辑验证的干扰。特别地，单元测试一定要覆盖所有对业务规则的验证，这是保证领域行为和领域服务正确性的基础。
	  
	  
	  单元测试编码规范：
	  
	  测试类的命名应与被测试类保持一致，为“被测类名称+Test后缀”。
	  测试方法表达业务或业务规则为目的。
	  测试方法体遵循Given-When-Then模式。Given: 为要测试的方法提供准备，包括创建被测试对象，为调用方法准备输入参数实参等；When: 调用被测试的方法，遵循单一职责原则，在一个测试方法的When部分，应该只有一条语句对被测方法进行调用；Then: 对被测方法调用后的结果进行预期验证。
	  

### 8.分层架构与代码骨架

- 8.1 分层架构

  
  代码架构分层是经典DDD四层：用户接口层，应用层，领域层和基础设施层。
  
  
  需要注意的的地方是：
  
  用户接口层根据通信方式的不同，区分开了Provider（面向服务行为）、Subscriber（面向事件）、Controller（面向视图模型&资源） 、Task（面向策略/定时任务）。
  基础设施层单独划分了 infranstructure-impl模块。为了保证领域层的纯洁性，DDD通过依赖倒置把访问外部系统（数据库，第三方系统）的服务的实现都下放到了基础设施层，而 infranstructure-impl模块 则是对这些实现进行了归集。这样做的好处有两个：第一，依赖关系明确，（infransturcture-impl —> domain，application）, （interface、application、domain —> infranstructure）；第二，拆分服务更便捷。当我们需要部分领域独立拆分出来的时候，在实现层面就只需要关注 infransturcture-impl模块 即可。
  Infranstructure-impl模块依赖应用层的原因是应用层可能会抽象出防腐层接口，需要infranstruct-impl为其提供实现。
  

- 8.2 代码骨架

	- 8.2.1 用户接口层
	- 8.2.2 应用层
	- 8.2.3 领域层
	- 8.2.4 基础设施实现层

### 9.杂谈

- 9.1 DDD与微服务

  
  微服务拆解指的是把一个单体服务拆分为粒度“足够小”的多个服务，而这里的“足够小”是一个主观的，没有任何标准的定义。尽管如此，我们对“微”这个词还是有一些基本要求的：足够内聚，足够独立，足够完备，这才使得拆分出来的微服务收益大于投入，试想如果一个微服务提供的业务功能会牵扯到与其他众多微服务的协作，那岂不是芭比Q了。
  
  
  而上述我们对微服务的基本要求，实际上与限界上下文的特征（最小完备，自我履行，稳定空间，独立进化）不谋而合，因此，我们可以把限界上下文映射为微服务。我在日常实践中，都是将限界上下文和微服务的关系进行一一对应的，但这不是绝对的！限界上下文是站在领域角度给出的逻辑边界，而微服务的设计往往还要考虑物理边界，以及实际的质量需求（性能，可用性，安全性等），比如当我们采用的是CQRS架构，领域模型会被分为命令模型和查询模型，虽然它们同属一个限界上下文，但是它们往往是物理隔离的。因此，限界上下文只能作为微服务拆分的指导，而拆分过程中需要考虑质量需求，架构设计等技术因素。
  
  

- 9.2 事务

	- 9.2.1 本地事务
	- 9.2.2 Saga事务

### 10. 参考

*XMind - Trial Version*