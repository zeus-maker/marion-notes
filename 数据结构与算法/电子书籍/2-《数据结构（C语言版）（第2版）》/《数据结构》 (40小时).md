# 《数据结构》
(40小时)

## 资料说明

### 1. 微信读书

- 《数据结构（C语言版）（第2版）》

### 2. B站视频

- 数据结构与算法基础（青岛大学-王卓）

### 3. 笔记项目

## 第1章 绪论

### 1.1 数据结构的研究内容

- 首先从具体问题抽象出数学模型，然后设计一个解此数学模型的算法，最后编写程序，进行测试、调试，直到解决问题。
- 例如，用计算机进行全球天气预报时，就需要求解一组球面坐标系下的二阶椭圆偏微分方程；预测人口增长情况的数学模型为常微分方程。求解这些数学方程的算法是计算数学研究的范畴，如高斯消元法、差分法、有限元法等算法。数据结构主要研究非数值计算问题，非数值计算问题无法用数学方程建立数学模型，下面通过三个实例加以说明。

	- 【例1.1】 学生学籍管理系统。
	- 【例1.2】 人机对弈问题。
	- 【例1.3】 最短路径问题。

### 1.2 基本概念和术语

- 1.2.1 数据、数据元素、数据项和数据对象
- 1.2.2 数据结构

	- 1．逻辑结构

	  线性结构包括线性表（典型的线性结构，如例1.1中的学生基本信息表）、栈和队列（具有特殊限制的线性表，数据操作只能在表的一端或两端进行）、字符串（也是特殊的线性表，其特殊性表现在它的数据元素仅由一个字符组成）、数组（是线性表的推广，它的数据元素是一个线性表）、广义表（也是线性表的推广，它的数据元素是一个线性表，但不同构，即或者是单元素，或者是线性表）。非线性结构包括树（具有多个分支的层次结构）和二叉树（具有两个分支的层次结构）、有向图（一种图结构，边是顶点的有序对）和无向图（另一种图结构，边是顶点的无序对）。
	  

		- 数据的逻辑结构有两个要素：一是数据元素；二是关系。
		- 根据数据元素之间关系的不同特性，通常有四类基本结构

			- （1）集合结构
			- （2）线性结构
			- （3）树结构
			- （4）图结构或网状结构

	- 2．存储结构

	  数据对象在计算机中的存储表示称为数据的存储结构，也称为物理结构。把数据对象存储到计算机时，通常要求既要存储各数据元素的数据，又要存储数据元素之间的逻辑关系，数据元素在计算机内用一个结点来表示。数据元素在计算机中有两种基本的存储结构，分别是顺序存储结构和链式存储结构。
	  

		- （1）顺序存储结构
		- （2）链式存储结构

- 1.2.3 数据类型和抽象数据类型

	- 1．数据类型
	- 2．抽象数据类型

	  抽象数据类型（Abstract Data Type，ADT）一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分：数据对象、数据对象上关系的集合以及对数据对象的基本操作的集合。
	  

### 1.3 抽象数据类型的表示与实现

- 复数的抽象数据类型定义

	- （1）定义部分：
	- （2）表示部分：
	- （3）实现部分：

### 1.4 算法和算法分析

- 1.4.1 算法的定义及特性

	- 算法（Algorithm）是为了解决某类问题而规定的一个有限长的操作序列。
	- 一个算法必须满足以下五个重要特性。

		- （1）有穷性。一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。
		- （2）确定性。对于每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义性，使算法的执行者或阅读者都能明确其含义及如何执行。
		- （3）可行性。算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。
		- （4）输入。一个算法有零个或多个输入。当用函数描述算法时，输入往往是通过形参表示的，在它们被调用时，从主调函数获得输入值。
		- （5）输出。一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有任何意义。当用函数描述算法时，输出多用返回值或引用类型的形参表示。

- 1.4.2 评价算法优劣的基本标准

	- （1）正确性。在合理的数据输入下，能够在有限的运行时间内得到正确的结果。
	- （2）可读性。一个好的算法，首先应便于人们理解和相互交流，其次才是机器可执行性。可读性强的算法有助于人们对算法的理解，而难懂的算法易于隐藏错误，且难于调试和修改。
	- （3）健壮性。当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而不会产生一些莫名其妙的输出结果。
	- （4）高效性。高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。时间复杂度和空间复杂度是衡量算法的两个主要指标。

- 1.4.3 算法的时间复杂度

	- 1．问题规模和语句频度
	- 2．算法的时间复杂度定义
	- 3．算法的时间复杂度分析举例

		- 常见的时间复杂度按数量级递增排列依次为：常量阶O(1)、对数阶O(log2n)、线性阶O(n)、线性对数阶O(nlog2n)、平方阶O(n2)、立方阶O(n3)、……、k次方阶O(nk)、指数阶O(2n)等。

	- 4．最好、最坏和平均时间复杂度

- 1.4.4 算法的空间复杂度

### 1.5 小结

- （1）数据结构是一门研究非数值计算程序设计中操作对象，以及这些对象之间的关系和操作的学科。
- （2）数据结构包括两个方面的内容：数据的逻辑结构和存储结构。同一逻辑结构采用不同的存储方法，可以得到不同的存储结构。

	- ① 逻辑结构是从具体问题抽象出来的数学模型，从逻辑关系上描述数据，它与数据的存储无关。根据数据元素之间关系的不同特性，通常有四类基本逻辑结构：集合结构、线性结构、树形结构和图状结构。
	- ② 存储结构是逻辑结构在计算机中的存储表示，有两类存储结构：顺序存储结构和链式存储结构。

- （3）抽象数据类型是指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分：数据对象、数据对象上关系的集合，以及对数据对象的基本操作的集合。
- （4）算法是为了解决某类问题而规定的一个有限长的操作序列。算法具有五个特性：有穷性、确定性、可行性、输入和输出。一个算法的优劣应该从以下四方面来评价：正确性、可读性、健壮性和高效性。
- （5）算法分析的两个主要方面是分析算法的时间复杂度和空间复杂度，以考察算法的时间和空间效率。一般情况下，鉴于运算空间较为充足，故将算法的时间复杂度作为分析的重点。算法执行时间的数量级称为算法的渐近时间复杂度，T(n)=O(f(n))，它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，简称时间复杂度。

### 习题

## 第2章 线性表

### 2.1 线性表的定义和特点

### 2.2 案例引入

### 2.3 线性表的类型定义

### 2.4 线性表的顺序表示和实现

### 2.5 线性表的链式表示和实现

- 2.5.1 单链表的定义和表示
- 2.5.2 单链表基本操作的实现
- 2.5.3 循环链表

	- 1. 其特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环
	- 2. 差别仅在于：当链表遍历时，判别当前指针p是否指向表尾结点的终止条件不同
	- 3. 将两个线性表合并成一个表时，仅需将第一个表的尾指针指向第二个表的第一个结点，第二个表的尾指针指向第一个表的头结点，然后释放第二个表的头结点

- 2.5.4 双向链表
- 2.5.5 单链表、循环链表和双向链表的时间效率比较

### 2.6 顺序表和链表的比较

- 2.6.1 空间性能的比较

	- （1）存储空间的分配
	- （2）存储密度的大小

- 2.6.2 时间性能的比较

	- （1）存取元素的效率
	- （2）插入和删除操作的效率

### 2.7 线性表的应用

- 2.7.1 线性表的合并
- 2.7.2 有序表的合并

### 2.8 案例分析与实现

- 案例2.1：一元多项式的运算。
- 案例2.2：稀疏多项式的运算。

	- 算法2.18 多项式的创建
	- 算法2.19 多项式的相加

- 案例2.3：图书信息管理系统。

### 2.9 小结

## 第3章 栈和队列

### 3.1 栈和队列的定义和特点

### 3.2 案例引入

- 案例3.1：数制的转换。
- 案例3.2：括号匹配的检验。
- 案例3.3：表达式求值。
- 案例3.4：舞伴问题。

### 3.3 栈的表示和操作的实现

- 3.3.1 栈的类型定义
- 3.3.2 顺序栈的表示和实现
- 3.3.3 链栈的表示和实现

### 3.4 栈与递归

- 3.4.1 采用递归算法解决的问题
- 3.4.2 递归过程与递归工作栈
- 3.4.3 递归算法的效率分析
- 3.4.4 利用栈将递归转换为非递归的方法

### 3.5 队列的表示和操作的实现

- 3.5.1 队列的类型定义
- 3.5.2 循环队列——队列的顺序表示和实现

	- 1．初始化
	- 2．求队列长度
	- 3．入队
	- 4．出队
	- 5．取队头元素

### 3.6 案例分析与实现

- 案例3.1：数制的转换。
- 案例3.2：括号匹配的检验。
- 案例3.3：表达式求值。
- 案例3.4：舞伴问题。

### 3.7 小结

## 第4章 串、数组和广义表
（3小时30分钟）

### 4.1 串的定义

### 4.2 案例引入

- 案例4.1：病毒感染检测。

### 4.3 串的类型定义、存储结构及其运算

- 4.3.1 串的抽象类型定义
- 4.3.2 串的存储结构

	- 1．串的顺序存储
	- 2．串的链式存储

- 4.3.3 串的模式匹配算法

### 4.4 数组

- 4.4.1 数组的类型定义
- 4.4.2 数组的顺序存储
- 4.4.3 特殊矩阵的压缩存储

### 4.5 广义表

- 4.5.1 广义表的定义
- 4.5.2 广义表的存储结构

### 4.6 案例分析与实现

- 案例4.1：病毒感染检测。

### 4.7 小结

### 习题

## 第5章 树和二叉树
（8小时）

### 5.1 树和二叉树的定义
（40分钟）

- 5.1.1 树的定义

- 5.1.2 树的基本术语

- 5.1.3 二叉树的定义

### 5.2 案例引入

- 案例5.1：数据压缩问题。
- 案例5.2：利用二叉树求解表达式的值。

### 5.3 树和二叉树的抽象数据类型定义

### 5.4 二叉树的性质和存储结构
（1小时20分钟）

- 5.4.1 二叉树的性质

	- 性质1 在二叉树的第i层上至多有2i−1个结点（i≥1）。
	- 性质2 深度为k的二叉树至多有2k−1个结点（k≥1）。
	- 性质3 对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。
	- 性质4 具有n个结点的完全二叉树的深度为[插图]注1。

	- 性质5 如果对一棵有n个结点的完全二叉树（其深度为[插图]）的结点按层序编号（从第1层到第[插图]层，每层从左到右），则对任一结点i（1≤i≤n），有

- 5.4.2 二叉树的存储结构
（30分钟）

	- 1．顺序存储结构
	- 2．链式存储结构

### 5.5 遍历二叉树和线索二叉树
(3小时)

- 5.5.1 遍历二叉树

	- 1．遍历二叉树算法描述
（1小时）

		- 算法5.1 中序遍历的递归算法
		- 算法5.2 中序遍历的非递归算法

		- 二叉树层次遍历

	- 2．根据遍历序列确定二叉树

	- 3．二叉树遍历算法的应用

		- （1）创建二叉树的存储结构——二叉链表

			- 算法5.3 先序遍历的顺序建立二叉链表

		- （2）复制二叉树

			- 算法5.4 复制二叉树

		- （3）计算二叉树的深度

			- 算法5.5 计算二叉树的深度

		- （4）统计二叉树中结点的个数

			- 算法5.6 统计二叉树中结点的个数

- 5.5.2 线索二叉树

	- 1．线索二叉树的基本概念
	- 2．构造线索二叉树

		- 算法5.7 以结点p为根的子树中序线索化
		- 算法5.8 带头结点的二叉树中序线索化

	- 3．遍历线索二叉树

		- 算法5.9 遍历中序线索二叉树

### 5.6 树和森林
（1小时）

- 5.6.1 树的存储结构
- 5.6.2 森林与二叉树的转换
- 5.6.3 树和森林的遍历

### 5.7 哈夫曼树及其应用

- 5.7.1 哈夫曼树的基本概念
- 5.7.2 哈夫曼树的构造算法
- 5.7.3 哈夫曼编码

### 5.8 案例分析与实现

### 5.9 小结

### 习题

## 第6章 图
（6小时）

### 6.1 图的定义和基本术语
（40分钟）

- 6.1.1 图的定义

	- 1. 图是什么？
	- 2. 图如何表示？
	- 3. 有向图如何表示？
	- 4. 无向图如何表示？

- 6.1.2 图的基本术语

	- （1）子图
	- （2）无向完全图和有向完全图
	- （3）稀疏图和稠密图
	- （4）权和网
	- （5）邻接点
	- （6）度、入度和出度
	- （7）路径和路径长度
	- （8）回路或环
	- （9）简单路径、简单回路或简单环
	- （10）连通、连通图和连通分量
	- （11）强连通图和强连通分量
	- （12）连通图的生成树
	- （13）有向树和生成森林

### 6.2 案例引入
（3分钟）

- 案例6.1：六度空间理论。

### 6.3 图的类型定义

- 1. 图的抽象数据类型

### 6.4 图的存储结构
（2小时30分钟）

- 6.4.1 邻接矩阵
（1小时）

	- 1．邻接矩阵表示法

		- 1. 图
		- 2. 网（有权图）

	- 2．采用邻接矩阵表示法创建无向网

		- 算法6.1 采用邻接矩阵表示法创建无向网

			- 1. 算法步骤

				- ① 输入总顶点数和总边数。
				- ② 依次输入点的信息存入顶点表中。
				- ③ 初始化邻接矩阵，使每个权值初始化为极大值。
				- ④ 构造邻接矩阵。依次输入每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。

			- 2. 算法描述
			- 3. 算法分析

		- 2. 无向图
		- 3. 有向网

	- 3．邻接矩阵表示法的优缺点

		- （1）优点

			- ① 便于判断两个顶点之间是否有边，即根据A[i][j]=0或1来判断。
			- ② 便于计算各个顶点的度。对于无向图，邻接矩阵第i行元素之和就是顶点i的度；对于有向图，第i行元素之和就是顶点i的出度，第i列元素之和就是顶点i的入度。

		- （2）缺点

			- ① 不便于增加和删除顶点。
			- ② 不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度为O(n2)。
			- ③ 空间复杂度高。

- 6.4.2 邻接表
（1小时）

	- 1．邻接表表示法

	  （1）表头结点表：由所有表头结点以顺序结构的形式存储，以便可以随机访问任一顶点的边链表。
	  （2）边表：由表示图中顶点间关系的2n个边链表组成。边链表中边结点包括邻接点域（adjvex）、数据域（info）和链域（nextarc）三部分
	  

	- 2．采用邻接表表示法创建无向图

		- 算法6.2 采用邻接表表示法创建无向图

			- 1. 算法步骤

			  ① 输入总顶点数和总边数。
			  ② 依次输入点的信息存入顶点表中，使每个表头结点的指针域初始化为NULL。
			  ③ 创建邻接表。依次输入每条边依附的两个顶点，确定这两个顶点的序号i和j之后，将此边结点分别插入vi和vj对应的两个边链表的头部。
			  

			- 2. 算法描述
			- 3．邻接表表示法的优缺点

				- （1）优点

				  ① 便于增加和删除顶点。
				  ② 便于统计边的数目，按顶点表顺序扫描所有边表可得到边的数目，时间复杂度为O(n+e)。
				  ③ 空间效率高。对于一个具有n个顶点e条边的图G，若G是无向图，则在其邻接表表示中有n个顶点表结点和2e个边表结点；若G是有向图，则在它的邻接表表示或逆邻接表表示中均有n个顶点表结点和e个边表结点。因此，邻接表或逆邻接表表示的空间复杂度为O(n+e)，适合表示稀疏图。对于稠密图，考虑到邻接表中要附加链域，因此常采取邻接矩阵表示法。
				  

				- （2）缺点

				  ① 不便于判断顶点之间是否有边，要判定vi和vj之间是否有边，就需扫描第i个边表，最坏情况下要耗费O(n)时间。
				  ② 不便于计算有向图各个顶点的度。对于无向图，在邻接表表示中顶点vi的度是第i个边表中的结点个数。在有向图的邻接表中，第i个边表上的结点个数是顶点vi的出度，但求vi的入度较困难，需遍历各顶点的边表。若有向图采用逆邻接表表示，则与邻接表表示相反，求顶点的入度容易，而求顶点的出度较难。
				  

		- 有向图

- 6.4.3 十字链表

	- 1. 解决有向图查入度边困难

- 6.4.4 邻接多重表

	- 2. 解决无向图有2次边

### 6.5 图的遍历
（1小时）

- 6.5.1 深度优先搜索

	- 1．深度优先搜索遍历的过程
	- 2．深度优先搜索遍历的算法实现

		- 1. 算法6.3 深度优先搜索遍历连通图

			- 1. 算法步骤

				- ① 从图中某个顶点v出发，访问v，并置visited[v]的值为true。
				- ② 依次检查v的所有邻接点w，如果visited[w]的值为false，再从w出发进行递归遍历，直到图中所有顶点都被访问过。

			- 2. 算法描述

		- 2. 算法6.4 深度优先搜索遍历非连通图
		- 3. 算法6.5 采用邻接矩阵表示图的深度优先搜索遍历
		- 4. 算法6.6 采用邻接表表示图的深度优先搜索遍历

	- 3．深度优先搜索遍历的算法分析

- 6.5.2 广度优先搜索

	- 1．广度优先搜索遍历的过程
	- 2．广度优先搜索遍历的算法实现
	- 3．广度优先搜索遍历的算法分析

### 6.6 图的应用

- 6.6.1 最小生成树

	- 1．普里姆算法

		- 1. 算法思想
		- （1）普里姆算法的构造过程
		- （2）普里姆算法的实现

			- 算法6.8 普里姆算法

	- 2．克鲁斯卡尔算法

		- （1）克鲁斯卡尔算法的构造过程

- 6.6.2 最短路径

	- 1．从某个源点到其余各顶点的最短路径

		- （1）迪杰斯特拉算法的求解过程

	- 2．每一对顶点之间的最短路径

		- 算法6.11 弗洛伊德算法

- 6.6.3 拓扑排序

	- 1．AOV-网
	- 2．拓扑排序的过程

		- （1）在有向图中选一个无前驱的顶点且输出它。
		- （2）从图中删除该顶点和所有以它为尾的弧。
		- （3）重复（1）和（2），直至不存在无前驱的顶点。
		- （4）若此时输出的顶点数小于有向图中的顶点数，则说明有向图中存在环，否则输出的顶点序列即为一个拓扑序列。

	- 3．拓扑排序的实现

- 6.6.4 关键路径
（1小时）

	- 1．AOE-网
	- 2．关键路径求解的过程
	- 3．关键路径算法的实现

### 6.7 案例分析与实现

### 6.8 小结

### 参考资料

- 知乎：什么是图计算及其应用场景？

## 第7章 查找

### 7.1 查找的基本概念

### 7.2 线性表的查找

- 7.2.1 顺序查找
- 7.2.2 折半查找
- 7.2.3 分块查找

### 7.3 树表的查找

- 7.3.1 二叉排序树
- 7.3.2 平衡二叉树
- 7.3.3 B-树
- 7.3.4 B+树

### 7.4 散列表的查找

- 7.4.1 散列表的基本概念
- 7.4.2 散列函数的构造方法
- 7.4.3 处理冲突的方法
- 7.4.4 散列表的查找

### 7.5 小结

### 习题

## 第8章 排序

### 8.1 基本概念和排序方法概述

- 8.1.1 排序的基本概念
- 8.1.2 内部排序方法的分类
- 8.1.3 待排序记录的存储方式
- 8.1.4 排序算法效率的评价指标

### 8.2 插入排序

- 8.2.1 直接插入排序
- 8.2.2 折半插入排序
- 8.2.3 希尔排序

### 8.3 交换排序

- 8.3.1 冒泡排序
- 8.3.2 快速排序

### 8.4 选择排序

- 8.4.1 简单选择排序
- 8.4.2 树形选择排序
- 8.4.3 堆排序

### 8.5 归并排序

### 8.6 基数排序

- 8.6.1 多关键字的排序
- 8.6.2 链式基数排序

### 8.7 外部排序

- 8.7.1 外部排序的基本方法
- 8.7.2 多路平衡归并的实现
- 8.7.3 置换-选择排序
- 8.7.4 最佳归并树

### 8.8 小结

### 习题

*XMind - Trial Version*