# JAVA高级面试题

## 第1章 JAVA相关面试题

### 1. JAVA面试题1

- 1、创建socket通讯的步骤？

	- 1、 服务器程序创建一个ServerSocket，然后再用accept方法等待客户来连接
	- 2、 客户端程序创建一个Socket并请求与服务器建立连接
	- 3、 服务器接收客户的连接请求,并创建一个新的Socket与该客户建立专线连接
	- 4、 刚才建立了连接的两个Socket在一个线程上对话
	- 5、 服务器开始等待新的连接请求

- 2、Java 中 sleep 方法和 wait 方法的区别？

	- 虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。

- 3、程序计数器(线程私有)

	- 一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有” 的内存。
	- 正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址） 。如果还是 Native 方法，则为空。
	- 这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。

- 4、什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？

	- 线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。

- 5、迭代器 Iterator 是什么？

	- Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。
	- 因为所有Collection接继承了Iterator迭代器

- 6、线程的 sleep()方法和 yield()方法有什么区别？

	- 1、 sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
	- 2、 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；
	- 3、 sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；
	- 4、 sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。

- 7、Java 中能创建 volatile 数组吗？

	- 能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。

- 8、java中equals方法的用法以及==的用法
- 9、如何创建一个json对象？

	- 使用{}实例化一个json对象，json对象多个元素使用逗号隔开，每个元素都是一个键值对

- 10、如何判断对象是否是垃圾？

	- **引用计数：**在对象中添加一个引用计数器，如果被引用计数器加 1，引用失效时计数器减 1，如果计数器为 0 则被标记为垃圾。原理简单，效率高，但是在 Java 中很少使用，因为存在对象间循环引用的问题，导致计数器无法清零。
	- **可达性分析：**主流语言的内存管理都使用可达性分析判断对象是否存活。基本思路是通过一系列称为 GC Roots 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为引用链，如果某个对象到 GC Roots 没有任何引用链相连，则会被标记为垃圾。可作为 GC Roots 的对象包括虚拟机栈和本地方法栈中引用的对象、类静态属性引用的对象、常量引用的对象。

- 11、GC是什么？为什么要有GC？
- 12、线程池四种创建方式？
- 13、形成死锁的四个必要条件是什么
- 14、java 面向对象编程三大特性------封装、继承、多态
- 15、什么是IoC和DI？DI是如何实现的？
- 16、假设数组内有5个元素，如果对数组进行反序，该如何做？
- 17、Java的内存模型是什么？（JMM是什么？）
- 18、什么时候用断言（assert）？
- 19、对象在哪块内存分配？
- 20、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？
- 21、怎么将 byte 转换为 String？
- 22、Swing 是线程安全的？
- 23、线程B怎么知道线程A修改了变量
- 24、notify() 和 notifyAll() 有什么区别？
- 25、Java 中的 LinkedList 是单向链表还是双向链表？
- 26、Java中垃圾回收有什么目的？什么时候进行垃圾回收？
- 27、你对线程优先级的理解是什么？
- 28、JVM内存模型
- 29、解释servlet如何完成生命周期?
- 30、Java中是如何支持正则表达式操作的？
- 31、接口有什么特点？
- 32、什么是过滤器？怎么创建一个过滤器
- 33、在 Java 程序中怎么保证多线程的运行安全？
- 34、直接内存是什么？
- 35、Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型
- 36、解释何时在Tomcat使用SSL ?
- 37、堆（Heap-线程共享） -运行时数据区
- 38、SWAP会影响性能么？
- 39、什么是方法内联？
- 40、谈一谈Hibernate的一级缓存、二级缓存和查询缓存。

### 2. JAVA面试题2

- 1、抽象工厂模式和原型模式之间的区别？

	- 抽象工厂模式：通常由工厂方法模式来实现。但一个工厂中往往含有多个工厂方法生成一系列的产品。这个模式强调的是客户代码一次保证只使用一个系列的产品。当要切换为另一个系列的产品，换一个工厂类即可。
	- 原型模式：工厂方法的最大缺点就是，对应一个继承体系的产品类，要有一个同样复杂的工厂类的继承体系。我们可以把工厂类中的工厂方法放到产品类自身之中吗？如果这样的话，就可以将两个继承体系为一个。这也就是原型模式的思想，原型模式中的工厂方法为clone，它会返回一个拷贝（可以是浅拷贝，也可以是深拷贝，由设计者决定）。为了保证用户代码中到时可以通过指针调用clone来动态绑定地生成所需的具体的类。这些原型对象必须事先构造好。
	- 原型模式想对工厂方法模式的另一个好处是，拷贝的效率一般对构造的效率要高。

- 2、在 Java 程序中怎么保证多线程的运行安全？

	- 出现线程安全问题的原因一般都是三个原因：
	- 1、 线程切换带来的原子性问题 解决办法：使用多线程之间同步synchronized或使用锁(lock)。
	- 2、 缓存导致的可见性问题 解决办法：synchronized、volatile、LOCK，可以解决可见性问题
	- 3、 编译优化带来的有序性问题 解决办法：Happens-Before 规则可以解决有序性问题

- 3、volatile 修饰符的有过什么实践？

	- 一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。

- 4、Java中各种数据默认值

	- 1、 Byte,short,int,long默认是都是0
	- 2、 Boolean默认值是false
	- 3、 Char类型的默认值是’’
	- 4、 Float与double类型的默认是0.0
	- 5、 对象类型的默认值是null

- 5、说说Java 垃圾回收机制

	- 在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

- 6、有没有可能两个不相等的对象有有相同的 hashcode？

	- 有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。

- 7、synchronized 和 Lock 有什么区别？

	- 1、 首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；
	- 2、 synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。
	- 3、 synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。
	- 4、 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。

- 8、什么是Vector

	- Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，访问它比访问ArrayList慢很多
	- ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。ArrayList的缺点是每个元素之间不能有间隔。

- 9、对象的访问定位有哪几种方式?

	- 建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针2种：
	- 句柄：如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
	- 直接指针：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。
	- 这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

- 10、equals 和 == 的区别？#

	- 通俗点讲：是看看左右是不是一个东西。equals是看看左右是不是长得一样。如何记住嘛。如果单纯是想记住，：等于。equals：相同。两个长得一样的人，只能说长的相同(equals)，但是不等于他们俩是一个人。你只要记住equals，==就不用记了。
	- 术语来讲的区别：
	- 1、 ==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同
	- 2、 ==是指对内存地址进行比较 equals()是对字符串的内容进行比较3.==指引用是否相同 equals()指的是值是否相同

- 11、Servlet中如何获取用户提交的查询参数或表单数据？
- 12、堆溢出的原因？
- 13、Java 中，怎么获取一个文件中单词出现的最高频率？
- 14、你知道哪些JVM性能调优
- 15、抽象类必须要有抽象方法吗？
- 16、串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？
- 17、React的请求应该放在哪个生命周期中?
- 18、volatile关键字的作用
- 19、我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？
- 20、什么是Java虚拟机
- 21、CMS 收集器（多线程标记清除算法）
- 22、接口和抽象类的区别是什么？
- 23、如何合理分配线程池大小?
- 24、什么是线程组，为什么在Java中不推荐使用？
- 25、类加载器
- 26、JVM 如何确定垃圾对象？
- 27、字符型常量和字符串常量的区别
- 28、G1 收集器
- 29、Java 中，直接缓冲区与非直接缓冲器有什么区别？
- 30、如何决定使用 HashMap 还是 TreeMap？
- 31、说一下 ArrayList 的优缺点
- 32、构造方法能不能重写？能不能重载？
- 33、什么是红黑树
- 34、什么是逃逸分析？
- 35、栈帧里面包含哪些东西？
- 36、Tomcat是怎么打破双亲委派机制的呢？
- 37、WeakHashMap 是怎么工作的？
- 38、java 中操作字符串都有哪些类？它们之间有什么区别？
- 39、什么是JVM？java虚拟机包括什么？
- 40、Java 的引用有哪些类型？

### 3. JAVA面试题3

- 1、什么是ThreadPoolExecutor？

  ThreadPoolExecutor就是线程池
  ThreadPoolExecutor其实也是JAVA的一个类，我们一般通过Executors工厂类的方法，通过传入不同的参数，就可以构造出适用于不同应用场景下的ThreadPoolExecutor（线程池）
  构造参数图：
  构造参数参数介绍：
  corePoolSize 核心线程数量
  maximumPoolSize 最大线程数量
  keepAliveTime 线程保持时间，N个时间单位
  unit 时间单位（比如秒，分）
  workQueue 阻塞队列
  threadFactory 线程工厂
  handler 线程池拒绝策略
  

- 2、invokedynamic 指令是干什么的？

  Java 7 开始，新引入的字节码指令，可以实现一些动态类型语言的功能。Java 8 的 Lambda 表达式就是通过 invokedynamic 指令实现，使用方法句柄实现。
  

- 3、synchronized、volatile、CAS 比较

  1、 synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。
  2、 volatile 提供多线程共享变量可见性和禁止指令重排序优化。
  3、 CAS 是基于冲突检测的乐观锁（非阻塞）
  4、Iterator 怎么使用？有什么特点？
  Iterator 使用代码如下：
  List<String> list = new ArrayList<>();
  Iterator<String> it = list、iterator();
  while(it、hasNext()){
    String obj = it、next();
    System、out、println(obj);
  }
  Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。
  

- 5、被引用的对象就一定能存活吗？

  不一定，看 Reference 类型，弱引用在 GC 时会被回收，软引用在内存不足的时候，即 OOM 前会被回收，但如果没有在 Reference Chain 中的对象就一定会被回收。
  

- 6、列出一些你常见的运行时异常？

  1、 ArithmeticException（算术异常）
  2、 ClassCastException （类转换异常）
  3、 IllegalArgumentException （非法参数异常）
  4、 IndexOutOfBoundsException （下标越界异常）
  5、 NullPointerException （空指针异常）
  6、 SecurityException （安全异常）
  

- 7、Servlet生命周期内调用的方法过程？

  1、 Init()
  2、 Service()
  3、 doGet或者doPost
  4、 destroy
  

- 8、阐述静态变量和实例变量的区别。

  静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。
  补充：在Java开发中，上下文类和工具类中通常会有大量的静态成员。
  

- 9、类加载器双亲委派模型机制？

  基本定义：
  双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器没有找到所需的类时，子加载器才会尝试去加载该类。
  双亲委派机制:
  1、 当 AppClassLoader 加载一个 class 时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器 ExtClassLoader 去完成。
  2、 当 ExtClassLoader 加载一个 class 时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给 BootStrapClassLoader 去完成。
  3、 如果 BootStrapClassLoader 加载失败，会使用 ExtClassLoader 来尝试加载；
  4、 若 ExtClassLoader 也加载失败，则会使用 AppClassLoader 来加载，如果 AppClassLoader 也加载失败，则会报出异常 ClassNotFoundException。
  如下图所示：
  双亲委派作用：
  1、 通过带有优先级的层级关可以避免类的重复加载；
  2、 保证 Java 程序安全稳定运行，Java 核心 API 定义类型不会被随意替换。
  

- 10、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？

  都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。
  

- 11、老年代
- 12、如何停止一个正在运行的线程？
- 13、常用JVM基本配置参数
- 14、线程池都有哪些状态？
- 15、怎么确保一个集合不能被修改？
- 16、怎么检测一个线程是否拥有锁？
- 17、启动一个线程是调用run()还是start()方法？
- 18、React组件通信如何实现?
- 19、Java 中 WeakReference 与 SoftReference的区别？
- 20、常用并发列队的介绍：
- 21、什么是数据结构？
- 22、遇到过堆外内存溢出吗？
- 23、会话跟踪技术有那些？
- 24、抽象类和接口的区别?
- 25、Java中用到的线程调度算法是什么？
- 26、如何使session失效
- 27、存储过程与函数的区别
- 28、Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？
- 29、用Java写一个折半查找。
- 30、对象都是优先分配在年轻代上的吗？
- 31、本地方法区(线程私有)
- 32、单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！”
- 33、JVM 有哪些运行时内存区域？
- 34、为什么Thread类的sleep()和yield ()方法是静态的？
- 35、如何用Java代码列出一个目录下所有的文件？
- 36、Java中notify 和 notifyAll有什么区别？
- 37、为什么使用Executor框架？
- 38、如何判断两个类是否相等？
- 39、虚拟DOM实现原理?
- 40、a = a + b 与 a += b 的区别

### 4. JAVA面试题4

- 1、如何判断一个对象是否存活

  判断一个对象是否存活有两种方法：
  1、 引用计数法
  所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收、
  引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，对象 B 又引用者对象 A，那么此时 A、B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。
  2、 可达性算法（引用链法）
  该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。
  在 Java 中可以作为 GC Roots 的对象有以下几种：
  1、 虚拟机栈中引用的对象
  2、 方法区类静态属性引用的对象
  3、 方法区常量池引用的对象
  4、 本地方法栈JNI引用的对象
  虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记、
  如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法或者已被虚拟机调用过，那么就认为是没必要的。 如果该对象有必要执行 finalize() 方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize() 线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize() 执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除” 即将回收” 集合，等待回收。
  

- 2、Int与integer的区别

  Integer是int的包装类型。
  Int的默认值是0，integer的默认值是null
  

- 3、Servlet的生命周期？

  1、 加载：判断servlet实例是否存在，如果不存在，就加载serlvet
  2、 实例化：
  3、 初始化
  4、服务
  5、销毁
  

- 4、怎么唤醒一个阻塞的线程

  如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。
  

- 5、虚拟DOM的优劣如何?

  优点:
  1、 保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限
  2、 无需手动操作DOM: 虚拟DOM的diff和patch都是在一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率
  3、 跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等
  缺点:
  无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化,比如VScode采用直接手动操作DOM的方式进行极端的性能优化
  

- 6、双亲委派模型是什么？

  类加载器具有等级制度但非继承关系，以组合的方式复用父加载器的功能。双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应该有自己的父加载器。
  一个类加载器收到了类加载请求，它不会自己去尝试加载，而将该请求委派给父加载器，每层的类加载器都是如此，因此所有加载请求最终都应该传送到启动类加载器，只有当父加载器反馈无法完成请求时，子加载器才会尝试。
  类跟随它的加载器一起具备了有优先级的层次关系，确保某个类在各个类加载器环境中都是同一个，保证程序的稳定性。
  

- 7、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？
- 8、如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？

  1、 不会，在下一个垃圾回调周期中，这个对象将是被可回收的。
  2、 也就是说并不会立即被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。
  

- 9、JVM 出现 fullGC 很频繁，怎么去线上排查问题

  这题就依据full GC的触发条件来做：
  1、 如果有perm gen的话(jdk1.8就没了)，要给perm gen分配空间，但没有足够的空间时，会触发full gc。
  2、 所以看看是不是perm gen区的值设置得太小了。
  3、 System.gc()方法的调用
  4、 这个一般没人去调用吧~~~
  5、 当统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间，则会触发full gc(这就可以从多个角度上看了)
  6、 是不是频繁创建了大对象(也有可能eden区设置过小)(大对象直接分配在老年代中，导致老年代空间不足--->从而频繁gc)
  7、 是不是老年代的空间设置过小了(Minor GC几个对象就大于老年代的剩余空间了)
  

- 10、JVM 内存区域

  JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。
  线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。
  线程共享区域随虚拟机的启动/关闭而创建/销毁。
  直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于Channel与 Buffer的IO方式, 它可以使用Native函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。
  

- 11、原型模式的使用方式
- 12、简述一下你了解的设计模式。
- 13、Java中有几种类型的流？
- 14、Try.catch.finally是必须要存在的吗？
- 15、你熟悉哪些垃圾收集算法？
- 16、为什么HashTable是线程安全的？
- 17、finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？
- 18、用最有效率的方法计算2乘以8？
- 19、多线程应用场景
- 20、List 和 Set 的区别
- 21、实现可见性的方法有哪些？
- 22、堆
- 23、什么是JDK?什么是JRE？
- 24、在 Java 中，对象什么时候可以被垃圾回收？
- 25、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?
- 26、如何将字符串反转？
- 27、如何通过反射获取和设置对象私有字段的值？
- 28、并发队列的常用方法
- 29、Set接口有什么特点
- 30、说说你知道的几种主要的JVM参数
- 31、“a==b”和”a.equals(b)”有什么区别？
- 32、什么是并发队列：
- 33、Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？
- 34、Linux环境下如何查找哪个线程使用CPU最长
- 35、并发编程三要素？
- 36、四种线程池的创建：
- 37、说说CMS垃圾收集器的工作原理
- 38、请解释如何配置Tomcat来使用IIS和NTLM ?
- 39、线程的sleep()方法和yield()方法有什么区别？
- 40、JAVA弱引用
- 41、方法区

### 5. JAVA面试题5

- 1、Parallel Old 收集器（多线程标记整理算法）

  Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6才开始提供。
  在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量， Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器， 如果系统对吞吐量要求比较高，可以优先考虑新生代Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。
  

- 2、对象分配内存是否线程安全？

  对象创建十分频繁，即使修改一个指针的位置在并发下也不是线程安全的，可能正给对象 A 分配内存，指针还没来得及修改，对象 B 又使用了指针来分配内存。
  解决方法：① CAS 加失败重试保证更新原子性。② 把内存分配按线程划分在不同空间，即每个线程在 Java 堆中预先分配一小块内存，叫做本地线程分配缓冲 TLAB，哪个线程要分配内存就在对应的 TLAB 分配，TLAB 用完了再进行同步。
  

- 3、当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？

  如果其他方法没有synchronized的话，其他线程是可以进入的。
  所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。
  

- 4、Serial 与 Parallel GC 之间的不同之处？

  Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而parallel 收集器使用多个 GC 线程来执行。
  

- 5、为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？

  因为Java所有类的都继承了Object，Java想让任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。
  有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。
  

- 6、redux异步中间件之间的优劣?

  redux-thunk优点:
  1、 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  2、 使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简单
  redux-thunk缺陷:
  1、 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
  2、 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
  3、 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:
  1、 异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中
  2、 action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满 “黑魔法” thunk function
  3、 异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过 try/catch 语法直接捕获处理
  4、 功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者无须封装或者简单封装即可使用
  5、 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
  6、 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:
  1、 额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
  2、 体积庞大: 体积略大,代码近2000行，min版25KB左右
  3、 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
  4、 ts支持不友好: yield无法返回TS类型
  redux-observable优点:
  1、 功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你能想到的异步处理
  2、 背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而且随着rxjs的升级redux-observable也会变得更强大
  redux-observable缺陷:
  1、 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  2、 社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步流中间件这个层面redux-saga仍处于领导地位
  关于redux-saga与redux-observable的详细比较可见此链接
  

- 7、类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？

  双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。
  1、 假设有一个开发者自己编写了一个名为java.lang.Object的类，想借此欺骗JVM。现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类。
  2、 然而幸运的是，双亲委托模型不会让他成功。因为JVM会优先在Bootstrap ClassLoader的路径下找到java.lang.Object类，并载入它
  Java的类加载是否一定遵循双亲委托模型？
  1、 在实际开发中，我们可以通过自定义ClassLoader，并重写父类的loadClass方法，来打破这一机制。
  2、 SPI就是打破了双亲委托机制的(SPI：服务提供发现)。
  

- 8、Hibernate中Session的load和get方法的区别是什么？

  如果没有找到符合条件的记录，get方法返回null，load方法抛出异常。
  get方法直接返回实体类对象，load方法返回实体类对象的代理。
  在Hibernate 3之前，get方法只在一级缓存中进行数据查找，如果没有找到对应的数据则越过二级缓存，直接发出SQL语句完成数据读取；load方法则可以从二级缓存中获取数据；从Hibernate 3开始，get方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。
  

- 9、说一下堆内存中对象的分配的基本策略

  eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区->Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。另外，大对象和长期存活的对象会直接进入老年代。
  

- 10、Java 中如何将字符串转换为整数？

  String s="123";
  int i;
  第一种方法：i=Integer.parseInt(s);
  第二种方法：i=Integer.valueOf(s).intValue();
  

- 11、Tcp协议的特点
- 12、如何在两个线程间共享数据？
- 13、java中有没有指针？
- 14、什么是多线程
- 15、a.hashCode() 有什么用？与 a.equals(b) 有什么关系？
- 16、堆和栈的区别
- 17、JDBC能否处理Blob和Clob？
- 18、什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？
- 19、简述一下面向对象的”六原则一法则”。
- 20、MinorGC，MajorGC、FullGC都什么时候发生？
- 21、JVM 运行时内存
- 22、如何自定义一个异常
- 23、synchronized、volatile、CAS比较
- 24、JVM有哪些内存区域？(JVM的内存布局是什么？)
- 25、强引用、软引用、弱引用、虚引用是什么？
- 26、Java 中垃圾收集的方法有哪些
- 27、CMS都有哪些问题？
- 28、redux中如何进行异步操作?
- 29、什么是多线程的上下文切换
- 30、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？
- 31、谈谈你知道的垃圾回收算法
- 32、重载与重写
- 33、Java 线程数过多会造成什么异常？
- 34、Java 中 ++ 操作符是线程安全的吗？
- 35、三种代理的区别
- 36、在不使用 StringBuffer 的前提下，怎么反转一个字符串？
- 37、什么叫线程安全？servlet 是线程安全吗?
- 38、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？
- 39、如果你提交任务时，线程池队列已满，这时会发生什么
- 40、什么情况下会发生栈溢出？
- 41、死锁与活锁的区别，死锁与饥饿的区别？

### 6. JAVA面试题6

- 1、讲讲什么情况下会出现内存溢出，内存泄漏？

  解决这个内存泄漏问题也很简单，将set设置为null，那就可以避免上述内存泄漏问题了。其他内存泄漏得一步一步分析了。
  内存溢出的原因：
  1、 内存泄露导致堆栈内存不断增大，从而引发内存溢出。
  2、 大量的jar，class文件加载，装载类的空间不够，溢出
  3、 操作大量的对象导致堆内存空间已经用满了，溢出
  4、 nio直接操作内存，内存过大导致溢出
  解决：
  1、 查看程序是否存在内存泄漏的问题
  2、 设置参数加大空间
  3、 代码中是否存在死循环或循环产生过多重复的对象实体、
  4、 查看是否使用了nio直接操作内存。
  

- 2、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？

  悲观锁：
  总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。
  乐观锁：
  顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。
  

- 3、线程与进程的区别？

  进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。
  一个程序至少有一个进程,一个进程至少有一个线程。
  

- 4、Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？

  瞬时态的实例可以通过调用save()、persist()或者saveOrUpdate()方法变成持久态；游离态的实例可以通过调用 update()、saveOrUpdate()、lock()或者replicate()变成持久态。save()和persist()将会引发SQL的INSERT语句，而update()或merge()会引发UPDATE语句。save()和update()的区别在于一个是将瞬时态对象变成持久态，一个是将游离态对象变为持久态。merge()方法可以完成save()和update()方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。
  对于persist()方法，
  persist()方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到flush的时间；
  persist()方法保证当它在一个事务外部被调用的时候并不触发一个INSERT语句，当需要封装一个长会话流程的时候，persist()方法是很有必要的；
  save()方法不保证第②条，它要返回标识符，所以它会立即执行INSERT语句，不管是在事务内部还是外部。至于lock()方法和update()方法的区别，update()方法是把一个已经更改过的脱管状态的对象变成持久状态；lock()方法是把一个没有更改过的脱管状态的对象变成持久状态。
  

- 5、用代码演示三种代理
- 6、stackoverflow错误，permgen space错误

  stackoverflow错误主要出现：
  在虚拟机栈中(线程请求的栈深度大于虚拟机栈锁允许的最大深度)
  permgen space错误(针对jdk之前1.7版本)：
  1、 大量加载class文件
  2、 常量池内存溢出
  

- 7、分代收集算法

  当前主流 VM 垃圾收集都采用”分代收集” (Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如 JVM 中的新生代、老年代、永久代， 这样就可以根据各年代特点分别采用最适当的 GC 算法
  

- 8、同步方法和同步块，哪个是更好的选择？

  同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。
  同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。
  请知道一条原则：同步的范围越小越好。
  

- 9、Java 中的编译期常量是什么？使用它又什么风险？

  公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。
  

- 10、Java死锁以及如何避免？

  Java中的死锁是一种编程情况，其中两个或多个线程被永久阻塞，Java死锁情况出现至少两个线程和两个或更多资源。
  Java发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。
  

- 11、为什么 Thread 类的 sleep()和 yield ()方法是静态的？
- 12、Java都有那些开发平台？
- 13、Java 中能创建 volatile 数组吗？
- 14、线程 B 怎么知道线程 A 修改了变量
- 15、GC日志的real、user、sys是什么意思？
- 16、你说你做过JVM参数调优和参数配置，请问如何查看JVM系统默认值
- 17、什么是ORM？
- 18、串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？
- 19、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用
- 20、Java对象创建过程
- 21、java 中 IO 流分为几种？
- 22、在Java中Executor和Executors的区别？
- 23、说说 JVM 如何执行 class 中的字节码。
- 24、构造方法有哪些特性？
- 25、final不可变对象，它对写并发应用有什么帮助？
- 26、Java中操作字符串使用哪个类？
- 27、在 Java 程序中怎么保证多线程的运行安全？
- 28、JIT是什么？
- 29、类加载有几个过程？
- 30、JSP中的静态包含和动态包含有什么区别？
- 31、线程池的优点？
- 32、Java 中，怎么在格式化的日期中显示时区？
- 33、什么是原型模式
- 34、Javascript中常用的事件有哪些？
- 35、32 位和 64 位的 JVM，int 类型变量的长度是多数？
- 36、常用的并发工具类有哪些？
- 37、什么是不可变对象，它对写并发应用有什么帮助？
- 38、单例模式的线程安全性
- 39、什么是阻塞式方法？
- 40、调优工具
- 41、创建线程的三种方式的对比？

### 7. JAVA面试题7

- 1、String 属于基础的数据类型吗？

  String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。
  

- 2、如何实现对象克隆？
- 3、Java最顶级的父类是哪个？

  Object
  

- 4、如何通过反射创建对象？

  1、 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance()
  2、 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”);
  

- 5、Java 中堆和栈有什么区别？

  JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。
  

- 6、volatile 能使得一个非原子操作变成原子操作吗？

  1、 关键字volatile的主要作用是使变量在多个线程间可见，但无法保证原子性，对于多个线程访问同一个实例变量需要加锁进行同步。
  2、 虽然volatile只能保证可见性不能保证原子性，但用volatile修饰long和double可以保证其操作原子性。
  所以从Oracle Java Spec里面可以看到：
  1、 对于64位的long和double，如果没有被volatile修饰，那么对其操作可以不是原子的。在操作的时候，可以分成两步，每次对32位操作。
  2、 如果使用volatile修饰long和double，那么其读写都是原子操作
  3、 对于64位的引用地址的读写，都是原子操作
  4、 在实现JVM时，可以自由选择是否把读写long和double作为原子操作
  5、 推荐JVM实现为原子操作
  

- 7、为什么选择使用框架而不是原生?

  框架的好处:
  1、 组件化: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。
  2、 天然分层: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。
  3、 生态: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案。
  4、 开发效率: 现代前端框架都默认自动更新DOM,而非我们手动操作,解放了开发者的手动DOM成本,提高开发效率,从根本上解决了UI 与状态同步问题.
  

- 8、你能写出一个正则表达式来判断一个字符串是否是一个数字吗？
- 9、运行时栈帧包含哪些结构？

  1、 局部变量表
  2、 操作数栈
  3、 动态连接
  4、 返回地址
  5、 附加信息
  

- 10、什么是Java程序的主类？应用程序和小程序的主类有何不同？

  一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main（）方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。
  

- 11、什么是模板方法模式？
- 12、Java 中应该使用什么数据类型来代表价格？
- 13、本地方法栈
- 14、静态方法和实例方法有何不同？
- 15、JAVA虚引用
- 16、Java应用程序与小程序之间有那些差别？
- 17、sleep方法和wait方法有什么区别?
- 18、普通类与抽象类有什么区别？
- 19、现实生活中的模板方法
- 20、一个线程运行时发生异常会怎样？
- 21、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？
- 22、Java 中怎么创建 ByteBuffer？
- 23、Json是什么？
- 24、JVM调优命令有哪些？
- 25、集合的特点
- 26、Java内存模型
- 27、什么是线程同步和线程互斥，有哪几种实现方式？
- 28、Java 中，throw 和 throws 有什么区别
- 29、运行时常量池溢出的原因？
- 30、假如生产环境CPU占用过高，请谈谈你的分析思路和定位。
- 31、Java的双亲委托机制是什么？
- 32、什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？
- 33、char 型变量中能不能存贮一个中文汉字，为什么？
- 34、84.Map有什么特点
- 35、监听器有哪些作用和用法？
- 36、final 在 java 中有什么作用？
- 37、Minor GC与Full GC分别在什么时候发生？
- 38、Minor Gc和Full GC 有什么不同呢？
- 39、Java 中，怎样才能打印出数组中的重复元素？
- 40、一个java类中包含那些内容？

### 8. JAVA面试题8

- 1、volatile 关键字的作用

  1、 对于可见性，Java 提供了 volatile 关键字来保证可见性和禁止指令重排。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile修饰时，它会保证修改的值会立即被更新到主内存中，当有其他线程需要读取时，它会去内存中读取新值。
  2、 从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 AtomicInteger。
  3、 volatile 常用于多线程环境下的单次操作(单次读或者单次写)。
  

- 2、Java 中用到的线程调度算法是什么？

  计算机通常只有一个 CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU 的使用权才能执行指令。所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。在运行池中，会有多个处于就绪状态的线程在等待 CPU，JAVA 虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配 CPU 的使用权。（Java是由JVM中的线程计数器来实现线程调度）
  有两种调度模型：
  分时调度模型和抢占式调度模型。
  1、 分时调度模型是指让所有的线程轮流获得 cpu 的使用权，并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。
  2、 Java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。
  

- 3、简单描述一下（分代）垃圾回收的过程

  分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。
  新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：
  当年轻代中的Eden区分配满的时候，就会触发年轻代的GC（Minor GC）。具体过程如下：
  1、 在Eden区执行了 第一次GC之后，存活的对象会被移动到其中一个Survivor分区（以下简称from）
  2、 Eden区再次GC，这时会采用复制算法，将Eden和from区一起清理。存活的对象会被复制到to区。接下来，只需要清空from区就可以了
  

- 4、什么是可重入锁（ReentrantLock）？
- 5、线程池有什么优点？

  1、 降低资源消耗：重用存在的线程，减少对象创建销毁的开销。
  2、 提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
  3、 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
  4、 附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。
  

- 6、你有哪些手段来排查 OOM 的问题？

  1、 增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录
  2、 同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域
  3、 使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用
  

- 7、什么是线程异步？什么是线程同步？

  1、 线程同步：同时只有一条线程执行一个任务
  2、 线程异步：同时有多条线程可以执行执行任务
  

- 8、Java 中，受检查异常 和 不受检查异常的区别？

  受检查异常编译器在编译期间检查。对于这种异常，方法强制处理或者通过 throws 子句声明。其中一种情况是 Exception 的子类但不是 RuntimeException 的子类。非受检查是 RuntimeException 的子类，在编译阶段不受编译器的检查。
  

- 9、OOP 中的 组合、聚合和关联有什么区别？

  如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。
  

- 10、Java网络编程有几种？

  TCP编程
  UDP编程
  

- 11、怎么在JDBC内调用一个存储过程
- 12、Collection接口下有那些集合框架？
- 13、MinorGC、MajorGC、FullGC 什么时候发生？
- 14、ReadWriteLock是什么
- 15、自动装箱与拆箱
- 16、设计模式的六大原则
- 17、给我一个符合开闭原则的设计模式的例子？
- 18、ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？
- 19、如何避免线程死锁
- 20、类加载是什么？
- 21、说说线程栈
- 22、url是什么？由哪些部分组成？
- 23、comparable 和 comparator的区别？
- 24、在Java中定义一个不做事且没有参数的构造方法的作用
- 25、CopyOnWriteArrayList 的设计思想?
- 26、能够找到 Reference Chain 的对象，就一定会存活么？
- 27、什么是竞争条件？你怎样发现和解决竞争？
- 28、为什么代码会重排序？
- 29、谈谈双亲委派模型
- 30、谈谈 JVM 中的常量池
- 31、JVM垃圾回收时候如何确定垃圾？什么是GC Roots？
- 32、Session加载实体对象的过程。
- 33、32 位和 64 位的 JVM，int 类型变量的长度是多数？
- 34、为什么 ArrayList 的 elementData 加上 transient 修饰？
- 35、JAVA软引用
- 36、Parallel Scavenge 收集器（多线程复制算法、高效）
- 37、Java 虚拟机栈的作用？
- 38、CAS的问题
- 39、什么情况会造成元空间溢出？
- 40、final、finalize 和 finally 的不同之处？
- 41、Sql优化有那些方法？

### 9. JAVA面试题9

- 1、日期和时间：

  1、 如何取得年月日、小时分钟秒？
  2、 如何取得从1970年1月1日0时0分0秒到现在的毫秒数？
  3、 如何取得某月的最后一天？
  4、 如何格式化日期？
  

- 2、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？

  XML文档定义分为DTD和Schema两种形式，二者都是对XML语法的约束，其本质区别在于Schema本身也是一个XML文件，可以被XML解析器解析，而且可以为XML承载的数据定义类型，约束能力较之DTD更强大。对XML的解析主要有DOM（文档对象模型，Document Object Model）、SAX（Simple API for XML）和StAX（Java 6中引入的新的解析XML的方式，Streaming API for XML），其中DOM处理大型文件时其性能下降的非常厉害，这个问题是由DOM树结构占用的内存较多造成的，而且DOM解析方式必须在解析文件之前把整个文档装入内存，适合对XML的随机访问（典型的用空间换取时间的策略）；SAX是事件驱动型的XML解析方式，它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理XML文件，适合对XML的顺序访问；顾名思义，StAX把重点放在流上，实际上StAX与其他解析方式的本质区别就在于应用程序能够把XML作为一个事件流来处理。将XML作为一组事件来处理的想法并不新颖（SAX就是这样做的），但不同之处在于StAX允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。
  

- 3、依赖注入和工程模式之间有什么不同？

  虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工程模式更清晰。通过依赖注入，你的类就是 POJO，它只知道依赖而不关心它们怎么获取。使用工厂模式，你的类需要通过工厂来获取依赖。因此，使用 DI 会比使用工厂模式更容易测试。
  

- 4、Java 堆的结构是什么样子的？什么是堆中的永久代（Perm Gen space）

  JVM 的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在 JVM 启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。
  堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些 对象回收掉之前，他们会一直占据堆内存空间。
  

- 5、如何修改tomcat的端口号？

  在tomcat根目录的conf文件夹内打开server.xml文件，修改Connector节点的port属性
  

- 6、Java有没有goto？

  goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）
  

- 7、Java 内存分配与回收策率以及 Minor GC 和 Major GC

  1、 对象优先在堆的 Eden 区分配
  2、 大对象直接进入老年代
  3、 长期存活的对象将直接进入老年代
  当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC。Minor GC 通常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高，回收速度比较快；Full GC/Major GC 发生在老年代，一般情况下，触发老年代 GC 的时候不会触发 Minor GC，但是通过配置，可以在 Full GC 之前进行一次 Minor GC 这样可以加快老年代的回收速度。
  

- 8、简述Hibernate常见优化策略。

  1、 制定合理的缓存策略（二级缓存、查询缓存）。
  2、 采用合理的Session管理机制。
  3、 尽量使用延迟加载特性。
  4、 设定合理的批处理参数。
  5、 如果可以，选用UUID作为主键生成器。
  6、 如果可以，选用乐观锁替代悲观锁。
  7、 在开发过程中, 开启hibernate.show_sql选项查看生成的SQL，从而了解底层的状况；开发完成后关闭此选项。
  8、 考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观的提升，但这些需要专业的DBA（数据库管理员）提供支持。
  

- 9、Statement与preparedStatement区别

  preparedStatement会预编译sql语句，能够提高批量的数据操作的执行效率，Statement执行slq的时候才进行编译
  Preparedstatement在第一次执行sql的时候，比较耗费资源。如果只对数据库进行一次操作，使用statement比较好。
  Statement会出现sql注入的问题，使用preparedstatment可以解决sql注入
  

- 10、什么是DAO模式？

  DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。
  

- 11、safepoint是什么？
- 12、什么是阻塞式方法？
- 13、解释什么是Jasper?
- 14、说一下 runnable 和 callable 有什么区别
- 15、抽象类可以使用final修饰吗？
- 16、双亲委派机制可以被违背吗？请举例说明。
- 17、如何让正在运行的线程暂停一段时间？
- 18、代理的分类
- 19、多线程的价值？
- 20、GC 是什么？为什么要有 GC？
- 21、什么是JDK？什么是JRE?
- 22、Final在java中的作用
- 23、请说明NAT协议的目的是什么?
- 24、抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？
- 25、那针对浮点型数据运算出现的误差的问题，你怎么解决？
- 26、Java中集合框架的有几个？
- 27、Java 中，DOM 和 SAX 解析器有什么不同？
- 28、java中是值传递引用传递？
- 29、如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？
- 30、final、finalize()、finally，作用
- 31、为什么HashMap中String、Integer这样的包装类适合作为K？
- 32、除了使用new创建对象之外，还可以用什么方法创建对象？
- 33、继承和组合之间有什么不同？
- 34、数组有没有length()方法？String有没有length()方法？
- 35、事务的使用场景在什么地方？
- 36、说一下堆和栈的区别
- 37、除了单例模式，你在生产环境中还用过什么设计模式？
- 38、什么是工厂模式
- 39、synchronized可重入的原理
- 40、双亲委派
- 41、说出 5 条 IO 的最佳实践(答案)

### 10. JAVA面试题10

- 1、什么是Web Service（Web服务）

  从表面上看，Web Service就是一个应用程序，它向外界暴露出一个能够通过Web进行调用的API。这就是说，你能够用编程的方法透明的调用这个应用程序，不需要了解它的任何细节，跟你使用的编程语言也没有关系。例如可以创建一个提供天气预报的Web Service，那么无论你用哪种编程语言开发的应用都可以通过调用它的API并传入城市信息来获得该城市的天气预报。之所以称之为Web Service，是因为它基于HTTP协议传输数据，这使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。
  

- 2、内部类与静态内部类的区别？

  静态内部类相对与外部类是独立存在的，在静态内部类中无法直接访问外部类中变量、方法。如果要访问的话，必须要new一个外部类的对象，使用new出来的对象来访问。但是可以直接访问静态的变量、调用静态的方法；
  普通内部类作为外部类一个成员而存在，在普通内部类中可以直接访问外部类属性，调用外部类的方法。
  如果外部类要访问内部类的属性或者调用内部类的方法，必须要创建一个内部类的对象，使用该对象访问属性或者调用方法。
  如果其他的类要访问普通内部类的属性或者调用普通内部类的方法，必须要在外部类中创建一个普通内部类的对象作为一个属性，外同类可以通过该属性调用普通内部类的方法或者访问普通内部类的属性
  如果其他的类要访问静态内部类的属性或者调用静态内部类的方法，直接创建一个静态内部类对象即可。
  

- 3、什么是代理模式

  通过代理控制对象的访问，可以在这个对象调用方法之前、调用方法之后去处理/添加新的功能。(也就是AO的P微实现)
  代理在原有代码乃至原业务流程都不修改的情况下，直接在业务流程中切入新代码，增加新功能，这也和Spring的（面向切面编程）很相似
  

- 4、32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？

  理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。
  

- 5、重排序实际执行的指令步骤

  ![87_5.png][87_5.png]
  1、 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
  2、 指令级并行的重排序。现代处理器采用了指令级并行技术（ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
  3、 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。
  这些重排序对于单线程没问题，但是多线程都可能会导致多线程程序出现内存可见性问题。
  

- 6、invokedynamic指令是干什么的？

  属于比较高级的题目。没看过虚拟机的一般是不知道的。所以如果你不太熟悉，不要气馁，加油！（小拳拳锤你胸口）。
  invokedynamic是Java7之后新加入的字节码指令，使用它可以实现一些动态类型语言的功能。我们使用的Lambda表达式，在字节码上就是invokedynamic指令实现的。它的功能有点类似反射，但它是使用方法句柄实现的，执行效率更高。
  

- 7、如何选择单例创建方式
- 8、Java集合的快速失败机制 “fail-fast”？

  是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。
  例如：假设存在两个线程（线程1、 线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。
  **原因：**迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。
  解决办法：
  1、 在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。
  2、 使用CopyOnWriteArrayList来替换ArrayList
  

- 9、如何实现字符串的反转及替换？
- 10、Spring开发中的工厂设计模式

  Spring IOC
  1、 看过Spring源码就知道，在Spring IOC容器创建bean的过程是使用了工厂设计模式
  2、 Spring中无论是通过xml配置还是通过配置类还是注解进行创建bean，大部分都是通过简单工厂来进行创建的。
  3、 当容器拿到了beanName和class类型后，动态的通过反射创建具体的某个对象，最后将创建的对象放到Map中。
  为什么Spring IOC要使用工厂设计模式创建Bean呢
  1、 在实际开发中，如果我们A对象调用B，B调用C，C调用D的话我们程序的耦合性就会变高。（耦合大致分为类与类之间的依赖，方法与方法之间的依赖。）
  2、 在很久以前的三层架构编程时，都是控制层调用业务层，业务层调用数据访问层时，都是是直接new对象，耦合性大大提升，代码重复量很高，对象满天飞
  3、 为了避免这种情况，Spring使用工厂模式编程，写一个工厂，由工厂创建Bean，以后我们如果要对象就直接管工厂要就可以，剩下的事情不归我们管了。Spring IOC容器的工厂中有个静态的Map集合，是为了让工厂符合单例设计模式，即每个对象只生产一次，生产出对象后就存入到Map集合中，保证了实例不会重复影响程序效率。
  

- 11、JRE、JDK、JVM 及 JIT 之间有什么不同？
- 12、HTTP的状态码
- 13、线程同步的方法
- 14、类ExampleA继承Exception，类ExampleB继承ExampleA。
- 15、HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？
- 16、volatile关键字的原理是什么？干什么用的？
- 17、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。
- 18、线程的状态流转图
- 19、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？
- 20、Java的io流分为哪两种？
- 21、如何解析json对象？
- 22、synchronized 和 ReentrantLock 区别是什么？
- 23、使用Log4j对程序有影响吗？
- 24、在新生代-复制算法
- 25、对象是怎么从年轻代进入老年代的？
- 26、int和Integer有什么区别？
- 27、Java 中的内存映射缓存区是什么？
- 28、你能解释一下里氏替换原则吗?
- 29、类加载的过程是什么？
- 30、说出几点 Java 中使用 Collections 的最佳实践
- 31、程序计数器为什么是私有的?
- 32、为什么需要双亲委派模式？
- 33、HashSet与HashMap的区别
- 34、用 wait-notify 写一段代码来解决生产者-消费者问题？
- 35、谈谈你知道的垃圾收集器
- 36、GC垃圾回收算法与垃圾收集器的关系？
- 37、什么是B/S架构？什么是C/S架构
- 38、什么是事务？事务有那些特点？
- 39、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？
- 40、什么是happen-before原则？

## 第2章 JVM

### 1. 面试题1

- 1、JAVA弱引用

  弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。
  

- 2、什么是堆

  存放对象实例，所有的对象和数组都要在堆上分配。 是 JVM 所管理的内存中最大的一块区域。
  

- 3、什么是程序计数器

  当前线程所执行的行号指示器。是 JVM 内存区域最小的一块区域。执行字节码工作时就是利用程序计数器来选取下一条需要执行的字节码指令。
  

- 4、各种回收器，各自优缺点，重点CMS、G1

  图来源于《深入理解Java虚拟机：JVM高级特效与最佳实现》，图中两个收集器之间有连线，说明它们可以配合使用.
  1、 Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，但可能会产生较长的停顿，只使用一个线程去回收。
  2、 ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。
  3、 Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。
  4、 Parallel Old收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程“标记－整理”算法
  5、 CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担。CMS无法处理浮动垃圾。CMS的“标记-清除”算法，会导致大量空间碎片的产生。
  6、 G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器、以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征。
  

- 5、可以描述一下 class 文件的结构吗？

  1、 Class 文件包含了 Java 虚拟机的指令集、符号表、辅助信息的字节码(Byte Code)，是实现跨操作系统和语言无关性的基石之一。
  2、 一个 Class 文件定义了一个类或接口的信息，是以 8 个字节为单位，没有分隔符，按顺序紧凑排在一起的二进制流。
  3、 用 "无符号数" 和 "表" 组成的伪结构来存储数据。
  4、 无符号数：基本数据类型，用来描述数字、索引引用、数量值、字符串值，如u1、u2 分别表示 1 个字节、2 个字节
  10、 表：无符号数和其他表组成，命名一般以 "_info" 结尾
  组成部分
  1、 魔数 Magic Number
  Class 文件头 4 个字节，0xCAFEBABE
  作用是确定该文件是 Class 文件
  2、 版本号
  4 个字节，前 2 个是次版本号 Minor Version，后 2 个主版本号 Major Version
  从 45 (JDK1.0) 开始，如 0x00000032 转十进制就是 50，代表 JDK 6
  低版本的虚拟机跑不了高版本的 Class 文件
  3、 常量池
  4、 访问标志
  5、 类索引、父类索引、接口索引集合
  6、 字段表(field_info)集合
  7、 方法表(method_info)集合
  8、 属性表(attribute_info)集合
  

- 6、类的实例化顺序

  比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序
  先静态、先父后子。
  先静态：父静态 > 子静态
  优先级：父类 > 子类 静态代码块 > 非静态代码块 > 构造函数
  一个类的实例化过程：
  1、 父类中的static代码块，当前类的static
  2、 顺序执行父类的普通代码块
  3、 父类的构造函数
  4、 子类普通代码块
  5、 子类（当前类）的构造函数，按顺序执行。
  6、 子类方法的执行，
  

- 7、怎么打出线程栈信息？

  输入jps，获得进程号。top -Hp pid 获取本进程中所有线程的CPU耗时性能 jstack pid命令查看当前java进程的堆栈状态 或者 jstack -l > /tmp/output.txt 把堆栈信息打到一个txt文件。可以使用fastthread 堆栈定位（fastthread.io）
  

- 8、程序计数器是什么？

  程序计数器是一块较小的内存空间，可以看作当前线程所执行字节码的行号指示器。字节码解释器工作时通过改变计数器的值选取下一条执行指令。分支、循环、跳转、线程恢复等功能都需要依赖计数器完成。是唯一在虚拟机规范中没有规定内存溢出情况的区域。
  如果线程正在执行 Java 方法，计数器记录正在执行的虚拟机字节码指令地址。如果是本地方法，计数器值为 Undefined。
  

- 9、JVM的引用类型有哪些？

  引用内型：
  强引用：
  当内存不足的时候，JVM宁可出现OutOfMemoryError错误停止，也需要进行保存，并且不会将此空间回收。在引用期间和栈有联系就无法被回收
  软引用：
  当内存不足的时候，进行对象的回收处理，往往用于高速缓存中；mybatis就是其中
  弱引用：
  不管内存是否紧张，只要有垃圾了就立即回收
  幽灵引用：
  和没有引用是一样的
  

- 10、Serial 与 Parallel GC 之间的不同之处？

  Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而parallel 收集器使用多个 GC 线程来执行。
  

- 11、JVM新生代中为什么要分为Eden和Survivor？
- 12、老年代
- 13、常用JVM基本配置参数
- 14、如何判断一个类是无用的类?
- 15、什么是 Class 文件？ Class 文件主要的信息结构有哪些？
- 16、Java 堆的结构是什么样子的？什么是堆中的永久代（Perm Gen space）
- 17、如何判断对象可以被回收
- 18、JVM有哪些内存区域？(JVM的内存布局是什么？)
- 19、说说CMS垃圾收集器的工作原理
- 20、类加载是什么？
- 21、JAVA虚引用
- 22、对于JDK自带的监控和性能分析工具用过哪些？
- 23、什么是指令重排序？
- 24、有哪些类加载器？
- 25、堆和栈的区别
- 26、Java会存在内存泄漏吗？请简单描述。
- 27、生产环境服务器变慢，如何诊断处理？
- 28、什么是逃逸分析？
- 29、java中会存在内存泄漏吗，请简单描述。
- 30、程序计数器为什么是私有的?

### 2. 面试题2

- 1、GC Roots 有哪些？

  1、 GC Roots 是一组必须活跃的引用。用通俗的话来说，就是程序接下来通过直接引用或者间接引用，能够访问到的潜在被使用的对象。
  2、 GC Roots 包括：Java 线程中，当前所有正在被调用的方法的引用类型参数、局部变量、临时值等。也就是与我们栈帧相关的各种引用。所有当前被加载的 Java 类。Java 类的引用类型静态变量。运行时常量池里的引用类型常量（String 或 Class 类型）。JVM 内部数据结构的一些引用，比如 sun.jvm.hotspot.memory.Universe 类。用于同步的监控对象，比如调用了对象的 wait() 方法。JNI handles，包括 global handles 和 local handles。
  3、 这些 GC Roots 大体可以分为三大类，下面这种说法更加好记一些：活动线程相关的各种引用。类的静态变量的引用。JNI 引用。
  4、 有两个注意点：我们这里说的是活跃的引用，而不是对象，对象是不能作为 GC Roots 的。GC 过程是找出所有活对象，并把其余空间认定为“无用”；而不是找出所有死掉的对象，并回收它们占用的空间。所以，哪怕 JVM 的堆非常的大，基于 tracing 的 GC 方式，回收速度也会非常快。
  

- 2、说说Java 垃圾回收机制

  在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。
  

- 3、介绍一下类文件结构吧！

  魔数: 确定这个文件是否为一个能被虚拟机接收的 Class 文件。Class 文件版本 ：Class 文件的版本号，保证编译正常执行。常量池 ：常量池主要存放两大常量：字面量和符号引用。访问标志 ：标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。当前类索引,父类索引 ：类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。接口索引集合 ：接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按implents(如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。字段表集合 ：描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。方法表集合 ：类中的方法。属性表集合 ：在 Class 文件，字段表，方法表中都可以携带自己的属性表集合。
  

- 4、分代收集算法

  当前主流 VM 垃圾收集都采用”分代收集” (Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如 JVM 中的新生代、老年代、永久代， 这样就可以根据各年代特点分别采用最适当的 GC 算法
  

- 5、堆溢出的原因？

  堆用于存储对象实例，只要不断创建对象并保证 GC Roots 到对象有可达路径避免垃圾回收，随着对象数量的增加，总容量触及最大堆容量后就会 OOM，例如在 while 死循环中一直 new 创建实例。
  堆 OOM 是实际应用中最常见的 OOM，处理方法是通过内存映像分析工具对 Dump 出的堆转储快照分析，确认内存中导致 OOM 的对象是否必要，分清到底是内存泄漏还是内存溢出。
  如果是内存泄漏，通过工具查看泄漏对象到 GC Roots 的引用链，找到泄露对象是通过怎样的引用路径、与哪些 GC Roots 关联才导致无法回收，一般可以准确定位到产生内存泄漏代码的具***置。
  如果不是内存泄漏，即内存中对象都必须存活，应当检查 JVM 堆参数，与机器内存相比是否还有向上调整的空间。再从代码检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。
  

- 6、Tomcat是怎么打破双亲委派机制的呢？

  是通过重写ClassLoader#loadClass和ClassLoader#findClass 实现的。可以看图中的WebAppClassLoader，它加载自己目录下的.class文件，并不会传递给父类的加载器。但是，它却可以使用 SharedClassLoader 所加载的类，实现了共享和分离的功能。
  

- 7、你知道哪些垃圾收集器？

  序列号
  最基础的收集器，使用复制算法、单线程工作，只用一个处理器或一条线程完成垃圾收集，进行垃圾收集时必须暂停其他所有工作线程。
  Serial 是虚拟机在客户端模式的默认新生代收集器，简单高效，对于内存受限的环境它是所有收集器中额外内存消耗最小的，对于处理器核心较少的环境，Serial 由于没有线程交互开销，可获得最高的单线程收集效率。
  新品
  Serial 的多线程版本，除了使用多线程进行垃圾收集外其余行为完全一致。
  ParNew 是虚拟机在服务端模式的默认新生代收集器，一个重要原因是除了 Serial 外只有它能与 CMS 配合。自从 JDK 9 开始，ParNew 加 CMS 不再是官方推荐的解决方案，官方希望它被 G1 取代。
  并行清理
  新生代收集器，基于复制算法，是可并行的多线程收集器，与 ParNew 类似。
  特点是它的关注点与其他收集器不同，Parallel Scavenge 的目标是达到一个可控制的吞吐量，吞吐量就是处理器用于运行用户代码的时间与处理器消耗总时间的比值。
  串行旧
  Serial 的老年代版本，单线程工作，使用标记-整理算法。
  Serial Old 是虚拟机在客户端模式的默认老年代收集器，用于服务端有两种用途：① JDK5 及之前与 Parallel Scavenge 搭配。② 作为CMS 失败预案。
  平行老
  Parallel Scavenge 的老年代版本，支持多线程，基于标记-整理算法。JDK6 提供，注重吞吐量可考虑 Parallel Scavenge 加 Parallel Old。
  不育系
  以获取最短回收停顿时间为目标，基于标记-清除算法，过程相对复杂，分为四个步骤：初始标记、并发标记、重新标记、并发清除。
  初始标记和重新标记需要 STW（Stop The World，系统停顿），初始标记仅是标记 GC Roots 能直接关联的对象，速度很快。并发标记从 GC Roots 的直接关联对象开始遍历整个对象图，耗时较长但不需要停顿用户线程。重新标记则是为了修正并发标记期间因用户程序运作而导致标记产生变动的那部分记录。并发清除清理标记阶段判断的已死亡对象，不需要移动存活对象，该阶段也可与用户线程并发。
  缺点：① 对处理器资源敏感，并发阶段虽然不会导致用户线程暂停，但会降低吞吐量。② 无法处理浮动垃圾，有可能出现并发失败而导致 Full GC。③ 基于标记-清除算法，产生空间碎片。
  G1
  开创了收集器面向局部收集的设计思路和基于 Region 的内存布局，主要面向服务端，最初设计目标是替换 CMS。
  G1 之前的收集器，垃圾收集目标要么是整个新生代，要么是整个老年代或整个堆。而 G1 可面向堆任何部分来组成回收集进行回收，衡量标准不再是分代，而是哪块内存中存放的垃圾数量最多，回收受益最大。
  跟踪各 Region 里垃圾的价值，价值即回收所获空间大小以及回收所需时间的经验值，在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先处理回收价值最大的 Region。这种方式保证了 G1 在有限时间内获取尽可能高的收集效率。
  G1 运作过程：
  初始标记：标记 GC Roots 能直接关联到的对象，让下一阶段用户线程并发运行时能正确地在可用 Region 中分配新对象。需要 STW 但耗时很短，在 Minor GC 时同步完成。
  并发标记：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆的对象图。耗时长但可与用户线程并发，扫描完成后要重新处理 SATB 记录的在并发时有变动的对象。
  最终标记：对用户线程做短暂暂停，处理并发阶段结束后仍遗留下来的少量 SATB 记录。
  筛选回收：对各 Region 的回收价值排序，根据用户期望停顿时间制定回收计划。必须暂停用户线程，由多条收集线程并行完成。
  可由用户指定期望停顿时间是 G1 的一个强大功能，但该值不能设得太低，一般设置为100~300 ms。
  

- 8、JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用

  当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM主要动机在于可以指定最大堆大小，通过压缩OOP 可以节省一定的内存。通过-XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。
  

- 9、invokedynamic 指令是干什么的？

  Java 7 开始，新引入的字节码指令，可以实现一些动态类型语言的功能。Java 8 的 Lambda 表达式就是通过 invokedynamic 指令实现，使用方法句柄实现。
  

- 10、动态改变构造

  OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理， OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。
  

- 11、怎样通过 Java 程序来判断 JVM 是 32 位 还是 64位？
- 12、引用计数法
- 13、在老年代-标记整理算法
- 14、Minor GC与Full GC分别在什么时候发生？
- 15、怎么获取 Java 程序使用的内存？堆使用的百分比？
- 16、在新生代-复制算法
- 17、JIT 是什么？
- 18、双亲委派模型是什么？
- 19、列举一些你知道的打破双亲委派机制的例子。为什么要打破？
- 20、谈谈你知道的垃圾回收算法
- 21、线上常用的 JVM 参数有哪些？
- 22、各种回收算法
- 23、JVM 有哪些运行时内存区域？
- 24、说说线程栈
- 25、JAVA8 与元数据
- 26、说说你知道的几种主要的JVM参数
- 27、生产环境用的什么JDK？如何配置的垃圾收集器？
- 28、本地方法栈的作用？
- 29、JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的
- 30、GC日志的real、user、sys是什么意思？
- 31、GC 是什么? 为什么要有 GC

### 3. 面试题3

- 1、ZGC 了解吗？

  JDK11 中加入的具有实验性质的低延迟垃圾收集器，目标是尽可能在不影响吞吐量的前提下，实现在任意堆内存大小都可以把停顿时间限制在 10ms 以内的低延迟。
  基于 Region 内存布局，不设分代，使用了读屏障、染色指针和内存多重映射等技术实现可并发的标记-整理，以低延迟为首要目标。
  ZGC 的 Region 具有动态性，是动态创建和销毁的，并且容量大小也是动态变化的。
  

- 2、safepoint是什么？

  STW并不会只发生在内存回收的时候。现在程序员这么卷，碰到几次safepoint的问题几率也是比较大的。
  当发生GC时，用户线程必须全部停下来，才可以进行垃圾回收，这个状态我们可以认为JVM是安全的（safe），整个堆的状态是稳定的。
  如果在GC前，有线程迟迟进入不了safepoint，那么整个JVM都在等待这个阻塞的线程，造成了整体GC的时间变长。
  

- 3、JVM 提供的常用工具

  jps：
  用来显示本地的 Java 进程，可以查看本地运行着几个 Java 程序，并显示他们的进程号。 命令格式：jps
  jinfo：
  运行环境参数：Java System 属性和 JVM 命令行参数，Java class path 等信息。 命令格式：jinfo 进程 pid
  jstat：
  监视虚拟机各种运行状态信息的命令行工具。 命令格式：jstat -gc 123 250 20
  jstack：
  可以观察到 JVM 中当前所有线程的运行情况和线程当前状态。 命令格式：jstack 进程 pid
  jmap：
  观察运行中的 JVM 物理内存的占用情况（如：产生哪些对象，及其数量）。 命令格式：jmap [option] pid
  

- 4、CMS 收集器（多线程标记清除算法）

  Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间， 和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂。整个过程分为以下 4 个阶段：
  初始标记
  只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。
  并发标记
  进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。
  重新标记
  为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。
  并发清除
  清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作， 所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。
  

- 5、对象都是优先分配在年轻代上的吗？

  不是。当新生代内存不够时，老年代分配担保。而大对象则是直接在老年代分配。
  

- 6、有哪些 GC 算法？

  标记-清除算法
  分为标记和清除阶段，首先从每个 GC Roots 出发依次标记有引用关系的对象，最后清除没有标记的对象。
  执行效率不稳定，如果堆包含大量对象且大部分需要回收，必须进行大量标记清除，导致效率随对象数量增长而降低。
  存在内存空间碎片化问题，会产生大量不连续的内存碎片，导致以后需要分配大对象时容易触发 Full GC。
  标记-复制算法
  为了解决内存碎片问题，将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当使用的这块空间用完了，就将存活对象复制到另一块，再把已使用过的内存空间一次清理掉。主要用于进行新生代。
  实现简单、运行高效，解决了内存碎片问题。代价是可用内存缩小为原来的一半，浪费空间。
  HotSpot 把新生代划分为一块较大的 Eden 和两块较小的 Survivor，每次分配内存只使用 Eden 和其中一块 Survivor。垃圾收集时将 Eden 和 Survivor 中仍然存活的对象一次性复制到另一块 Survivor 上，然后直接清理掉 Eden 和已用过的那块 Survivor。HotSpot 默认Eden 和 Survivor 的大小比例是 8:1，即每次新生代中可用空间为整个新生代的 90%。
  标记-整理算法
  标记-复制算法在对象存活率高时要进行较多复制操作，效率低。如果不想浪费空间，就需要有额外空间分配担保，应对被使用内存中所有对象都存活的极端情况，所以老年代一般不使用此算法。
  老年代使用标记-整理算法，标记过程与标记-清除算法一样，但不直接清理可回收对象，而是让所有存活对象都向内存空间一端移动，然后清理掉边界以外的内存。
  标记-清除与标记-整理的差异在于前者是一种非移动式算法而后者是移动式的。如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活的区域，是一种极为负重的操作，而且移动必须全程暂停用户线程。如果不移动对象就会导致空间碎片问题，只能依赖更复杂的内存分配器和访问器解决。
  

- 7、有什么堆外内存的排查思路？

  进程占用的内存，可以使用top命令，看RES段占用的值。如果这个值大大超出我们设定的最大堆内存，则证明堆外内存占用了很大的区域。
  使用gdb可以将物理内存dump下来，通常能看到里面的内容。更加复杂的分析可以使用perf工具，或者谷歌开源的gperftools。那些申请内存最多的native函数，很容易就可以找到。
  

- 8、SWAP会影响性能么？

  当操作系统内存不足的时候，会将部分数据写入到SWAP交换分中，但是SWAP的性能是比较低的。如果应用的访问量较大，需要频繁申请和销毁内存，就容易发生卡顿。一般高并发场景下，会禁用SWAP。
  

- 9、你知道哪些JVM性能调优

  设定堆内存大小
  1、 -Xmx：堆内存最大限制。设定新生代大小。新生代不宜太小，否则会有大量对象涌入老年代
  2、 -XX:NewSize：新生代大小
  3、 -XX:NewRatio 新生代和老生代占比
  4、 -XX:SurvivorRatio：伊甸园空间和幸存者空间的占比
  5、 设定垃圾回收器 年轻代用 -XX:+UseParNewGC 年老代用-XX:+UseConcMarkSweepGC
  

- 10、你都有哪些手段用来排查内存溢出？

  （这个话题很大，可以从实践环节中随便摘一个进行总结，下面举例一个最普通的）
  你可以来一个中规中矩的回
  内存溢出包含很多种情况，我在平常工作中遇到最多的就是堆溢出。有一次线上遇到故障，重新启动后，使用jstat命令，发现Old区在一直增长。我使用jmap命令，导出了一份线上堆栈，然后使用MAT进行分析。通过对GC Roots的分析，我发现了一个非常大的HashMap对象，这个原本是有位同学做缓存用的，但是一个无界缓存，造成了堆内存占用一直上升。后来，将这个缓存改成 guava的Cache，并设置了弱引用，故障就消失了。
  这个回答不是十分出彩，但着实是常见问题，让人挑不出毛病。
  

- 11、JIT是什么？
- 12、Java 中堆和栈有什么区别？
- 13、方法区
- 14、你能保证 GC 执行吗？
- 15、说说G1垃圾收集器的工作原理
- 16、方法区的作用是什么？
- 17、ParNew 垃圾收集器（Serial+多线程）
- 18、你知道哪些内存分配与回收策略？
- 19、什么是栈
- 20、Minor Gc和Full GC 有什么不同呢？
- 21、JVM怎么判断一个对象是不是要回收？
- 22、说一下Java对象的创建过程
- 23、怎么看死锁的线程？
- 24、JVM垃圾回收机制，何时触发MinorGC等操作
- 25、GC垃圾回收算法与垃圾收集器的关系？
- 26、永久代
- 27、谈谈JVM中，对类加载器的认识
- 28、描述一下什么情况下，对象会从年轻代进入老年代
- 29、可达性分析
- 30、描述一下JVM加载class文件的原理机制？

### 4. 面试题4

- 1、类加载的过程是什么？

  加载
  该阶段虚拟机需要完成三件事：① 通过一个类的全限定类名获取定义类的二进制字节流。② 将字节流所代表的静态存储结构转化为方法区的运行时数据区。③ 在内存中生成对应该类的 Class 实例，作为方法区这个类的数据访问入口。
  验证
  确保 Class 文件的字节流符合约束。如果虚拟机不检查输入的字节流，可能因为载入有错误或恶意企图的字节流而导致系统受攻击。验证主要包含四个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证。
  验证重要但非必需，因为只有通过与否的区别，通过后对程序运行期没有任何影响。如果代码已被反复使用和验证过，在生产环境就可以考虑关闭大部分验证缩短类加载时间。
  准备
  为类静态变量分配内存并设置零值，该阶段进行的内存分配仅包括类变量，不包括实例变量。如果变量被 final 修饰，编译时 Javac 会为变量生成 ConstantValue 属性，准备阶段虚拟机会将变量值设为代码值。
  解析
  将常量池内的符号引用替换为直接引用。
  符号引用以一组符号描述引用目标，可以是任何形式的字面量，只要使用时能无歧义地定位目标即可。与虚拟机内存布局无关，引用目标不一定已经加载到虚拟机内存。
  直接引用是可以直接指向目标的指针、相对偏移量或能间接定位到目标的句柄。和虚拟机的内存布局相关，引用目标必须已在虚拟机的内存中存在。
  初始化
  直到该阶段 JVM 才开始执行类中编写的代码。准备阶段时变量赋过零值，初始化阶段会根据程序员的编码去初始化类变量和其他资源。初始化阶段就是执行类构造方法中的 `` 方法，该方法是 Javac 自动生成的。
  

- 2、谈谈 JVM 中的常量池

  JDK 1.8 开始
  1、 字符串常量池：存放在堆中，包括 String 对象执行 intern() 方法后存的地方、双引号直接引用的字符串
  2、 运行时常量池：存放在方法区，属于元空间，是类加载后的一些存储区域，大多数是类中 constant_pool 的内容
  3、 类文件常量池：constant_pool，JVM 定义的概念
  

- 3、JVM 内存区域

  JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。
  线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。
  线程共享区域随虚拟机的启动/关闭而创建/销毁。
  直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于Channel与 Buffer的IO方式, 它可以使用Native函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。
  

- 4、G1 收集器

  Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器， G1 收集器两个最突出的改进是：
  1、 基于标记-整理算法，不产生内存碎片。
  2、 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率
  

- 5、堆的作用是什么？

  堆是虚拟机所管理的内存中最大的一块，被所有线程共享的，在虚拟机启动时创建。堆用来存放对象实例，Java 里几乎所有对象实例都在堆分配内存。堆可以处于物理上不连续的内存空间，逻辑上应该连续，但对于例如数组这样的大对象，多数虚拟机实现出于简单、存储高效的考虑会要求连续的内存空间。
  堆既可以被实现成固定大小，也可以是可扩展的，可通过 -Xms 和 -Xmx 设置堆的最小和最大容量，当前主流 JVM 都按照可扩展实现。如果堆没有内存完成实例分配也无法扩展，抛出 OutOfMemoryError。
  

- 6、如何查看 JVM 当前使用的是什么垃圾收集器？

  -XX:+PrintCommandLineFlags 参数可以打印出所选垃圾收集器和堆空间大小等设置
  如果开启了 GC 日志详细信息，里面也会包含各代使用的垃圾收集器的简称
  

- 7、GC的回收流程是怎样的？

  GC回收流程如下：
  1、 对于整个的GC流程里面，那么最需要处理的就是新生代和老年代的内存清理操作，而元空间（永久代）都不在GC范围内
  2、 当现在有一个新的对象产生，那么对象一定需要内存空间，平均每个栈内存存4k，每个堆内存存8k，那么对象一定需要进行堆空间的申请
  3、 首先会判断Eden区是否有内存空间，如果此时有内存空间，则直接将新对象保存在伊甸园区。
  4、 但是如果此时在伊甸园区内存不足，那么会自动执行一个Minor GC 操作，将伊甸园区的无用内存空间进行清理，Minor GC的清理范围只在Eden园区，清理之后会继续判断Eden园区的内存空间是否充足？如果内存空间充足，则将新对象直接在Eden园区进行空间分配。
  5、 如果执行Minor GC 之后发现伊甸园区的内存空间依然不足，那么这个时候会执行存活区的判断，如果存活区有剩余空间，则将Eden园区部分活跃对象保存在存活区，那么随后继续判断Eden园区的内存空间是否充足，如果充足怎则将新对象直接在Eden园区进行空间分配。
  6、 此时如果存活区没有内存空间，则继续判断老年区。则将部分存活对象保存在老年代，而后存活区将有空余空间。
  7、 如果这个时候老年代也满了，那么这个时候将产生Major GC（Full GC）,那么这个时候将进行老年代的清理
  8、 如果老年代执行Full GC之后，无法进行对象的保存，则会产生OOM异常,OutOfMemoryError异常
  

- 8、类的实例化顺序

  1、 父类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行
  2、 子类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行
  3、 父类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行
  4、 父类构造方法
  5、 子类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行
  6、 子类构造方法
  

- 9、工作中常用的 JVM 配置参数有哪些？

  Java 8 为例
  日志
  1、 -XX:+PrintFlagsFinal，打印JVM所有参数的值
  2、 -XX:+PrintGC，打印GC信息
  3、 -XX:+PrintGCDetails，打印GC详细信息
  4、 -XX:+PrintGCTimeStamps，打印GC的时间戳
  5、 -Xloggc:filename，设置GC log文件的位置
  6、 -XX:+PrintTenuringDistribution，查看熬过收集后剩余对象的年龄分布信息
  内存设置
  1、 -Xms，设置堆的初始化内存大小
  2、 -Xmx，设置堆的最大内存
  3、 -Xmn，设置新生代内存大小
  4、 -Xss，设置线程栈大小
  5、 -XX:NewRatio，新生代与老年代比值
  6、 -XX:SurvivorRatio，新生代中Eden区与两个Survivor区的比值，默认为8，即Eden:Survivor:Survivor=8:1:1
  7、 -XX:MaxTenuringThreshold，从年轻代到老年代，最大晋升年龄。CMS 下默认为 6，G1 下默认为 15
  8、 -XX:MetaspaceSize，设置元空间的大小，第一次超过将触发 GC
  9、 -XX:MaxMetaspaceSize，元空间最大值
  10、 -XX:MaxDirectMemorySize，用于设置直接内存的最大值，限制通过 DirectByteBuffer 申请的内存
  11、 -XX:ReservedCodeCacheSize，用于设置 JIT 编译后的代码存放区大小，如果观察到这个值有限制，可以适当调大，一般够用即可
  设置垃圾收集相关
  1、 -XX:+UseSerialGC，设置串行收集器
  2、 -XX:+UseParallelGC，设置并行收集器
  3、 -XX:+UseConcMarkSweepGC，使用CMS收集器
  4、 -XX:ParallelGCThreads，设置Parallel GC的线程数
  5、 -XX:MaxGCPauseMillis，GC最大暂停时间 ms
  6、 -XX:+UseG1GC，使用G1垃圾收集器
  CMS 垃圾回收器相关
  1、 -XX:+UseCMSInitiatingOccupancyOnly
  2、 -XX:CMSInitiatingOccupancyFraction，与前者配合使用，指定MajorGC的发生时机
  3、 -XX:+ExplicitGCInvokesConcurrent，代码调用 System.gc() 开始并行 FullGC，建议加上这个参数
  4、 -XX:+CMSScavengeBeforeRemark，表示开启或关闭在 CMS 重新标记阶段之前的清除（YGC）尝试，它可以降低 remark 时间，建议加上
  5、 -XX:+ParallelRefProcEnabled，可以用来并行处理 Reference，以加快处理速度，缩短耗时
  G1 垃圾回收器相关
  1、 -XX:MaxGCPauseMillis，用于设置目标停顿时间，G1 会尽力达成
  2、 -XX:G1HeapRegionSize，用于设置小堆区大小，建议保持默认
  3、 -XX:InitiatingHeapOccupancyPercent，表示当整个堆内存使用达到一定比例（默认是 45%），并发标记阶段就会被启动
  4、 -XX:ConcGCThreads，表示并发垃圾收集器使用的线程数量，默认值随 JVM 运行的平台不同而变动，不建议修改
  参数查询官网地址：
  https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html
  建议面试时最好能记住 CMS 和 G1的参数，特点突出使用较多，被问的概率大
  

- 10、Java里有哪些引用类型？

  1、 强引用 这种引用属于最普通最强硬的一种存在，只有在和 GC Roots 断绝关系时，才会被消灭掉。
  2、 软引用 软引用用于维护一些可有可无的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。可以看到，这种特性非常适合用在缓存技术上。比如网页缓存、图片缓存等。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java 虚拟机就会把这个软引用加入到与之关联的引用队列中。
  3、 弱引用 弱引用对象相比较软引用，要更加无用一些，它拥有更短的生命周期。当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。弱引用拥有更短的生命周期，在 Java 中，用 java.lang.ref.WeakReference 类来表示。它的应用场景和软引用类似，可以在一些对内存更加敏感的系统里采用。
  4、 虚引用 这是一种形同虚设的引用，在现实场景中用的不是很多。虚引用必须和引用队列（ReferenceQueue）联合使用。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。实际上，虚引用的 get，总是返回 null。
  

- 11、本地方法区(线程私有)
- 12、什么是本地方法栈
- 13、栈溢出的原因？
- 14、Java的内存模型是什么？（JMM是什么？）
- 15、方法区溢出的原因？
- 16、JVM 监控与分析工具你用过哪些？介绍一下。
- 17、说说类加载的过程
- 18、MinorGC、MajorGC、FullGC 什么时候发生？
- 19、谈谈你知道的垃圾收集器
- 20、复制算法（copying）
- 21、垃圾收集算法
- 22、JVM的永久代中会发生垃圾回收么
- 23、类加载器双亲委派模型机制？
- 24、为什么需要双亲委派模式？
- 25、讲讲什么情况下会出现内存溢出，内存泄漏？
- 26、JVM 如何确定垃圾对象？
- 27、OSGI（ 动态模型系统）
- 28、你平时工作中用过的JVM常用基本配置参数有哪些？
- 29、invokedynamic指令是干什么的？
- 30、程序计数器
- 31、强引用、软引用、弱引用、虚引用是什么？

### 5. 面试题5

- 1、谈谈动态年龄判断

  1、 这里涉及到 -XX:TargetSurvivorRatio 参数，Survivor 区的目标使用率默认 50，即 Survivor 区对象目标使用率为 50%。
  2、 Survivor 区相同年龄所有对象大小的总和 (Survivor 区内存大小 * 这个目标使用率)时，大于或等于该年龄的对象直接进入老年代。
  3、 当然，这里还需要考虑参数 -XX:MaxTenuringThreshold 晋升年龄最大阈值
  

- 2、类初始化的情况有哪些？

  遇到 new、getstatic、putstatic 或 invokestatic 字节码指令时，还未初始化。典型场景包括 new 实例化对象、读取或设置静态字段、调用静态方法。
  对类反射调用时，还未初始化。
  初始化类时，父类还未初始化。
  虚拟机启动时，会先初始化包含 main 方法的主类。
  使用 JDK7 的动态语言支持时，如果 MethodHandle 实例的解析结果为指定类型的方法句柄且句柄对应的类还未初始化。
  口定义了默认方法，如果接口的实现类初始化，接口要在其之前初始化。
  其余所有引用类型的方式都不会触发初始化，称为被动引用。被动引用实例：① 子类使用父类的静态字段时，只有父类被初始化。② 通过数组定义使用类。③ 常量在编译期会存入调用类的常量池，不会初始化定义常量的类。
  接口和类加载过程的区别：初始化类时如果父类没有初始化需要初始化父类，但接口初始化时不要求父接口初始化，只有在真正使用父接口时（如引用接口中定义的常量）才会初始化。
  

- 3、GC 是什么？为什么要有 GC？

  GC 是垃 圾收 集的 意思 ，内存 处理 是编 程人 员容 易出 现问 题的 地方 ，忘记 或者 错误的内 存回 收会 导致 程序 或系 统的 不稳 定甚 至崩 溃， Java 提供 的 GC 功能 可以 自动监测 对象 是否 超过 作用 域从 而达 到自 动回 收内 存的 目的 ，Java 语言 没有 提供 释放已分配内存的 显示 操作 方法 。Java 程序 员不 用担 心内 存管 理， 因为 垃圾 收集 器会自动 进行 管理 。要 请求 垃圾 收集 ，可 以调 用下 面的 方法 之一 ：System.gc() 或Runtime.getRuntime().gc() ，但 JVM 可以 屏蔽 掉线 示的 垃圾 回收 调用 。
  垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在 Java 诞生初期，垃圾回收是 Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今 Java 的垃圾回收机制已经成为被诟病的东。移动智能终端用户通常觉得 iOS 的系统比 Android 系统有更好的用户体验，其中一个深层次的原因就在于 Android 系统中垃圾回收的不可预知性。
  

- 4、MinorGC，MajorGC、FullGC都什么时候发生？

  MinorGC在年轻代空间不足的时候发生，MajorGC指的是老年代的GC，出现MajorGC一般经常伴有MinorGC。
  FullGC有三种情况。
  1、 当老年代无法再分配内存的时候
  2、 元空间不足的时候
  3、 显示调用System.gc的时候。另外，像CMS一类的垃圾回收器，在MinorGC出现promotion failure的时候也会发生FullGC
  

- 5、Java的双亲委托机制是什么？

  它的意思是，除了顶层的启动类加载器以外，其余的类加载器，在加载之前，都会委派给它的父加载器进行加载。这样一层层向上传递，直到祖先们都无法胜任，它才会真正的加载。
  Java默认是这种行为。当然Java中也有很多打破双亲行为的骚操作，比如SPI（JDBC驱动加载），OSGI等。
  

- 6、在 Java 中，对象什么时候可以被垃圾回收？

  当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。
  

- 7、有哪些打破了双亲委托机制的案例？

  1、 Tomcat可以加载自己目录下的class文件，并不会传递给父类的加载器。
  2、 Java的SPI，发起者是 BootstrapClassLoader， BootstrapClassLoader已经是最上层的了。它直接获取了 AppClassLoader进行驱动加载，和双亲委派是相反的。。
  

- 8、JVM 年轻代到年老代的晋升过程的判断条件是什么呢？

  1、 部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代。
  2、 如果对象的大小大于Eden的二分之一会直接分配在old，如果old也分配不下，会做一次majorGC，如果小于eden的一半但是没有足够的空间，就进行minorgc也就是新生代GC。
  3、 minor gc后，survivor仍然放不下，则放到老年代
  4、 动态年龄判断 ，大于等于某个年龄的对象超过了survivor空间一半 ，大于等于某个年龄的对象直接进入老年代
  

- 9、JVM 数据运行区，哪些会造成 OOM 的情况？

  除了数据运行区，其他区域均有可能造成 OOM 的情况。
  **堆溢出：**java.lang.OutOfMemoryError: Java heap space
  **栈溢出：**java.lang.StackOverflowError
  **永久代溢出：**java.lang.OutOfMemoryError: PermGen space
  

- 10、JVM 类加载机制

  JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化。
  加载
  加载是类加载过程中的一个阶段， 这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象， 作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。
  验证
  这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
  准备
  准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：
  实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080， 将 v 赋值为 8080 的 put static 指令是程序被编译后， 存放于类构造器方法之中。
  但是注意如果声明为：
  public static final int v = 8080;
  在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080。
  解析
  解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的
  public static int v = 8080;
  实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080， 将 v 赋值为 8080 的 put static 指令是程序被编译后， 存放于类构造器方法之中。但是注意如果声明为：
  在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080。
  解析
  解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的
  public static final int v = 8080;
  在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080。
  解析
  解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：
  1、 CONSTANT_Class_info
  2、 CONSTANT_Field_info
  3、 CONSTANT_Method_info
  等类型的常量。
  符号引用
  符号引用与虚拟机实现的布局无关， 引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。
  直接引用
  直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。
  初始化
  初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。
  类构造器
  初始化阶段是执行类构造器方法的过程。方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子方法执行之前，父类的方法已经执行完毕， 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成()方法。
  注意以下几种情况不会执行类初始化：
  1、 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
  2、 定义对象数组，不会触发该类的初始化。
  3、 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。
  4、 通过类名获取 Class 对象，不会触发类的初始化。
  5、 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
  6、 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。
  

- 11、字符串常量存放在哪个区域？
- 12、对象的访问方式有哪些？
- 13、说一下 JVM 调优的工具？
- 14、对象分配内存是否线程安全？
- 15、什么时候会造成堆外内存溢出？
- 16、你都用过G1垃圾回收器的哪几个重要参数？
- 17、双亲委派
- 18、Parallel Old 收集器（多线程标记整理算法）
- 19、Java 程序是怎样运行的？
- 20、请解释StackOverflowError和OutOfMemeryError的区别？
- 21、分区收集算法
- 22、串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？
- 23、栈帧都有哪些数据？
- 24、对象在哪块内存分配？
- 25、运行时常量池溢出的原因？
- 26、safepoint 是什么？
- 27、JVM调优命令有哪些？
- 28、你说你做过JVM参数调优和参数配置，请问如何查看JVM系统默认值
- 29、Java 中会存在内存泄漏?简述一下
- 30、对象是怎么从年轻代进入老年代的？
- 31、什么情况下会发生栈内存溢出？

### 6. 面试题6

- 1、类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？

  双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。
  1、 假设有一个开发者自己编写了一个名为java.lang.Object的类，想借此欺骗JVM。现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类。
  2、 然而幸运的是，双亲委托模型不会让他成功。因为JVM会优先在Bootstrap ClassLoader的路径下找到java.lang.Object类，并载入它
  Java的类加载是否一定遵循双亲委托模型？
  1、 在实际开发中，我们可以通过自定义ClassLoader，并重写父类的loadClass方法，来打破这一机制。
  2、 SPI就是打破了双亲委托机制的(SPI：服务提供发现)。
  

- 2、生产环境 CPU 占用过高，你如何解决？

  1、 top + H 指令找出占用 CPU 最高的进程的 pid
  2、 top -H -p
  在该进程中找到，哪些线程占用的 CPU 最高的线程，记录下 tid
  3、 jstack -l
  threads.txt，导出进程的线程栈信息到文本，导出出现异常的话，加上 -F 参数
  4、 将 tid 转换为十六进制，在 threads.txt 中搜索，查到对应的线程代码执行栈，在代码中查找占 CPU 比较高的原因。其中 tid 转十六进制，可以借助 Linux 的 printf "%x" tid 指令
  我用上述方法查到过，jvm 多条线程疯狂 full gc 导致的CPU 100% 的问题和 JDK1.6 HashMap 并发 put 导致线程 CPU 100% 的问题
  

- 3、JVM 的内存模型是什么？

  JVM 试图定义一种统一的内存模型，能将各种底层硬件以及操作系统的内存访问差异进行封装，使 Java 程序在不同硬件以及操作系统上都能达到相同的并发效果。它分为工作内存和主内存，线程无法对主存储器直接进行操作，如果一个线程要和另外一个线程通信，那么只能通过主存进行交换。
  

- 4、你知道哪些GC类型？

  Minor GC：发生在年轻代的 GC。Major GC：发生在老年代的 GC。Full GC：全堆垃圾回收。比如 Metaspace 区引起年轻代和老年代的回收。
  

- 5、如何判断一个常量是废弃常量 ？

  运行时常量池主要回收的是废弃的常量。假如在常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。
  

- 6、对象的内存布局了解吗？

  对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。
  对象头占 12B，包括对象标记和类型指针。对象标记存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁标志、偏向线程 ID 等，这部分占 8B，称为 Mark Word。Mark Word 被设计为动态数据结构，以便在极小的空间存储更多数据，根据对象状态复用存储空间。
  类型指针是对象指向它的类型元数据的指针，占 4B。JVM 通过该指针来确定对象是哪个类的实例。
  实例数据是对象真正存储的有效信息，即本类对象的实例成员变量和所有可见的父类成员变量。存储顺序会受到虚拟机分配策略参数和字段在源码中定义顺序的影响。相同宽度的字段总是被分配到一起存放，在满足该前提条件的情况下父类中定义的变量会出现在子类之前。
  对齐填充不是必然存在的，仅起占位符作用。虚拟机的自动内存管理系统要求任何对象的大小必须是 8B 的倍数，对象头已被设为 8B 的 1 或 2 倍，如果对象实例数据部分没有对齐，需要对齐填充补全。
  

- 7、Java对象的布局了解过吗？

  对象头区域此处存储的信息包括两部分：
  1、对象自身的运行时数据( MarkWord )，占8字节 存储 hashCode、GC 分代年龄、锁类型标记、偏向锁线程 ID 、 CAS 锁指向线程 LockRecord 的指针等， synconized 锁的机制与这个部分( markwork )密切相关，用 markword 中最低的三位代表锁的状态，其中一位是偏向锁位，另外两位是普通锁位。
  2、对象类型指针( Class Pointer )，占4字节 对象指向它的类元数据的指针、 JVM 就是通过它来确定是哪个 Class 的实例。
  实例数据区域 此处存储的是对象真正有效的信息，比如对象中所有字段的内容
  对齐填充区域 JVM 的实现 HostSpot 规定对象的起始地址必须是 8 字节的整数倍，换句话来说，现在 64 位的 OS 往外读取数据的时候一次性读取 64bit 整数倍的数据，也就是 8 个字节，所以 HotSpot 为了高效读取对象，就做了"对齐"，如果一个对象实际占的内存大小不是 8byte 的整数倍时，就"补位"到 8byte 的整数倍。所以对齐填充区域的大小不是固定的。
  

- 8、谈谈双亲委派模型

  1、 Parents Delegation Model，这里的 Parents 翻译成双亲有点不妥，类加载向上传递的过程中只有单亲；parents 更多的是多级向上的意思。
  2、 除了顶层的启动类加载器，其他的类加载器在加载之前，都会委派给它的父加载器进行加载，一层层向上传递，直到所有父类加载器都无法加载，自己才会加载该类。
  3、 双亲委派模型，更好地解决了各个类加载器协作时基础类的一致性问题，避免类的重复加载；防止核心API库被随意篡改。
  JDK 9 之前
  1、 启动类加载器（Bootstrp ClassLoader），加载 /lib/rt.jar、-Xbootclasspath
  2、 扩展类加载器（Extension ClassLoader）sun.misc.Launcher$ExtClassLoader，加载 /lib/ext、java.ext.dirs
  3、 应用程序类加载器（Application ClassLoader，sun.misc.Launcher$AppClassLoader），加载 CLASSPTH、-classpath、-cp、Manifest
  4、 自定义类加载器
  JDK 9 开始 Extension ClassLoader 被 Platform ClassLoader 取代，启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader
  类加载代码逻辑
  protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    // 首先，检查请求的类是否已经被加载过了
    Class c = findLoadedClass(name);
    if (c == null) {
      try {
        if (parent != null) {
          c = parent.loadClass(name, false);
        } else {
          c = findBootstrapClassOrNull(name);
        }
      } catch (ClassNotFoundException e) {
        // 如果父类加载器抛出ClassNotFoundException
        // 说明父类加载器无法完成加载请求
      }
      if (c == null) {
        // 在父类加载器无法加载时
        // 再调用本身的findClass方法来进行类加载
        c = findClass(name);
      }
    }
    if (resolve) {
      resolveClass(c);
    }
    return c;
  }
  

- 9、CMS分为哪几个阶段?

  CMS已经弃用。生活美好，时间有限，不建议再深入研究了。如果碰到问题，直接祭出回收过程即可。
  1、 初始标记
  2、 并发标记
  3、 并发预清理
  4、 并发可取消的预清理
  5、 重新标记
  6、 并发清理
  

- 10、解释 Java 堆空间及 GC？

  当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。
  

- 11、调优命令有哪些？
- 12、Java 中 WeakReference 与 SoftReference 的区别？
- 13、JRE、JDK、JVM 及 JIT 之间有什么不同？
- 14、CMS都有哪些问题？
- 15、Java 8 为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢？
- 16、64 位 JVM 中，int 的长度是多数？
- 17、介绍一下 JVM 中垃圾收集器有哪些？ 他们特点分别是什么？
- 18、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代？
- 19、遇到过堆外内存溢出吗？
- 20、对象的访问定位有哪几种方式?
- 21、什么是分布式垃圾回收（DGC）？它是如何工作的？
- 22、遇到过元空间溢出吗？
- 23、说说ZGC垃圾收集器的工作原理
- 24、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
- 25、说说类加载的过程
- 26、Serial 垃圾收集器（单线程、 复制算法）
- 27、如何写一段简单的死锁代码？
- 28、如何找到死锁的线程？
- 29、直接内存是什么？
- 30、新生代与复制算法

## 第3章 MySQL

### 1. 面试题1

- 1、什么是存储过程？用什么来调用？

  存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。
  

- 2、优化数据库的方法

  1、  选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM
  2、  使用连接(JOIN)来代替子查询
  3、  适用联合(UNION)来代替手动创建的临时表
  4、  事务处理
  5、  锁定表、优化事务处理
  6、  适用外键，优化锁定表
  7、  建立索引
  8、  优化查询语句
  

- 3、完整性约束包括哪些？

  数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。
  分为以下四类：
  1、 实体完整性：规定表的每一行在表中是惟一的实体。
  2、 域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。
  3、 参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。
  4、 用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。
  与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。
  

- 4、使用B树的好处

  B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。
  

- 5、视图有哪些特点？哪些使用场景？

  「视图特点：」
  1、 视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。
  2、 视图是由基本表(实表)产生的表(虚表)。
  3、 视图的建立和删除不影响基本表。
  4、 对视图内容的更新(添加，删除和修改)直接影响基本表。
  5、 当视图来自多个基本表时，不允许添加和删除数据。
  「视图用途：」 简化sql查询，提高开发效率，兼容老的表结构。
  「视图的常见使用场景：」
  1、 重用SQL语句；
  2、 简化复杂的SQL操作。
  3、 使用表的组成部分而不是整个表；
  4、 保护数据
  5、 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。
  

- 6、事务是如何通过日志来实现的

  因为事务在修改页时，要先记 undo，在记 undo 之前要记 undo 的 redo， 然后修改数据页，再记数据页修改的 redo。 Redo（里面包括 undo 的修改） 一定要比数据页先持久化到磁盘。
  当事务需要回滚时，因为有 undo，可以把数据页回滚到前镜像的 状态，崩溃恢复时，如果 redo log 中事务没有对应的 commit 记录，那么需要用 undo把该事务的修改回滚到事务开始之前。
  如果有 commit 记录，就用 redo 前滚到该事务完成时并提交掉。
  

- 7、索引有哪几种类型？

  1、 主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。
  2、 唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。
  3、 普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。
  4、 全文索引：是目前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。
  5、 覆盖索引：查询列要被所建的索引覆盖，不必读取数据行
  6、 组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并
  

- 8、谈谈六种关联查询，使用场景。

  1、 交叉连接
  2、 内连接
  3、 外连接
  4、 联合查询
  5、 全连接
  6、 交叉连接
  

- 9、试述视图的优点？

  (1) 视图能够简化用户的操作 (2) 视图使用户能以多种角度看待同一数据； (3) 视图为数据库提供了一定程度的逻辑独立性； (4) 视图能够对机密数据提供安全保护。
  

- 10、MySQL自增主键用完了怎么办？

  自增主键一般用int类型，一般达不到最大值，可以考虑提前分库分表的。
  

- 11、为什么要尽量设定一个主键？
- 12、存储时期
- 13、创建索引的三种方式
- 14、为什么要使用数据库
- 15、实践中如何优化MySQL
- 16、MySQL如何优化DISTINCT？
- 17、什么是触发器？触发器的使用场景有哪些？
- 18、如何显示前50行？
- 20、B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？
- 21、MySQL中有哪几种锁，列举一下？
- 22、超键、候选键、主键、外键分别是什么？
- 23、为什么官方建议使用自增长主键作为索引？
- 24、什么情况下设置了索引但无法使用
- 25、MySQL中有哪几种锁，列举一下？
- 26、什么是基本表？什么是视图？
- 27、索引哪些情况会失效
- 28、一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。
- 29、视图有哪些特点？哪些使用场景？
- 30、数据表损坏的修复方式有哪些？

### 2. 面试题2

- 1、innoDB的B+Tree 存储整行数据和主键的值得区别？

  1、 整行数据：innoDB的B+Tree存储了整行数据的是主键索引，也被成为聚凑索引。
  2、 存储主键的值：成为非主键索引，也被称为非聚凑索引
  

- 2、读写分离常见方案？

  1、 应用程序根据业务逻辑来判断，增删改等写操作命令发给主库，查询命令发给备库。
  2、 利用中间件来做代理，负责对数据库的请求识别出读还是写，并分发到不同的数据库中。（如：amoeba，MySQL-proxy）
  

- 3、六种关联查询

  1、 交叉连接（CROSS JOIN）
  2、 内连接（INNER JOIN）
  3、 外连接（LEFT JOIN/RIGHT JOIN）
  4、 联合查询（UNION与UNION ALL）
  5、 全连接（FULL JOIN）
  6、 交叉连接（CROSS JOIN）
  SELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id=B.id或者SELECT * FROM A INNER JOIN B ON A.id=B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN
  内连接分为三类
  1、 等值连接：ON A.id=B.id
  2、 不等值连接：ON A.id > B.id
  3、 自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid
  外连接（LEFT JOIN/RIGHT JOIN）
  左外连接：
  LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN
  右外连接：
  RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN
  联合查询（UNION与UNION ALL）
  SELECT * FROM A UNION SELECT * FROM B UNION ...
  1、 就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并
  2、 如果使用UNION ALL，不会合并重复的记录行
  3、 效率 UNION 高于 UNION ALL
  全连接（FULL JOIN）
  SELECT * FROM A LEFT JOIN B ON A.id=B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id=B.id
  MySQL不支持全连接
  

- 4、什么是存储过程？有哪些优缺点？

  存储过程，就是一些编译好了的SQL语句，这些SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后给这些代码块取一个名字，在用到这个功能的时候调用即可。
  优点：
  1、 存储过程是一个预编译的代码块，执行效率比较高
  2、 存储过程在服务器端运行，减少客户端的压力
  3、 允许模块化程序设计，只需要创建一次过程，以后在程序中就可以调用该过程任意次，类似方法的复用
  4、 一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率
  5、 可以一定程度上确保数据安全
  缺点：
  1、 调试麻烦
  2、 可移植性不灵活
  3、 重新编译问题
  

- 5、优化关联查询

  1、 确定ON或者USING子句中是否有索引。
  2、 确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。
  

- 6、主键和候选键有什么区别？

  表格的每一行都由主键唯一标识,一个表只有一个主键。
  主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。
  

- 7、既然提到了InnoDB使用户的B+树的索引模型

  那么你知道为什么采用B+树吗？这和Hash索引比较起来有什么缺点吗？
  因为hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点，父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。
  

- 8、MySQL_fetch_array和MySQL_fetch_object的区别是什么？

  以下是MySQL_fetch_array和MySQL_fetch_object的区别：
  MySQL_fetch_array（） – 将结果行作为关联数组或来自数据库的常规数组返回。
  MySQL_fetch_object – 从数据库返回结果行作为对象。
  

- 9、对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题：

  1、 索引的目的是什么？
  快速访问数据表中的特定信息，提高检索速度
  创建唯一性索引，保证数据库表中每一行数据的唯一性。
  加速表和表之间的连接
  使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间
  2、 索引对数据库系统的负面影响是什么？
  负面影响：
  创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。
  3、 为数据表建立索引的原则有哪些？
  在最频繁使用的、用以缩小查询范围的字段上建立索引。
  在频繁使用的、需要排序的字段上建立索引
  4、 什么情况下不宜建立索引？
  对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。
  对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等
  

- 10、MySQL如何优化DISTINCT？

  DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。
  1
  SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;
  

- 11、什么是幻读，脏读，不可重复读呢？
- 12、linux添加索引
- 13、B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？
- 14、数据库中间件了解过吗，sharding jdbc，mycat？
- 15、为什么要使用视图？什么是视图？
- 16、NULL是什么意思
- 17、MySQL中InnoDB引擎的行锁是怎么实现的？
- 18、优化器的执行过程？
- 19、什么是最左前缀原则？什么是最左匹配原则
- 20、LIKE声明中的％和_是什么意思？
- 21、使用乐观锁
- 22、varchar(50)中50的涵义
- 23、主从同步延迟的解决办法
- 24、MySQL 遇到过死锁问题吗，你是如何解决的？
- 25、主键使用自增ID还是UUID，为什么？
- 26、什么是数据库事务？
- 27、怎么查询SQL语句是否使用了索引查询？
- 28、什么是死锁？怎么解决？
- 29、主键使用自增ID还是UUID？
- 30、MVCC熟悉吗，它的底层原理？

### 3. 面试题3

- 1、隔离级别与锁的关系

  回答这个问题，可以先阐述四种隔离级别，再阐述它们的实现原理。隔离级别就是依赖锁和MVCC实现的。
  

- 2、实践中如何优化MySQL

  最好是按照以下顺序优化：
  1、 SQL语句及索引的优化
  2、 数据库表结构的优化
  3、 系统配置的优化
  4、 硬件的优化
  

	- 详细可以查看 阿里P8架构师谈：MySQL慢查询优化、索引优化、以及表等优化总结

- 3、优化子查询

  1、 用关联查询替代
  2、 优化GROUP BY和DISTINCT
  3、 这两种查询据可以使用索引来优化，是最有效的优化方法
  4、 关联查询中，使用标识列分组的效率更高
  5、 如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。
  6、 WITH ROLLUP超级聚合，可以挪到应用程序处理
  

- 4、前缀索引

  1、 语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。
  2、 前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。
  3、 实操的难度：在于前缀截取的长度。
  4、 我们可以利用select count(*)/count(distinct left(password,prefixLen));，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）
  

- 5、MySQL5.6和MySQL5.7对索引做了哪些优化？

  1、 MySQL5.6引入了索引下推优化，默认是开启的。
  2、 例子：user表中（a,b,c）构成一个索引。
  3、 select * from user where a='23' and b like '%eqw%' and c like 'dasd'。
  4、 解释：如果没有索引下推原则，则MySQL会通过a='23' 先查询出一个对应的数据。然后返回到MySQL服务端。MySQL服务端再基于两个like模糊查询来校验and查询出的数据是否符合条件。这个过程就设计到回表操作。
  5、 如果使用了索引下推技术，则MySQL会首先返回返回条件a='23'的数据的索引，然后根据模糊查询的条件来校验索引行数据是否符合条件，如果符合条件，则直接根据索引来定位对应的数据，如果不符合直接reject掉。因此，有了索引下推优化，可以在有like条件的情况下，减少回表的次数。
  

- 6、MySQL有关权限的表有哪几个呢？

  MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在MySQL数据库里，由MySQL_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。
  1、 user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。
  2、 db权限表：记录各个帐号在各个数据库上的操作权限。
  3、 table_priv权限表：记录数据表级的操作权限。
  4、 columns_priv权限表：记录数据列级的操作权限。
  5、 host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。
  

- 7、MySQL中都有哪些触发器？

  MySQL 数据库中有六种触发器：
  1、 Before Insert
  2、 After Insert
  3、 Before Update
  4、 After Update
  5、 Before Delete
  6、 After Delete
  

- 8、大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？

  当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：
  1、 限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；
  2、 读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；
  3、 缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；
  还有就是通过分库分表的方式进行优化，主要有垂直分区、垂直分表和水平分区、水平分表
  垂直分区
  1、 根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。
  2、 简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。
  垂直拆分的优点：
  可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
  垂直拆分的缺点：
  主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；
  垂直分表
  把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中
  适用场景
  1、 如果一个表中某些列常用，另外一些列不常用
  2、 可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数
  缺点
  1、 有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差
  2、 对于应用层来说，逻辑算法增加开发成本
  3、 管理冗余列，查询所有数据需要join操作
  水平分区
  1、 保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。
  2、 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。
  1、 水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。
  2、 水平拆分能够支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨界点Join性能较差，逻辑复杂。
  《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。
  水平分表：
  表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数
  适用场景
  1、 表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。
  2、 需要把数据存放在多个介质上。
  水平切分的缺点
  1、 给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作
  2、 在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数
  数据库分片的两种常见方案：
  客户端代理：
  分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。
  中间件代理：
  在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。
  分库分表后面临的问题
  事务支持
  分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。
  跨库join
  只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品
  跨节点的count,order by,group by以及聚合函数问题
  这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。
  数据迁移，容量规划，扩容等问题
  来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。
  ID问题
  一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由、一些常见的主键生成策略
  UUID 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 Twitter的分布式自增ID算法Snowflake 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。
  跨分片的排序分页问题
  一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：
  

- 9、B+ Tree索引和Hash索引区别？

  1、 hash索引适合等值查询，但是无法进行范围查询。
  2、 hash索引没办法利用索引完成排序。
  3、 hash索引不支持多列联合索引的最左匹配规则。
  4、 如果有大量重复健值得情况下，hash索引的效率会很低，因为哈希碰撞问题。
  

- 10、数据库索引的原理，为什么要用 B+树，为什么不用二叉树？

  可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？
  为什么不是一般二叉树？
  如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。
  为什么不是平衡二叉树呢？
  我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。
  那为什么不是B树而是B+树呢？
  1）B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。
  2）B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。
  

- 11、MySQL的binlog有几种录入格式？分别有什么区别？
- 12、字段为什么要求定义为not null？
- 13、一条Sql的执行顺序？
- 14、SQL注入漏洞产生的原因？如何防止？
- 15、如何选择合适的分布式主键方案呢？
- 16、B树和B+树的区别，数据库为什么使用B+树而不是B树？
- 17、何时使用聚簇索引与非聚簇索引
- 18、你可以用什么来确保表格里的字段只接受特定范围里的值?
- 19、百万级别或以上的数据，你是如何删除的？
- 20、列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？
- 21、数据库的乐观锁和悲观锁是什么？怎么实现的？
- 22、什么是最左前缀原则？什么是最左匹配原则？
- 23、如果一个表有一列定义为TIMESTAMP，将发生什么？
- 24、说出一些数据库优化方面的经验?
- 25、select for update 含义
- 26、MyISAM索引与InnoDB索引的区别？
- 27、varchar(50)中50的涵义
- 28、完整性约束包括哪些？
- 29、索引的底层实现原理和优化
- 30、MySQL中int(20)和char(20)以及varchar(20)的区别

### 4. 面试题4

- 1、一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。

  1、 如果A表TID是自增长,并且是连续的,B表的ID为索引 select * from a,b where a.tid = b.id and a.tid>500000 limit 200;
  2、 如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。 select * from b , (select tid from a limit 50000,200) a where b.id = a .tid;
  

- 2、SQL语句优化的一些方法

  1、 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
  2、 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：
  select id from t where num is null
  -- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：
  select id from t where num=0
  3、 应尽量避免在 where 子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描。
  4、 应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：
  select id from t where num=10 or num=20
  -- 可以这样查询：
  select id from t where num=10 union all select id from t where num=20
  5、in 和 not in 也要慎用，否则会导致全表扫描，如：
  select id from t where num in(1,2,3) 
  -- 对于连续的数值，能用 between 就不要用 in 了：
  select id from t where num between 1 and 3
  6、 下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。
  7、 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：
  select id from t where num=@num
  -- 可以改为强制查询使用索引：
  select id from t with(index(索引名)) where num=@num
  8、 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：
  select id from t where num/2=100
  -- 应改为:
  select id from t where num=100*2
  9、 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：
  select id from t where substring(name,1,3)=’abc’
  -- name以abc开头的id应改为:
  select id from t where name like ‘abc%’
  10、 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
  

- 3、什么是数据库连接池?为什么需要数据库连接池呢?

  「连接池基本原理：」 数据库连接池原理：在内部对象池中，维护一定数量的数据库连接，并对外暴露数据库连接的获取和返回方法。
  「应用程序和数据库建立连接的过程：」
  1、 通过TCP协议的三次握手和数据库服务器建立连接
  2、 发送数据库用户账号密码，等待数据库验证用户身份
  3、 完成身份验证后，系统可以提交SQL语句到数据库执行
  

- 4、 把连接关闭，TCP四次挥手告别。

  「数据库连接池好处：」
  1、 资源重用 (连接复用)
  2、 更快的系统响应速度
  3、 新的资源分配手段
  4、 统一的连接管理，避免数据库连接泄漏
  4、事物的四大特性(ACID)介绍一下?
  关系性数据库需要遵循ACID规则，具体内容如下：
  ![99_6.png][99_6.png]
  1、 原子性：
  事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
  2、 一致性：
  执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
  3、 隔离性：
  并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
  4、 持久性：
  一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
  

- 5、索引分类？

  单列索引
  1、 普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。
  2、 唯一索引：索引列中的值必须是唯一的，但是允许为空值，
  3、 主键索引：是一种特殊的唯一索引，不允许有空值。
  组合索引：
  多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。
  全文索引：
  只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT    类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有"你是个靓仔，靓女 ..."   通过靓仔，可能就可以找到该条记录
  空间索引：
  空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。在创建空间索引时，使用SPATIAL关键字。要求，引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。
  

- 6、锁的优化策略

  1\、读写分离
  2\、分段加锁
  3\、减少锁持有的时间
  4\、多个线程尽量以相同的顺序去获取资源
  不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。
  

- 7、limit 1000000 加载很慢的话，你是怎么解决的呢？

  方案一：如果id是连续的，可以这样，返回上次查询的最大记录(偏移量)，再往下limit
  select id，name from employee where id>1000000 limit 10.
  方案二：在业务允许的情况下限制页数：
  建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。
  方案三：order by + 索引（id为索引）
  select id，name from employee order by id  limit 1000000，10
  方案四：利用延迟关联或者子查询优化超多分页场景。（先快速定位需要获取的id段，然后再关联）
  SELECT a.* FROM employee a, (select id from employee where 条件 LIMIT 1000000,10 ) b where a.id=b.id
  

- 8、什么是事务的隔离级别？MySQL的默认隔离级别是什么？

  为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。
  隔离级别	脏读	不可重复读	幻影读
  READ-UNCOMMITTED	√	√	√
  READ-COMMITTED	×	√	√
  REPEATABLE-READ	×	×	√
  SERIALIZABLE			
  SQL 标准定义了四个隔离级别：
  1、 READ-UNCOMMITTED(读取未提交)：
  最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
  2、 READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
  3、 REPEATABLE-READ(可重复读)：
  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
  4、 SERIALIZABLE(可串行化)：
  最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
  注意：
  1、 这里需要注意的是：MySQL 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别
  2、 事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。
  3、 因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。
  4、 InnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。
  

- 9、视图的使用场景有哪些？

  视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构
  下面是视图的常见使用场景：
  1、 重用SQL语句；
  2、 简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；
  3、 使用表的组成部分而不是整个表；
  4、 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；
  5、 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。
  

- 10、MYSQL数据库服务器性能分析的方法命令有哪些?

  Show status, 一些值得监控的变量值：
  1、 Bytes_received和Bytes_sent 和服务器之间来往的流量。
  2、 Com_*服务器正在执行的命令。
  3、 Created_*在查询执行期限间创建的临时表和文件。
  4、 Handler_*存储引擎操作。
  5、 Select_*不同类型的联接执行计划。
  6、 Sort_*几种排序信息。
  Show profiles 是MySql用来分析当前会话SQL语句执行的资源消耗情况
  

- 11、列值为NULL时，查询是否会用到索引？
- 12、MySQL里记录货币用什么字段类型好
- 13、在高并发情况下，如何做到安全的修改同一行数据？
- 14、B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，
- 15、SQL语言包括哪几部分？每部分都有哪些操作关键字？
- 16、优化特定类型的查询语句
- 17、什么是数据库事务？
- 18、谈谈MySQL的Explain
- 19、视图的优点，缺点，讲一下？
- 20、MyISAM Static和MyISAM Dynamic有什么区别？
- 21、隔离级别与锁的关系
- 22、如何优化长难的查询语句？有实战过吗？
- 23、B+Tree的页子节点都可以存放哪些东西？
- 24、SQL语句的语法顺序：
- 25、什么是锁？
- 26、你怎么看到为表格定义的所有索引？
- 27、MySQL里记录货币用什么字段类型比较好？
- 28、数据库的乐观锁和悲观锁。
- 29、MySQL有关权限的表都有哪几个？
- 30、索引不适合哪些场景

### 5. 面试题5

- 1、NOW（）和CURRENT_DATE（）有什么区别？

  NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。
  CURRENT_DATE（）仅显示当前年份，月份和日期。
  

- 2、CHAR和VARCHAR的区别？

  1.CHAR和VARCHAR类型在存储和检索方面有所不同
  2.CHAR列长度固定为创建表时声明的长度，长度值范围是1到255
  当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。
  

- 3、主键索引与唯一索引的区别

  1、 主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。
  2、 主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。
  3、 唯一性索引列允许空值，而主键列不允许为空值。
  4、 主键列在创建时，已经默认为空值 ++ 唯一索引了。
  5、 一个表最多只能创建一个主键，但可以创建多个唯一索引。
  6、 主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。
  7、 主键可以被其他表引用为外键，而唯一索引不能。 ？
  

- 4、MySQL中有哪些不同的表格？

  共有5种类型的表格：
  1、 MyISAM
  2、 Heap
  3、 Merge
  4、 INNODB
  5、 ISAM
  

- 5、SQL的生命周期？

  1、 应用服务器与数据库服务器建立一个连接
  2、 数据库进程拿到请求sql
  3、 解析并生成执行计划，执行
  4、 读取数据到内存并进行逻辑处理
  5、 通过步骤一的连接，发送结果到客户端
  6、 关掉连接，释放资源
  

- 6、你怎么看到为表格定义的所有索引？

  索引是通过以下方式为表格定义的：
  SHOW INDEX FROM <tablename>;
  

- 7、数据库为什么使用B+树而不是B树

  1、 B树只适合随机检索，而B+树同时支持随机检索和顺序检索；
  2、 B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；
  3、 B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。
  4、 B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。
  5、 增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。
  

- 8、数据库三大范式是什么

  第一范式：每个列都不可以再拆分。
  第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。
  第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。
  在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。
  

- 9、怎么优化SQL查询语句吗

  1、 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引
  2、 用索引可以提高查询
  3、 SELECT子句中避免使用*号，尽量全部大写SQL
  4、 应尽量避免在 where 子句中对字段进行 is null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，使用 IS NOT NULL
  5、 where 子句中使用 or 来连接条件，也会导致引擎放弃使用索引而进行全表扫描
  6、 in 和 not in 也要慎用，否则会导致全表扫描
  

- 10、覆盖索引、回表等这些，了解过吗？

  1、 覆盖索引： 查询列要被所建的索引覆盖，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。
  2、 回表：二级索引无法直接查询所有列的数据，所以通过二级索引查询到聚簇索引后，再查询到想要的数据，这种通过二级索引查询出来的过程，就叫做回表。
  

	- MySQL覆盖索引与回表

- 11、NULL是什么意思
- 12、MySQL中in 和exists的区别。
- 13、500台db，在最快时间之内重启。
- 14、MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？
- 15、NOW（）和CURRENT_DATE（）有什么区别？
- 16、超键、候选键、主键、外键分别是什么？
- 17、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？
- 18、为什么要使用视图？什么是视图？
- 19、索引的一些潜规则
- 20、myisamchk是用来做什么的？
- 21、如何在Unix和MySQL时间戳之间进行转换？
- 22、什么是索引？
- 23、日常工作中你是怎么优化SQL的？
- 24、MYSQL的主从延迟，你怎么解决？
- 25、索引的底层实现
- 26、SQL语言包括哪几部分？每部分都有哪些操作关键字？
- 27、500台db，在最快时间之内重启。
- 28、MySQL中TEXT数据类型的最大长度
- 29、数据库存储日期格式时，如何考虑时区转换问题？

## 第4章 MyBatis

### 1. MyBatis面试题

- 1、Hibernate 和 MyBatis 的区别

  相同点
  都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。
  不同点
  映射关系
  MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单
  Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂
  SQL优化和移植性
  Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。
  MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。
  

- 2、Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？

  第一种是使用标签，逐一定义列名和对象属性名之间的映射关系。
  第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对
  象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能
  找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工
  作。
  有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性
  逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。
  

- 3、Mybatis编程步骤 ？

  1、 创建SQLSessionFactory
  2、 通过SQLSessionFactory创建SQLSession
  3、 通过SQLSession执行数据库操作
  4、 调用session.commit()提交事物 Step5：调用session.close()关闭会话
  

- 4、Mapper 编写有哪几种方式？

  第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口，mapper 接口实现类、mapper.xml 文件
  1、 在 sqlMapConfig.xml 中配置 mapper.xml 的位置
  <mappers>
      <mapper resource="mapper.xml 文件的地址" />
      <mapper resource="mapper.xml 文件的地址" />
  </mappers>
  2、 定义 mapper 接口
  3、 实现类集成 SqlSessionDaoSupport
  mapper 方法中可以 this.getSqlSession()进行数据增删改查。
  4、 spring 配置
  <bean id=" " class="mapper 接口的实现">
      <property name="sqlSessionFactory"
      ref="sqlSessionFactory"></property>
  </bean>
  第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：
  1、 在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和mappre 接口的名称相同且在同一个目录，这里可以不用配置
  2、 定义 mapper 接口：
  <mappers>
      <mapper resource="mapper.xml 文件的地址" />
      <mapper resource="mapper.xml 文件的地址" />
  </mappers>
  3、 mapper.xml 中的 namespace 为 mapper 接口的地址
  4、 mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致
  5、 Spring 中定义
  <bean id="" class="org.mybatis.spring.mapper.MapperFactoryBean">
      <property name="mapperInterface" value="mapper 接口地址" />
      <property name="sqlSessionFactory" ref="sqlSessionFactory" />
  </bean>
  第三种：使用 mapper 扫描器：
  1、 mapper.xml 文件编写：
  mapper.xml 中的 namespace 为 mapper 接口的地址；
  mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；
  如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml中进行配置。
  2、 定义 mapper 接口：
  注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录
  3、 配置 mapper 扫描器：
  <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
      <property name="basePackage" value="mapper 接口包地址
      "></property>
      <property name="sqlSessionFactoryBeanName"
      value="sqlSessionFactory"/>
  </bean>
  4、 使用扫描器后从 spring 容器中获取 mapper 的实现对象。
  

- 5、Mybatis 是否可以映射 Enum 枚举类？

  Mybatis 可以映射枚举类，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一
  列上。映射方式为自定义一个 TypeHandler，实现 TypeHandler 的 setParameter()和
  getResult()接口方法。TypeHandler 有两个作用，一是完成从 javaType 至 jdbcType 的转换，
  二是完成 jdbcType 至 javaType 的转换，体现为 setParameter()和 getResult()两个方法，分别
  代表设置 sql 问号占位符参数和获取列查询结果。
  

- 6、Mybatis是如何进行分页的？分页插件的原理是什么？

  Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。
  分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。
  举例：
  select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10
  

- 7、Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？

  1、 Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association
  指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否
  启用延迟加载 lazyLoadingEnabled=true|false。
  2、 它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方
  法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单
  独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的
  对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原
  理。
  

- 8、什么是 MyBatis 的接口绑定,有什么好处？

  接口映射就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑定,我们
  直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选
  择和设置.
  

- 9、Mybatis中如何指定使用哪一种Executor执行器？

  在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。
  配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。
  

- 10、在mapper中如何传递多个参数?

  1、 第一种：
  DAO层的函数
  public UserselectUser(String name,String area);
          对应的xml,#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数一致往后加即可。
  <select id="selectUser"resultMap="BaseResultMap">
      select *  fromuser_user_t   whereuser_name = #{0} anduser_area=#{1}
  </select>
  2、 第二种： 使用 @param 注解:
  public interface usermapper {
      user selectuser(@param(“username”) string username,@param(“hashedpassword”) string hashedpassword);
  }
  然后,就可以在xml像下面这样使用(推荐封装为一个map,作为单个参数传递给mapper):
  <select id=”selectuser” resulttype=”user”>
          select id, username, hashedpassword
          from some_table
          where username = #{username}
          and hashedpassword = #{hashedpassword}
          </select>
  3、 第三种：多个参数封装成map
  try {
          //映射文件的命名空间.SQL片段的ID，就可以调用对应的映射文件中的SQL
          //由于我们的参数超过了两个，而方法中只有一个Object参数收集，因此我们使用Map集合来装载我们的参数
          Map < String, Object > map = new HashMap();
          map.put("start", start);
          map.put("end", end);
          return sqlSession.selectList("StudentID.pagination", map);
          } catch (Exception e) {
          e.printStackTrace();
          sqlSession.rollback();
          throw e;
          } finally {
          MybatisUtil.closeSqlSession();
          }
  

- 11、传统JDBC开发存在什么问题？
- 12、MyBatis 实现一对一有几种方式?具体怎么操作的？
- 13、MyBatis的功能架构是怎样的
- 14、#{}和${}的区别
- 15、IBatis 和 MyBatis 在核心处理类分别叫什么？
- 16、Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？
- 17、Mybatis的编程步骤是什么样的？
- 18、MyBatis框架适用场合：
- 19、Mybatis映射文件中，如果A标签通过include引用了B标签的内容
- 20、Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？
- 21、MyBatis 的好处是什么？
- 22、使用MyBatis的mapper接口调用时有哪些要求？
- 23、#{}和${}的区别是什么？
- 24、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？
- 25、JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？

## 第5章 Spring

## 第6章 SpringBoot

## 第7章 SpringCloud

*XMind - Trial Version*