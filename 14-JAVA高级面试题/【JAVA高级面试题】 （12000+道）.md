# 【JAVA高级面试题】
（12000+道）

## 第1章 JAVA相关面试题（300道）

### 1. JAVA面试题1

- 1、创建socket通讯的步骤？

	- 1、 服务器程序创建一个ServerSocket，然后再用accept方法等待客户来连接
	- 2、 客户端程序创建一个Socket并请求与服务器建立连接
	- 3、 服务器接收客户的连接请求,并创建一个新的Socket与该客户建立专线连接
	- 4、 刚才建立了连接的两个Socket在一个线程上对话
	- 5、 服务器开始等待新的连接请求

- 2、Java 中 sleep 方法和 wait 方法的区别？

	- 虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。

- 3、程序计数器(线程私有)

	- 一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有” 的内存。
	- 正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址） 。如果还是 Native 方法，则为空。
	- 这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。

- 4、什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？

	- 线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。

- 5、迭代器 Iterator 是什么？

	- Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。
	- 因为所有Collection接继承了Iterator迭代器

- 6、线程的 sleep()方法和 yield()方法有什么区别？

	- 1、 sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
	- 2、 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；
	- 3、 sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；
	- 4、 sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。

- 7、Java 中能创建 volatile 数组吗？

	- 能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。

- 8、java中equals方法的用法以及==的用法
- 9、如何创建一个json对象？

	- 使用{}实例化一个json对象，json对象多个元素使用逗号隔开，每个元素都是一个键值对

- 10、如何判断对象是否是垃圾？

	- **引用计数：**在对象中添加一个引用计数器，如果被引用计数器加 1，引用失效时计数器减 1，如果计数器为 0 则被标记为垃圾。原理简单，效率高，但是在 Java 中很少使用，因为存在对象间循环引用的问题，导致计数器无法清零。
	- **可达性分析：**主流语言的内存管理都使用可达性分析判断对象是否存活。基本思路是通过一系列称为 GC Roots 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为引用链，如果某个对象到 GC Roots 没有任何引用链相连，则会被标记为垃圾。可作为 GC Roots 的对象包括虚拟机栈和本地方法栈中引用的对象、类静态属性引用的对象、常量引用的对象。

- 11、GC是什么？为什么要有GC？
- 12、线程池四种创建方式？
- 13、形成死锁的四个必要条件是什么
- 14、java 面向对象编程三大特性------封装、继承、多态
- 15、什么是IoC和DI？DI是如何实现的？
- 16、假设数组内有5个元素，如果对数组进行反序，该如何做？
- 17、Java的内存模型是什么？（JMM是什么？）
- 18、什么时候用断言（assert）？
- 19、对象在哪块内存分配？
- 20、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？
- 21、怎么将 byte 转换为 String？
- 22、Swing 是线程安全的？
- 23、线程B怎么知道线程A修改了变量
- 24、notify() 和 notifyAll() 有什么区别？
- 25、Java 中的 LinkedList 是单向链表还是双向链表？
- 26、Java中垃圾回收有什么目的？什么时候进行垃圾回收？
- 27、你对线程优先级的理解是什么？
- 28、JVM内存模型
- 29、解释servlet如何完成生命周期?
- 30、Java中是如何支持正则表达式操作的？
- 31、接口有什么特点？
- 32、什么是过滤器？怎么创建一个过滤器
- 33、在 Java 程序中怎么保证多线程的运行安全？
- 34、直接内存是什么？
- 35、Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型
- 36、解释何时在Tomcat使用SSL ?
- 37、堆（Heap-线程共享） -运行时数据区
- 38、SWAP会影响性能么？
- 39、什么是方法内联？
- 40、谈一谈Hibernate的一级缓存、二级缓存和查询缓存。

### 2. JAVA面试题2

- 1、抽象工厂模式和原型模式之间的区别？

	- 抽象工厂模式：通常由工厂方法模式来实现。但一个工厂中往往含有多个工厂方法生成一系列的产品。这个模式强调的是客户代码一次保证只使用一个系列的产品。当要切换为另一个系列的产品，换一个工厂类即可。
	- 原型模式：工厂方法的最大缺点就是，对应一个继承体系的产品类，要有一个同样复杂的工厂类的继承体系。我们可以把工厂类中的工厂方法放到产品类自身之中吗？如果这样的话，就可以将两个继承体系为一个。这也就是原型模式的思想，原型模式中的工厂方法为clone，它会返回一个拷贝（可以是浅拷贝，也可以是深拷贝，由设计者决定）。为了保证用户代码中到时可以通过指针调用clone来动态绑定地生成所需的具体的类。这些原型对象必须事先构造好。
	- 原型模式想对工厂方法模式的另一个好处是，拷贝的效率一般对构造的效率要高。

- 2、在 Java 程序中怎么保证多线程的运行安全？

	- 出现线程安全问题的原因一般都是三个原因：
	- 1、 线程切换带来的原子性问题 解决办法：使用多线程之间同步synchronized或使用锁(lock)。
	- 2、 缓存导致的可见性问题 解决办法：synchronized、volatile、LOCK，可以解决可见性问题
	- 3、 编译优化带来的有序性问题 解决办法：Happens-Before 规则可以解决有序性问题

- 3、volatile 修饰符的有过什么实践？

	- 一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。

- 4、Java中各种数据默认值

	- 1、 Byte,short,int,long默认是都是0
	- 2、 Boolean默认值是false
	- 3、 Char类型的默认值是’’
	- 4、 Float与double类型的默认是0.0
	- 5、 对象类型的默认值是null

- 5、说说Java 垃圾回收机制

	- 在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

- 6、有没有可能两个不相等的对象有有相同的 hashcode？

	- 有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。

- 7、synchronized 和 Lock 有什么区别？

	- 1、 首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；
	- 2、 synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。
	- 3、 synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。
	- 4、 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。

- 8、什么是Vector

	- Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，访问它比访问ArrayList慢很多
	- ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。ArrayList的缺点是每个元素之间不能有间隔。

- 9、对象的访问定位有哪几种方式?

	- 建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针2种：
	- 句柄：如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
	- 直接指针：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。
	- 这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

- 10、equals 和 == 的区别？#

	- 通俗点讲：是看看左右是不是一个东西。equals是看看左右是不是长得一样。如何记住嘛。如果单纯是想记住，：等于。equals：相同。两个长得一样的人，只能说长的相同(equals)，但是不等于他们俩是一个人。你只要记住equals，==就不用记了。
	- 术语来讲的区别：
	- 1、 ==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同
	- 2、 ==是指对内存地址进行比较 equals()是对字符串的内容进行比较3.==指引用是否相同 equals()指的是值是否相同

- 11、Servlet中如何获取用户提交的查询参数或表单数据？
- 12、堆溢出的原因？
- 13、Java 中，怎么获取一个文件中单词出现的最高频率？
- 14、你知道哪些JVM性能调优
- 15、抽象类必须要有抽象方法吗？
- 16、串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？
- 17、React的请求应该放在哪个生命周期中?
- 18、volatile关键字的作用
- 19、我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？
- 20、什么是Java虚拟机
- 21、CMS 收集器（多线程标记清除算法）
- 22、接口和抽象类的区别是什么？
- 23、如何合理分配线程池大小?
- 24、什么是线程组，为什么在Java中不推荐使用？
- 25、类加载器
- 26、JVM 如何确定垃圾对象？
- 27、字符型常量和字符串常量的区别
- 28、G1 收集器
- 29、Java 中，直接缓冲区与非直接缓冲器有什么区别？
- 30、如何决定使用 HashMap 还是 TreeMap？
- 31、说一下 ArrayList 的优缺点
- 32、构造方法能不能重写？能不能重载？
- 33、什么是红黑树
- 34、什么是逃逸分析？
- 35、栈帧里面包含哪些东西？
- 36、Tomcat是怎么打破双亲委派机制的呢？
- 37、WeakHashMap 是怎么工作的？
- 38、java 中操作字符串都有哪些类？它们之间有什么区别？
- 39、什么是JVM？java虚拟机包括什么？
- 40、Java 的引用有哪些类型？

### 3. JAVA面试题3

- 1、什么是ThreadPoolExecutor？

  ThreadPoolExecutor就是线程池
  ThreadPoolExecutor其实也是JAVA的一个类，我们一般通过Executors工厂类的方法，通过传入不同的参数，就可以构造出适用于不同应用场景下的ThreadPoolExecutor（线程池）
  构造参数图：
  构造参数参数介绍：
  corePoolSize 核心线程数量
  maximumPoolSize 最大线程数量
  keepAliveTime 线程保持时间，N个时间单位
  unit 时间单位（比如秒，分）
  workQueue 阻塞队列
  threadFactory 线程工厂
  handler 线程池拒绝策略
  

- 2、invokedynamic 指令是干什么的？

  Java 7 开始，新引入的字节码指令，可以实现一些动态类型语言的功能。Java 8 的 Lambda 表达式就是通过 invokedynamic 指令实现，使用方法句柄实现。
  

- 3、synchronized、volatile、CAS 比较

  1、 synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。
  2、 volatile 提供多线程共享变量可见性和禁止指令重排序优化。
  3、 CAS 是基于冲突检测的乐观锁（非阻塞）
  4、Iterator 怎么使用？有什么特点？
  Iterator 使用代码如下：
  List<String> list = new ArrayList<>();
  Iterator<String> it = list、iterator();
  while(it、hasNext()){
    String obj = it、next();
    System、out、println(obj);
  }
  Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。
  

- 5、被引用的对象就一定能存活吗？

  不一定，看 Reference 类型，弱引用在 GC 时会被回收，软引用在内存不足的时候，即 OOM 前会被回收，但如果没有在 Reference Chain 中的对象就一定会被回收。
  

- 6、列出一些你常见的运行时异常？

  1、 ArithmeticException（算术异常）
  2、 ClassCastException （类转换异常）
  3、 IllegalArgumentException （非法参数异常）
  4、 IndexOutOfBoundsException （下标越界异常）
  5、 NullPointerException （空指针异常）
  6、 SecurityException （安全异常）
  

- 7、Servlet生命周期内调用的方法过程？

  1、 Init()
  2、 Service()
  3、 doGet或者doPost
  4、 destroy
  

- 8、阐述静态变量和实例变量的区别。

  静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。
  补充：在Java开发中，上下文类和工具类中通常会有大量的静态成员。
  

- 9、类加载器双亲委派模型机制？

  基本定义：
  双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器没有找到所需的类时，子加载器才会尝试去加载该类。
  双亲委派机制:
  1、 当 AppClassLoader 加载一个 class 时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器 ExtClassLoader 去完成。
  2、 当 ExtClassLoader 加载一个 class 时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给 BootStrapClassLoader 去完成。
  3、 如果 BootStrapClassLoader 加载失败，会使用 ExtClassLoader 来尝试加载；
  4、 若 ExtClassLoader 也加载失败，则会使用 AppClassLoader 来加载，如果 AppClassLoader 也加载失败，则会报出异常 ClassNotFoundException。
  如下图所示：
  双亲委派作用：
  1、 通过带有优先级的层级关可以避免类的重复加载；
  2、 保证 Java 程序安全稳定运行，Java 核心 API 定义类型不会被随意替换。
  

- 10、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？

  都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。
  

- 11、老年代
- 12、如何停止一个正在运行的线程？
- 13、常用JVM基本配置参数
- 14、线程池都有哪些状态？
- 15、怎么确保一个集合不能被修改？
- 16、怎么检测一个线程是否拥有锁？
- 17、启动一个线程是调用run()还是start()方法？
- 18、React组件通信如何实现?
- 19、Java 中 WeakReference 与 SoftReference的区别？
- 20、常用并发列队的介绍：
- 21、什么是数据结构？
- 22、遇到过堆外内存溢出吗？
- 23、会话跟踪技术有那些？
- 24、抽象类和接口的区别?
- 25、Java中用到的线程调度算法是什么？
- 26、如何使session失效
- 27、存储过程与函数的区别
- 28、Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？
- 29、用Java写一个折半查找。
- 30、对象都是优先分配在年轻代上的吗？
- 31、本地方法区(线程私有)
- 32、单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！”
- 33、JVM 有哪些运行时内存区域？
- 34、为什么Thread类的sleep()和yield ()方法是静态的？
- 35、如何用Java代码列出一个目录下所有的文件？
- 36、Java中notify 和 notifyAll有什么区别？
- 37、为什么使用Executor框架？
- 38、如何判断两个类是否相等？
- 39、虚拟DOM实现原理?
- 40、a = a + b 与 a += b 的区别

### 4. JAVA面试题4

- 1、如何判断一个对象是否存活

  判断一个对象是否存活有两种方法：
  1、 引用计数法
  所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收、
  引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，对象 B 又引用者对象 A，那么此时 A、B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。
  2、 可达性算法（引用链法）
  该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。
  在 Java 中可以作为 GC Roots 的对象有以下几种：
  1、 虚拟机栈中引用的对象
  2、 方法区类静态属性引用的对象
  3、 方法区常量池引用的对象
  4、 本地方法栈JNI引用的对象
  虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记、
  如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法或者已被虚拟机调用过，那么就认为是没必要的。 如果该对象有必要执行 finalize() 方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize() 线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize() 执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除” 即将回收” 集合，等待回收。
  

- 2、Int与integer的区别

  Integer是int的包装类型。
  Int的默认值是0，integer的默认值是null
  

- 3、Servlet的生命周期？

  1、 加载：判断servlet实例是否存在，如果不存在，就加载serlvet
  2、 实例化：
  3、 初始化
  4、服务
  5、销毁
  

- 4、怎么唤醒一个阻塞的线程

  如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。
  

- 5、虚拟DOM的优劣如何?

  优点:
  1、 保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限
  2、 无需手动操作DOM: 虚拟DOM的diff和patch都是在一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率
  3、 跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等
  缺点:
  无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化,比如VScode采用直接手动操作DOM的方式进行极端的性能优化
  

- 6、双亲委派模型是什么？

  类加载器具有等级制度但非继承关系，以组合的方式复用父加载器的功能。双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应该有自己的父加载器。
  一个类加载器收到了类加载请求，它不会自己去尝试加载，而将该请求委派给父加载器，每层的类加载器都是如此，因此所有加载请求最终都应该传送到启动类加载器，只有当父加载器反馈无法完成请求时，子加载器才会尝试。
  类跟随它的加载器一起具备了有优先级的层次关系，确保某个类在各个类加载器环境中都是同一个，保证程序的稳定性。
  

- 7、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？
- 8、如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？

  1、 不会，在下一个垃圾回调周期中，这个对象将是被可回收的。
  2、 也就是说并不会立即被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。
  

- 9、JVM 出现 fullGC 很频繁，怎么去线上排查问题

  这题就依据full GC的触发条件来做：
  1、 如果有perm gen的话(jdk1.8就没了)，要给perm gen分配空间，但没有足够的空间时，会触发full gc。
  2、 所以看看是不是perm gen区的值设置得太小了。
  3、 System.gc()方法的调用
  4、 这个一般没人去调用吧~~~
  5、 当统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间，则会触发full gc(这就可以从多个角度上看了)
  6、 是不是频繁创建了大对象(也有可能eden区设置过小)(大对象直接分配在老年代中，导致老年代空间不足--->从而频繁gc)
  7、 是不是老年代的空间设置过小了(Minor GC几个对象就大于老年代的剩余空间了)
  

- 10、JVM 内存区域

  JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。
  线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。
  线程共享区域随虚拟机的启动/关闭而创建/销毁。
  直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于Channel与 Buffer的IO方式, 它可以使用Native函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。
  

- 11、原型模式的使用方式
- 12、简述一下你了解的设计模式。
- 13、Java中有几种类型的流？
- 14、Try.catch.finally是必须要存在的吗？
- 15、你熟悉哪些垃圾收集算法？
- 16、为什么HashTable是线程安全的？
- 17、finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？
- 18、用最有效率的方法计算2乘以8？
- 19、多线程应用场景
- 20、List 和 Set 的区别
- 21、实现可见性的方法有哪些？
- 22、堆
- 23、什么是JDK?什么是JRE？
- 24、在 Java 中，对象什么时候可以被垃圾回收？
- 25、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?
- 26、如何将字符串反转？
- 27、如何通过反射获取和设置对象私有字段的值？
- 28、并发队列的常用方法
- 29、Set接口有什么特点
- 30、说说你知道的几种主要的JVM参数
- 31、“a==b”和”a.equals(b)”有什么区别？
- 32、什么是并发队列：
- 33、Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？
- 34、Linux环境下如何查找哪个线程使用CPU最长
- 35、并发编程三要素？
- 36、四种线程池的创建：
- 37、说说CMS垃圾收集器的工作原理
- 38、请解释如何配置Tomcat来使用IIS和NTLM ?
- 39、线程的sleep()方法和yield()方法有什么区别？
- 40、JAVA弱引用
- 41、方法区

### 5. JAVA面试题5

- 1、Parallel Old 收集器（多线程标记整理算法）

  Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6才开始提供。
  在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量， Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器， 如果系统对吞吐量要求比较高，可以优先考虑新生代Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。
  

- 2、对象分配内存是否线程安全？

  对象创建十分频繁，即使修改一个指针的位置在并发下也不是线程安全的，可能正给对象 A 分配内存，指针还没来得及修改，对象 B 又使用了指针来分配内存。
  解决方法：① CAS 加失败重试保证更新原子性。② 把内存分配按线程划分在不同空间，即每个线程在 Java 堆中预先分配一小块内存，叫做本地线程分配缓冲 TLAB，哪个线程要分配内存就在对应的 TLAB 分配，TLAB 用完了再进行同步。
  

- 3、当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？

  如果其他方法没有synchronized的话，其他线程是可以进入的。
  所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。
  

- 4、Serial 与 Parallel GC 之间的不同之处？

  Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而parallel 收集器使用多个 GC 线程来执行。
  

- 5、为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？

  因为Java所有类的都继承了Object，Java想让任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。
  有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。
  

- 6、redux异步中间件之间的优劣?

  redux-thunk优点:
  1、 体积小: redux-thunk的实现方式很简单,只有不到20行代码
  2、 使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简单
  redux-thunk缺陷:
  1、 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
  2、 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
  3、 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
  redux-saga优点:
  1、 异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中
  2、 action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满 “黑魔法” thunk function
  3、 异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过 try/catch 语法直接捕获处理
  4、 功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者无须封装或者简单封装即可使用
  5、 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
  6、 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
  redux-saga缺陷:
  1、 额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
  2、 体积庞大: 体积略大,代码近2000行，min版25KB左右
  3、 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
  4、 ts支持不友好: yield无法返回TS类型
  redux-observable优点:
  1、 功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你能想到的异步处理
  2、 背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而且随着rxjs的升级redux-observable也会变得更强大
  redux-observable缺陷:
  1、 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
  2、 社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步流中间件这个层面redux-saga仍处于领导地位
  关于redux-saga与redux-observable的详细比较可见此链接
  

- 7、类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？

  双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。
  1、 假设有一个开发者自己编写了一个名为java.lang.Object的类，想借此欺骗JVM。现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类。
  2、 然而幸运的是，双亲委托模型不会让他成功。因为JVM会优先在Bootstrap ClassLoader的路径下找到java.lang.Object类，并载入它
  Java的类加载是否一定遵循双亲委托模型？
  1、 在实际开发中，我们可以通过自定义ClassLoader，并重写父类的loadClass方法，来打破这一机制。
  2、 SPI就是打破了双亲委托机制的(SPI：服务提供发现)。
  

- 8、Hibernate中Session的load和get方法的区别是什么？

  如果没有找到符合条件的记录，get方法返回null，load方法抛出异常。
  get方法直接返回实体类对象，load方法返回实体类对象的代理。
  在Hibernate 3之前，get方法只在一级缓存中进行数据查找，如果没有找到对应的数据则越过二级缓存，直接发出SQL语句完成数据读取；load方法则可以从二级缓存中获取数据；从Hibernate 3开始，get方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。
  

- 9、说一下堆内存中对象的分配的基本策略

  eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区->Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。另外，大对象和长期存活的对象会直接进入老年代。
  

- 10、Java 中如何将字符串转换为整数？

  String s="123";
  int i;
  第一种方法：i=Integer.parseInt(s);
  第二种方法：i=Integer.valueOf(s).intValue();
  

- 11、Tcp协议的特点
- 12、如何在两个线程间共享数据？
- 13、java中有没有指针？
- 14、什么是多线程
- 15、a.hashCode() 有什么用？与 a.equals(b) 有什么关系？
- 16、堆和栈的区别
- 17、JDBC能否处理Blob和Clob？
- 18、什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？
- 19、简述一下面向对象的”六原则一法则”。
- 20、MinorGC，MajorGC、FullGC都什么时候发生？
- 21、JVM 运行时内存
- 22、如何自定义一个异常
- 23、synchronized、volatile、CAS比较
- 24、JVM有哪些内存区域？(JVM的内存布局是什么？)
- 25、强引用、软引用、弱引用、虚引用是什么？
- 26、Java 中垃圾收集的方法有哪些
- 27、CMS都有哪些问题？
- 28、redux中如何进行异步操作?
- 29、什么是多线程的上下文切换
- 30、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？
- 31、谈谈你知道的垃圾回收算法
- 32、重载与重写
- 33、Java 线程数过多会造成什么异常？
- 34、Java 中 ++ 操作符是线程安全的吗？
- 35、三种代理的区别
- 36、在不使用 StringBuffer 的前提下，怎么反转一个字符串？
- 37、什么叫线程安全？servlet 是线程安全吗?
- 38、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？
- 39、如果你提交任务时，线程池队列已满，这时会发生什么
- 40、什么情况下会发生栈溢出？
- 41、死锁与活锁的区别，死锁与饥饿的区别？

### 6. JAVA面试题6

- 1、讲讲什么情况下会出现内存溢出，内存泄漏？

  解决这个内存泄漏问题也很简单，将set设置为null，那就可以避免上述内存泄漏问题了。其他内存泄漏得一步一步分析了。
  内存溢出的原因：
  1、 内存泄露导致堆栈内存不断增大，从而引发内存溢出。
  2、 大量的jar，class文件加载，装载类的空间不够，溢出
  3、 操作大量的对象导致堆内存空间已经用满了，溢出
  4、 nio直接操作内存，内存过大导致溢出
  解决：
  1、 查看程序是否存在内存泄漏的问题
  2、 设置参数加大空间
  3、 代码中是否存在死循环或循环产生过多重复的对象实体、
  4、 查看是否使用了nio直接操作内存。
  

- 2、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？

  悲观锁：
  总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。
  乐观锁：
  顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。
  

- 3、线程与进程的区别？

  进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。
  一个程序至少有一个进程,一个进程至少有一个线程。
  

- 4、Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？

  瞬时态的实例可以通过调用save()、persist()或者saveOrUpdate()方法变成持久态；游离态的实例可以通过调用 update()、saveOrUpdate()、lock()或者replicate()变成持久态。save()和persist()将会引发SQL的INSERT语句，而update()或merge()会引发UPDATE语句。save()和update()的区别在于一个是将瞬时态对象变成持久态，一个是将游离态对象变为持久态。merge()方法可以完成save()和update()方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。
  对于persist()方法，
  persist()方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到flush的时间；
  persist()方法保证当它在一个事务外部被调用的时候并不触发一个INSERT语句，当需要封装一个长会话流程的时候，persist()方法是很有必要的；
  save()方法不保证第②条，它要返回标识符，所以它会立即执行INSERT语句，不管是在事务内部还是外部。至于lock()方法和update()方法的区别，update()方法是把一个已经更改过的脱管状态的对象变成持久状态；lock()方法是把一个没有更改过的脱管状态的对象变成持久状态。
  

- 5、用代码演示三种代理
- 6、stackoverflow错误，permgen space错误

  stackoverflow错误主要出现：
  在虚拟机栈中(线程请求的栈深度大于虚拟机栈锁允许的最大深度)
  permgen space错误(针对jdk之前1.7版本)：
  1、 大量加载class文件
  2、 常量池内存溢出
  

- 7、分代收集算法

  当前主流 VM 垃圾收集都采用”分代收集” (Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如 JVM 中的新生代、老年代、永久代， 这样就可以根据各年代特点分别采用最适当的 GC 算法
  

- 8、同步方法和同步块，哪个是更好的选择？

  同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。
  同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。
  请知道一条原则：同步的范围越小越好。
  

- 9、Java 中的编译期常量是什么？使用它又什么风险？

  公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。
  

- 10、Java死锁以及如何避免？

  Java中的死锁是一种编程情况，其中两个或多个线程被永久阻塞，Java死锁情况出现至少两个线程和两个或更多资源。
  Java发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。
  

- 11、为什么 Thread 类的 sleep()和 yield ()方法是静态的？
- 12、Java都有那些开发平台？
- 13、Java 中能创建 volatile 数组吗？
- 14、线程 B 怎么知道线程 A 修改了变量
- 15、GC日志的real、user、sys是什么意思？
- 16、你说你做过JVM参数调优和参数配置，请问如何查看JVM系统默认值
- 17、什么是ORM？
- 18、串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？
- 19、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用
- 20、Java对象创建过程
- 21、java 中 IO 流分为几种？
- 22、在Java中Executor和Executors的区别？
- 23、说说 JVM 如何执行 class 中的字节码。
- 24、构造方法有哪些特性？
- 25、final不可变对象，它对写并发应用有什么帮助？
- 26、Java中操作字符串使用哪个类？
- 27、在 Java 程序中怎么保证多线程的运行安全？
- 28、JIT是什么？
- 29、类加载有几个过程？
- 30、JSP中的静态包含和动态包含有什么区别？
- 31、线程池的优点？
- 32、Java 中，怎么在格式化的日期中显示时区？
- 33、什么是原型模式
- 34、Javascript中常用的事件有哪些？
- 35、32 位和 64 位的 JVM，int 类型变量的长度是多数？
- 36、常用的并发工具类有哪些？
- 37、什么是不可变对象，它对写并发应用有什么帮助？
- 38、单例模式的线程安全性
- 39、什么是阻塞式方法？
- 40、调优工具
- 41、创建线程的三种方式的对比？

### 7. JAVA面试题7

- 1、String 属于基础的数据类型吗？

  String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。
  

- 2、如何实现对象克隆？
- 3、Java最顶级的父类是哪个？

  Object
  

- 4、如何通过反射创建对象？

  1、 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance()
  2、 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”);
  

- 5、Java 中堆和栈有什么区别？

  JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。
  

- 6、volatile 能使得一个非原子操作变成原子操作吗？

  1、 关键字volatile的主要作用是使变量在多个线程间可见，但无法保证原子性，对于多个线程访问同一个实例变量需要加锁进行同步。
  2、 虽然volatile只能保证可见性不能保证原子性，但用volatile修饰long和double可以保证其操作原子性。
  所以从Oracle Java Spec里面可以看到：
  1、 对于64位的long和double，如果没有被volatile修饰，那么对其操作可以不是原子的。在操作的时候，可以分成两步，每次对32位操作。
  2、 如果使用volatile修饰long和double，那么其读写都是原子操作
  3、 对于64位的引用地址的读写，都是原子操作
  4、 在实现JVM时，可以自由选择是否把读写long和double作为原子操作
  5、 推荐JVM实现为原子操作
  

- 7、为什么选择使用框架而不是原生?

  框架的好处:
  1、 组件化: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。
  2、 天然分层: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。
  3、 生态: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案。
  4、 开发效率: 现代前端框架都默认自动更新DOM,而非我们手动操作,解放了开发者的手动DOM成本,提高开发效率,从根本上解决了UI 与状态同步问题.
  

- 8、你能写出一个正则表达式来判断一个字符串是否是一个数字吗？
- 9、运行时栈帧包含哪些结构？

  1、 局部变量表
  2、 操作数栈
  3、 动态连接
  4、 返回地址
  5、 附加信息
  

- 10、什么是Java程序的主类？应用程序和小程序的主类有何不同？

  一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main（）方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。
  

- 11、什么是模板方法模式？
- 12、Java 中应该使用什么数据类型来代表价格？
- 13、本地方法栈
- 14、静态方法和实例方法有何不同？
- 15、JAVA虚引用
- 16、Java应用程序与小程序之间有那些差别？
- 17、sleep方法和wait方法有什么区别?
- 18、普通类与抽象类有什么区别？
- 19、现实生活中的模板方法
- 20、一个线程运行时发生异常会怎样？
- 21、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？
- 22、Java 中怎么创建 ByteBuffer？
- 23、Json是什么？
- 24、JVM调优命令有哪些？
- 25、集合的特点
- 26、Java内存模型
- 27、什么是线程同步和线程互斥，有哪几种实现方式？
- 28、Java 中，throw 和 throws 有什么区别
- 29、运行时常量池溢出的原因？
- 30、假如生产环境CPU占用过高，请谈谈你的分析思路和定位。
- 31、Java的双亲委托机制是什么？
- 32、什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？
- 33、char 型变量中能不能存贮一个中文汉字，为什么？
- 34、84.Map有什么特点
- 35、监听器有哪些作用和用法？
- 36、final 在 java 中有什么作用？
- 37、Minor GC与Full GC分别在什么时候发生？
- 38、Minor Gc和Full GC 有什么不同呢？
- 39、Java 中，怎样才能打印出数组中的重复元素？
- 40、一个java类中包含那些内容？

### 8. JAVA面试题8

- 1、volatile 关键字的作用

  1、 对于可见性，Java 提供了 volatile 关键字来保证可见性和禁止指令重排。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile修饰时，它会保证修改的值会立即被更新到主内存中，当有其他线程需要读取时，它会去内存中读取新值。
  2、 从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 AtomicInteger。
  3、 volatile 常用于多线程环境下的单次操作(单次读或者单次写)。
  

- 2、Java 中用到的线程调度算法是什么？

  计算机通常只有一个 CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU 的使用权才能执行指令。所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。在运行池中，会有多个处于就绪状态的线程在等待 CPU，JAVA 虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配 CPU 的使用权。（Java是由JVM中的线程计数器来实现线程调度）
  有两种调度模型：
  分时调度模型和抢占式调度模型。
  1、 分时调度模型是指让所有的线程轮流获得 cpu 的使用权，并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。
  2、 Java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。
  

- 3、简单描述一下（分代）垃圾回收的过程

  分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。
  新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：
  当年轻代中的Eden区分配满的时候，就会触发年轻代的GC（Minor GC）。具体过程如下：
  1、 在Eden区执行了 第一次GC之后，存活的对象会被移动到其中一个Survivor分区（以下简称from）
  2、 Eden区再次GC，这时会采用复制算法，将Eden和from区一起清理。存活的对象会被复制到to区。接下来，只需要清空from区就可以了
  

- 4、什么是可重入锁（ReentrantLock）？
- 5、线程池有什么优点？

  1、 降低资源消耗：重用存在的线程，减少对象创建销毁的开销。
  2、 提高响应速度。可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
  3、 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
  4、 附加功能：提供定时执行、定期执行、单线程、并发数控制等功能。
  

- 6、你有哪些手段来排查 OOM 的问题？

  1、 增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录
  2、 同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域
  3、 使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用
  

- 7、什么是线程异步？什么是线程同步？

  1、 线程同步：同时只有一条线程执行一个任务
  2、 线程异步：同时有多条线程可以执行执行任务
  

- 8、Java 中，受检查异常 和 不受检查异常的区别？

  受检查异常编译器在编译期间检查。对于这种异常，方法强制处理或者通过 throws 子句声明。其中一种情况是 Exception 的子类但不是 RuntimeException 的子类。非受检查是 RuntimeException 的子类，在编译阶段不受编译器的检查。
  

- 9、OOP 中的 组合、聚合和关联有什么区别？

  如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。
  

- 10、Java网络编程有几种？

  TCP编程
  UDP编程
  

- 11、怎么在JDBC内调用一个存储过程
- 12、Collection接口下有那些集合框架？
- 13、MinorGC、MajorGC、FullGC 什么时候发生？
- 14、ReadWriteLock是什么
- 15、自动装箱与拆箱
- 16、设计模式的六大原则
- 17、给我一个符合开闭原则的设计模式的例子？
- 18、ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？
- 19、如何避免线程死锁
- 20、类加载是什么？
- 21、说说线程栈
- 22、url是什么？由哪些部分组成？
- 23、comparable 和 comparator的区别？
- 24、在Java中定义一个不做事且没有参数的构造方法的作用
- 25、CopyOnWriteArrayList 的设计思想?
- 26、能够找到 Reference Chain 的对象，就一定会存活么？
- 27、什么是竞争条件？你怎样发现和解决竞争？
- 28、为什么代码会重排序？
- 29、谈谈双亲委派模型
- 30、谈谈 JVM 中的常量池
- 31、JVM垃圾回收时候如何确定垃圾？什么是GC Roots？
- 32、Session加载实体对象的过程。
- 33、32 位和 64 位的 JVM，int 类型变量的长度是多数？
- 34、为什么 ArrayList 的 elementData 加上 transient 修饰？
- 35、JAVA软引用
- 36、Parallel Scavenge 收集器（多线程复制算法、高效）
- 37、Java 虚拟机栈的作用？
- 38、CAS的问题
- 39、什么情况会造成元空间溢出？
- 40、final、finalize 和 finally 的不同之处？
- 41、Sql优化有那些方法？

### 9. JAVA面试题9

- 1、日期和时间：

  1、 如何取得年月日、小时分钟秒？
  2、 如何取得从1970年1月1日0时0分0秒到现在的毫秒数？
  3、 如何取得某月的最后一天？
  4、 如何格式化日期？
  

- 2、XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？

  XML文档定义分为DTD和Schema两种形式，二者都是对XML语法的约束，其本质区别在于Schema本身也是一个XML文件，可以被XML解析器解析，而且可以为XML承载的数据定义类型，约束能力较之DTD更强大。对XML的解析主要有DOM（文档对象模型，Document Object Model）、SAX（Simple API for XML）和StAX（Java 6中引入的新的解析XML的方式，Streaming API for XML），其中DOM处理大型文件时其性能下降的非常厉害，这个问题是由DOM树结构占用的内存较多造成的，而且DOM解析方式必须在解析文件之前把整个文档装入内存，适合对XML的随机访问（典型的用空间换取时间的策略）；SAX是事件驱动型的XML解析方式，它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理XML文件，适合对XML的顺序访问；顾名思义，StAX把重点放在流上，实际上StAX与其他解析方式的本质区别就在于应用程序能够把XML作为一个事件流来处理。将XML作为一组事件来处理的想法并不新颖（SAX就是这样做的），但不同之处在于StAX允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。
  

- 3、依赖注入和工程模式之间有什么不同？

  虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工程模式更清晰。通过依赖注入，你的类就是 POJO，它只知道依赖而不关心它们怎么获取。使用工厂模式，你的类需要通过工厂来获取依赖。因此，使用 DI 会比使用工厂模式更容易测试。
  

- 4、Java 堆的结构是什么样子的？什么是堆中的永久代（Perm Gen space）

  JVM 的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在 JVM 启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。
  堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些 对象回收掉之前，他们会一直占据堆内存空间。
  

- 5、如何修改tomcat的端口号？

  在tomcat根目录的conf文件夹内打开server.xml文件，修改Connector节点的port属性
  

- 6、Java有没有goto？

  goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字）
  

- 7、Java 内存分配与回收策率以及 Minor GC 和 Major GC

  1、 对象优先在堆的 Eden 区分配
  2、 大对象直接进入老年代
  3、 长期存活的对象将直接进入老年代
  当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC。Minor GC 通常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高，回收速度比较快；Full GC/Major GC 发生在老年代，一般情况下，触发老年代 GC 的时候不会触发 Minor GC，但是通过配置，可以在 Full GC 之前进行一次 Minor GC 这样可以加快老年代的回收速度。
  

- 8、简述Hibernate常见优化策略。

  1、 制定合理的缓存策略（二级缓存、查询缓存）。
  2、 采用合理的Session管理机制。
  3、 尽量使用延迟加载特性。
  4、 设定合理的批处理参数。
  5、 如果可以，选用UUID作为主键生成器。
  6、 如果可以，选用乐观锁替代悲观锁。
  7、 在开发过程中, 开启hibernate.show_sql选项查看生成的SQL，从而了解底层的状况；开发完成后关闭此选项。
  8、 考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观的提升，但这些需要专业的DBA（数据库管理员）提供支持。
  

- 9、Statement与preparedStatement区别

  preparedStatement会预编译sql语句，能够提高批量的数据操作的执行效率，Statement执行slq的时候才进行编译
  Preparedstatement在第一次执行sql的时候，比较耗费资源。如果只对数据库进行一次操作，使用statement比较好。
  Statement会出现sql注入的问题，使用preparedstatment可以解决sql注入
  

- 10、什么是DAO模式？

  DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。
  

- 11、safepoint是什么？
- 12、什么是阻塞式方法？
- 13、解释什么是Jasper?
- 14、说一下 runnable 和 callable 有什么区别
- 15、抽象类可以使用final修饰吗？
- 16、双亲委派机制可以被违背吗？请举例说明。
- 17、如何让正在运行的线程暂停一段时间？
- 18、代理的分类
- 19、多线程的价值？
- 20、GC 是什么？为什么要有 GC？
- 21、什么是JDK？什么是JRE?
- 22、Final在java中的作用
- 23、请说明NAT协议的目的是什么?
- 24、抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？
- 25、那针对浮点型数据运算出现的误差的问题，你怎么解决？
- 26、Java中集合框架的有几个？
- 27、Java 中，DOM 和 SAX 解析器有什么不同？
- 28、java中是值传递引用传递？
- 29、如何理解Hibernate的延迟加载机制？在实际应用中，延迟加载与Session关闭的矛盾是如何处理的？
- 30、final、finalize()、finally，作用
- 31、为什么HashMap中String、Integer这样的包装类适合作为K？
- 32、除了使用new创建对象之外，还可以用什么方法创建对象？
- 33、继承和组合之间有什么不同？
- 34、数组有没有length()方法？String有没有length()方法？
- 35、事务的使用场景在什么地方？
- 36、说一下堆和栈的区别
- 37、除了单例模式，你在生产环境中还用过什么设计模式？
- 38、什么是工厂模式
- 39、synchronized可重入的原理
- 40、双亲委派
- 41、说出 5 条 IO 的最佳实践(答案)

### 10. JAVA面试题10

- 1、什么是Web Service（Web服务）

  从表面上看，Web Service就是一个应用程序，它向外界暴露出一个能够通过Web进行调用的API。这就是说，你能够用编程的方法透明的调用这个应用程序，不需要了解它的任何细节，跟你使用的编程语言也没有关系。例如可以创建一个提供天气预报的Web Service，那么无论你用哪种编程语言开发的应用都可以通过调用它的API并传入城市信息来获得该城市的天气预报。之所以称之为Web Service，是因为它基于HTTP协议传输数据，这使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件，就可相互交换数据或集成。
  

- 2、内部类与静态内部类的区别？

  静态内部类相对与外部类是独立存在的，在静态内部类中无法直接访问外部类中变量、方法。如果要访问的话，必须要new一个外部类的对象，使用new出来的对象来访问。但是可以直接访问静态的变量、调用静态的方法；
  普通内部类作为外部类一个成员而存在，在普通内部类中可以直接访问外部类属性，调用外部类的方法。
  如果外部类要访问内部类的属性或者调用内部类的方法，必须要创建一个内部类的对象，使用该对象访问属性或者调用方法。
  如果其他的类要访问普通内部类的属性或者调用普通内部类的方法，必须要在外部类中创建一个普通内部类的对象作为一个属性，外同类可以通过该属性调用普通内部类的方法或者访问普通内部类的属性
  如果其他的类要访问静态内部类的属性或者调用静态内部类的方法，直接创建一个静态内部类对象即可。
  

- 3、什么是代理模式

  通过代理控制对象的访问，可以在这个对象调用方法之前、调用方法之后去处理/添加新的功能。(也就是AO的P微实现)
  代理在原有代码乃至原业务流程都不修改的情况下，直接在业务流程中切入新代码，增加新功能，这也和Spring的（面向切面编程）很相似
  

- 4、32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？

  理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。
  

- 5、重排序实际执行的指令步骤

  ![87_5.png][87_5.png]
  1、 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
  2、 指令级并行的重排序。现代处理器采用了指令级并行技术（ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
  3、 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。
  这些重排序对于单线程没问题，但是多线程都可能会导致多线程程序出现内存可见性问题。
  

- 6、invokedynamic指令是干什么的？

  属于比较高级的题目。没看过虚拟机的一般是不知道的。所以如果你不太熟悉，不要气馁，加油！（小拳拳锤你胸口）。
  invokedynamic是Java7之后新加入的字节码指令，使用它可以实现一些动态类型语言的功能。我们使用的Lambda表达式，在字节码上就是invokedynamic指令实现的。它的功能有点类似反射，但它是使用方法句柄实现的，执行效率更高。
  

- 7、如何选择单例创建方式
- 8、Java集合的快速失败机制 “fail-fast”？

  是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。
  例如：假设存在两个线程（线程1、 线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。
  **原因：**迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。
  解决办法：
  1、 在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。
  2、 使用CopyOnWriteArrayList来替换ArrayList
  

- 9、如何实现字符串的反转及替换？
- 10、Spring开发中的工厂设计模式

  Spring IOC
  1、 看过Spring源码就知道，在Spring IOC容器创建bean的过程是使用了工厂设计模式
  2、 Spring中无论是通过xml配置还是通过配置类还是注解进行创建bean，大部分都是通过简单工厂来进行创建的。
  3、 当容器拿到了beanName和class类型后，动态的通过反射创建具体的某个对象，最后将创建的对象放到Map中。
  为什么Spring IOC要使用工厂设计模式创建Bean呢
  1、 在实际开发中，如果我们A对象调用B，B调用C，C调用D的话我们程序的耦合性就会变高。（耦合大致分为类与类之间的依赖，方法与方法之间的依赖。）
  2、 在很久以前的三层架构编程时，都是控制层调用业务层，业务层调用数据访问层时，都是是直接new对象，耦合性大大提升，代码重复量很高，对象满天飞
  3、 为了避免这种情况，Spring使用工厂模式编程，写一个工厂，由工厂创建Bean，以后我们如果要对象就直接管工厂要就可以，剩下的事情不归我们管了。Spring IOC容器的工厂中有个静态的Map集合，是为了让工厂符合单例设计模式，即每个对象只生产一次，生产出对象后就存入到Map集合中，保证了实例不会重复影响程序效率。
  

- 11、JRE、JDK、JVM 及 JIT 之间有什么不同？
- 12、HTTP的状态码
- 13、线程同步的方法
- 14、类ExampleA继承Exception，类ExampleB继承ExampleA。
- 15、HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？
- 16、volatile关键字的原理是什么？干什么用的？
- 17、写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。
- 18、线程的状态流转图
- 19、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？
- 20、Java的io流分为哪两种？
- 21、如何解析json对象？
- 22、synchronized 和 ReentrantLock 区别是什么？
- 23、使用Log4j对程序有影响吗？
- 24、在新生代-复制算法
- 25、对象是怎么从年轻代进入老年代的？
- 26、int和Integer有什么区别？
- 27、Java 中的内存映射缓存区是什么？
- 28、你能解释一下里氏替换原则吗?
- 29、类加载的过程是什么？
- 30、说出几点 Java 中使用 Collections 的最佳实践
- 31、程序计数器为什么是私有的?
- 32、为什么需要双亲委派模式？
- 33、HashSet与HashMap的区别
- 34、用 wait-notify 写一段代码来解决生产者-消费者问题？
- 35、谈谈你知道的垃圾收集器
- 36、GC垃圾回收算法与垃圾收集器的关系？
- 37、什么是B/S架构？什么是C/S架构
- 38、什么是事务？事务有那些特点？
- 39、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？
- 40、什么是happen-before原则？

## 第2章 并发编程（150道）

### 1. 并发编程面试题

- 1、堆的作用是什么？
- 堆是虚拟机所管理的内存中最大的一块，被所有线程共享的，在虚拟机启动时创建。堆用来存放对象实例，Java 里几乎所有对象实例都在堆分配内存。堆可以处于物理上不连续的内存空间，逻辑上应该连续，但对于例如数组这样的大对象，多数虚拟机实现出于简单、存储高效的考虑会要求连续的内存空间。
- 堆既可以被实现成固定大小，也可以是可扩展的，可通过 -Xms 和 -Xmx 设置堆的最小和最大容量，当前主流 JVM 都按照可扩展实现。如果堆没有内存完成实例分配也无法扩展，抛出 OutOfMemoryError。
- 2、为什么HashTable是线程安全的？
- 因为HasTable的内部方法都被synchronized修饰了，所以是线程安全的。其他的都和HashMap一样
- 1、 HashMap添加方法的源码 
- 2、 HashTable添加方法的源码 
- 3、stackoverflow错误，permgen space错误
- stackoverflow错误主要出现：
- 在虚拟机栈中(线程请求的栈深度大于虚拟机栈锁允许的最大深度)
- permgen space错误(针对jdk之前1.7版本)：
- 1、 大量加载class文件
- 2、 常量池内存溢出
- 4、Java 中你怎样唤醒一个阻塞的线程？
- 首先 ，wait()、notify() 方法是针对对象的，调用任意对象的 wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取该对象的锁，直到获取成功才能往下执行；
- 其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。
- 5、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代？
- 当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代。Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。
- 6、你熟悉哪些垃圾收集算法？
- 标记清除（缺点是碎片化） 复制算法（缺点是浪费空间） 标记整理算法（效率比前两者差） 分代收集算法（老年代一般使用“标记-清除”、“标记-整理”算法，年轻代一般用复制算法）
- 7、CMS分为哪几个阶段?
- CMS已经弃用。生活美好，时间有限，不建议再深入研究了。如果碰到问题，直接祭出回收过程即可。
- 1、 初始标记
- 2、 并发标记
- 3、 并发预清理
- 4、 并发可取消的预清理
- 5、 重新标记
- 6、 并发清理
- 由于《深入理解java虚拟机》一书的流行，面试时省略3、4步一般也是没问题的。
- 8、创建线程的四种方式
- 继承 Thread 类；
- public class MyThread extends Thread {
-     @Override
-     public void run() {
-         System.out.println(Thread.currentThread().getName() + " run()方法正在执行...");
- }
- 实现 Runnable 接口；
- public class MyRunnable implements Runnable {
-     @Override
-     public void run() {
-         System.out.println(Thread.currentThread().getName() + " run()方法执行中...");
- }
- 实现 Callable 接口；
- public class MyCallable implements Callable<Integer> {
- @Override
- public Integer call() {
-     System.out.println(Thread.currentThread().getName() + " call()方法执行中...");
-     return 1;
- }
- 使用匿名内部类方式
- public class CreateRunnable {
-     public static void main(String[] args) {
-         //创建多线程创建开始
-         Thread thread = new Thread(new Runnable() {
-                     public void run() {
-                     for (int i = 0; i < 10; i++) {
-                     System.out.println("i:" + i);
-                 }
-             }
-         });
-         thread.start();
-     }
- }
- 9、说一下 runnable 和 callable 有什么区别
- 相同点：
- 1、 都是接口
- 2、 都可以编写多线程程序
- 3、 都采用Thread.start()启动线程
- 主要区别：
- Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果
- Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息 注：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。
- 10、为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object 类里？
- Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法。
- 11、什么叫线程安全？servlet是线程安全吗?
- 12、Java会存在内存泄漏吗？请简单描述。
- 13、JVM 出现 fullGC 很频繁，怎么去线上排查问题
- 14、GC 垃圾收集器
- 15、不可变对象对多线程有什么帮助
- 16、线程之间是如何通信的？
- 17、为什么需要双亲委派模式？
- 18、Java线程池中submit() 和 execute()方法有什么区别？
- 19、形成死锁的四个必要条件是什么
- 20、什么是多线程中的上下文切换？
- 21、标记清除算法（ Mark-Sweep）
- 22、遇到过堆外内存溢出吗？
- 23、谈谈你知道的垃圾回收算法
- 24、运行时数据区是什么？
- 25、CyclicBarrier和CountDownLatch的区别
- 26、Java线程具有五中基本状态
- 27、什么是原子类
- 28、ArrayList和Vector有什么不同之处？
- 29、什么是方法内联？
- 30、JVM怎么判断一个对象是不是要回收？
- 31、调优命令有哪些？
- 32、java如何实现多线程之间的通讯和协作？

### 2. 并发编程面试题

- 1、阻塞队列和非阻塞队列区别
- 1、 当队列阻塞队列为空的时，从队列中获取元素的操作将会被阻塞。
- 2、 或者当阻塞队列是满时，往队列里添加元素的操作会被阻塞。
- 3、 或者试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。
- 4、 试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来
- 2、类加载有几个过程？
- 加载、验证、准备、解析、初始化。
- 3、线程 B 怎么知道线程 A 修改了变量
- 1、 volatile 修饰变量
- 2、 synchronized 修饰修改变量的方法
- 3、 wait/notify
- 4、 while 轮询
- 4、如何停止一个正在运行的线程？
- 在java中有以下3种方法可以终止正在运行的线程：
- 1、 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。
- 2、 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。
- 3、 使用interrupt方法中断线程。
- 5、什么是线程死锁
- 1、 死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。
- 2、 多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。
- 3、 如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。
- ![87_1.png][87_1.png]
- 6、常用的并发工具类有哪些？
- CountDownLatch
- CountDownLatch 类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他3个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。
- CyclicBarrier (回环栅栏) CyclicBarrier它的作用就是会让所有线程都等待完成后才会继续下一步行动。
- CyclicBarrier初始化时规定一个数目，然后计算调用了CyclicBarrier.await()进入等待的线程数。当线程数达到了这个数目时，所有进入等待状态的线程被唤醒并继续。
- CyclicBarrier初始时还可带一个Runnable的参数， 此Runnable任务在CyclicBarrier的数目达到后，所有其它线程被唤醒前被执行。
- Semaphore (信号量) Semaphore 是 synchronized 的加强版，作用是控制线程的并发数量（允许自定义多少线程同时访问）。就这一点而言，单纯的synchronized 关键字是实现不了的。
- Semaphore是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。它的用法如下：
- 7、并发编程三个必要因素是什么？
- 原子性：
- 原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。
- 可见性：
- 一个线程对共享变量的修改,另一个线程能够立刻看到。（synchronized,volatile）
- 有序性：
- 程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）
- 8、safepoint 是什么？
- 1、 为了减少对象引用的扫描，使用 OopMap 的数据结构在特定的位置记录下栈里和寄存器里哪些位置是引用；
- 2、 但为了避免给每条指令都生成 OopMap 记录占用大量内存的问题，只在特定位置记录这些信息。
- 3、 安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的，如方法调用、循环跳转、异常跳转等都属于指令序列复用。
- 9、如何让正在运行的线程暂停一段时间？
- 我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。
- 10、synchronized可重入的原理
- 重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。
- 11、JVM调优命令有哪些？
- 12、什么是Executors框架？
- 13、单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！”
- 14、Parallel Old 收集器（多线程标记整理算法）
- 15、什么情况会造成元空间溢出？
- 16、Java对象的布局了解过吗？
- 17、volatile关键字的作用
- 18、程序计数器为什么是私有的?
- 19、如何判断对象是否是垃圾？
- 20、为什么使用Executor框架？
- 21、模块化编程与热插拔
- 22、JVM 年轻代到年老代的晋升过程的判断条件是什么呢？
- 23、说说你知道的几种主要的JVM参数
- 24、JVM内存模型
- 25、CopyOnWriteArrayList 的缺点?
- 26、双亲委派模型是什么？
- 27、volatile有什么用？能否用一句话说明下volatile的应用场景？
- 28、FutureTask是什么
- 29、线程类的构造方法、静态块是被哪个线程调用的
- 30、如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？
- 31、方法区/永久代（线程共享）
- 32、栈帧里面包含哪些东西？

### 3. 并发编程面试题

- 1、生产上如何配置垃圾收集器的？
- 首先是内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。通常，堆空间我会设置成操作系统的2/3（这是想给其他进程和操作系统预留一些时间），超过8GB的堆优先选用G1。
- 接下来，我会对JVM进行初步优化。比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例。
- 再接下来，就是专项优化，主要判断的依据就是系统容量、访问延迟、吞吐量等。我们的服务是高并发的，所以对STW的时间非常敏感。
- 我会通过记录详细的GC日志，来找到这个瓶颈点，借用gceasy（重点）这样的日志分析工具，很容易定位到问题。之所以选择采用工具，是因为gc日志看起来实在是太麻烦了，gceasy号称是AI学习分析问题，可视化做的较好。
- 2、对象的访问定位有哪几种方式?
- 建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针2种：
- 句柄：如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
- 直接指针：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。
- 这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。
- 3、invokedynamic 指令是干什么的？
- Java 7 开始，新引入的字节码指令，可以实现一些动态类型语言的功能。Java 8 的 Lambda 表达式就是通过 invokedynamic 指令实现，使用方法句柄实现。
- 4、CAS的问题
- 1、 CAS容易造成ABA问题
- 一个线程a将数值改成了b，接着又改成了a，此时CAS认为是没有变化，其实是已经变化过了，而这个问题的解决方案可以使用版本号标识，每操作一次version加1。在java5中，已经提供了AtomicStampedReference来解决问题。
- 2、 不能保证代码块的原子性
- CAS机制所保证的知识一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用synchronized了。
- 3、 CAS造成CPU利用率增加
- 之前说过了CAS里面是一个循环判断的过程，如果线程一直没有获取到状态，cpu资源会一直被占用。
- 5、讲讲什么情况下会出现内存溢出，内存泄漏？
- 内存泄漏的原因很简单：
- 1、 对象是可达的(一直被引用)
- 2、 但是对象不会被使用
- 常见的内存泄漏例子：
-     public static void main(String[] args) {
-         Set<Object> set = new HashSet<>();
-         for (int i = 0; i < 10; i++) {
-             Object object = new Object();
-             set.add(object);
-             // 设置为空，该对象不再使用
-             object = null;
-         }
-         // 但是set集合中还维护object的引用，gc不会回收object对象
-         System.out.println(set);
-         System.out.println(set.size());
-     }
- }
- 输出结果
- [java.lang.Object@74a14482, 
- java.lang.Object@677327b6, 
- java.lang.Object@6d6f6e28, 
- java.lang.Object@4554617c, 
- java.lang.Object@45ee12a7, 
- java.lang.Object@1b6d3586, 
- java.lang.Object@7f31245a,
- java.lang.Object@135fbaa4,
- java.lang.Object@1540e19d, 
- java.lang.Object@14ae5a5]
- 10
- Process finished with exit code 0
- 解决这个内存泄漏问题也很简单，将set设置为null，那就可以避免上述内存泄漏问题了。其他内存泄漏得一步一步分析了。
- 内存溢出的原因：
- 1、 内存泄露导致堆栈内存不断增大，从而引发内存溢出。
- 2、 大量的jar，class文件加载，装载类的空间不够，溢出
- 3、 操作大量的对象导致堆内存空间已经用满了，溢出
- 4、 nio直接操作内存，内存过大导致溢出
- 解决：
- 1、 查看程序是否存在内存泄漏的问题
- 2、 设置参数加大空间
- 3、 代码中是否存在死循环或循环产生过多重复的对象实体、
- 4、 查看是否使用了nio直接操作内存。
- 6、类的实例化顺序
- 1、 父类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行
- 2、 子类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行
- 3、 父类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行
- 4、 父类构造方法
- 5、 子类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行
- 6、 子类构造方法
- 检验一下是不是真懂了：
- public class Base {
-     private String name = "博客：Soinice";
-     public Base() {
-         tellName();
-         printName();
-     }
-     public void tellName() {
-         System.out.println("Base tell name: " + name);
-     }
-     public void printName() {
-         System.out.println("Base print name: " + name);
-     }
- }
- public class Dervied extends Base {
-     private String name = "Java3y";
-     public Dervied() {
-         tellName();
-         printName();
-     }
-     @Override
-     public void tellName() {
-         System.out.println("Dervied tell name: " + name);
-     }
-     @Override
-     public void printName() {
-         System.out.println("Dervied print name: " + name);
-     }
-     public static void main(String[] args) {
-         new Dervied();
-     }
- }
- 输出数据：
- Dervied tell name: null
- Dervied print name: null
- Dervied tell name: Java3y
- Dervied print name: Java3y
- Process finished with exit code 0
- 第一次做错的同学点个赞，加个关注不过分吧(hahaha。
- 7、Serial 垃圾收集器（单线程、 复制算法）
- Serial（英文连续） 是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1 之前新生代唯一的垃圾收集器。Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。
- Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。
- 8、怎么唤醒一个阻塞的线程
- 如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。
- 9、什么是阻塞式方法？
- 阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。
- 10、并发队列的常用方法
- 不管是那种列队，是那个类，当是他们使用的方法都是差不多的
- 方法名	描述
- add()	在不超出队列长度的情况下插入元素，可以立即执行，成功返回true，如果队列满了就抛出异常。
- offer()	在不超出队列长度的情况下插入元素的时候则可以立即在队列的尾部插入指定元素,成功时返回true，如果此队列已满，则返回false。
- put()	插入元素的时候，如果队列满了就进行等待，直到队列可用。
- take()	从队列中获取值，如果队列中没有值，线程会一直阻塞，直到队列中有值，并且该方法取得了该值。
- poll(long timeout, TimeUnit unit)	在给定的时间里，从队列中获取值，如果没有取到会抛出异常。
- remainingCapacity()	获取队列中剩余的空间。
- remove(Object o)	从队列中移除指定的值。
- contains(Object o)	判断队列中是否拥有该值。
- drainTo(Collection c)	将队列中值，全部移除，并发设置到给定的集合中。
- 11、工作中常用的 JVM 配置参数有哪些？
- 12、怎样通过 Java 程序来判断 JVM 是 32 位 还是 64位？
- 13、newFixedThreadPool
- 14、Executors类是什么？
- 15、什么是双亲委派机制？
- 16、说说自己是怎么使用 synchronized 关键字，在项目中用到了吗
- 17、介绍一下 JVM 中垃圾收集器有哪些？ 他们特点分别是什么？
- 18、为什么Thread类的sleep()和yield ()方法是静态的？
- 19、如何避免线程死锁
- 20、分代收集算法
- 21、多线程同步有哪几种方法？
- 22、什么是Executors？
- 23、谈谈永久代
- 24、对于JDK自带的监控和性能分析工具用过哪些？
- 25、Serial Old 收集器（单线程标记整理算法 ）
- 26、四种线程池的创建：
- 27、线程池作用？
- 28、什么是堆
- 29、MinorGC、MajorGC、FullGC 什么时候发生？
- 30、简述Java的对象结构
- 31、JRE、JDK、JVM 及 JIT 之间有什么不同？
- 32、实现可见性的方法有哪些？

### 4. 并发编程面试题

- 1、ZGC收集器中的染色指针有什么用？
- 染色指针是一种直接将少量额外的信息存储在指针上的技术，可是为什么指针本身也可以存储额外信息呢？在64位系统中，理论可以访问的内存高达16EB（2的64次幂）字节 [3] 。实际上，基于需求（用不到那么多内存）、性能（地址越宽在做地址转换时需要的页表级数越多）和成本（消耗更多晶体管）的考虑，在AMD64架构 [4] 中只支持到52位（4PB）的地址总线和48位（256TB）的虚拟地址空间，所以目前64位的硬件实际能够支持的最大内存只有256TB。此外，操作系统一侧也还会施加自己的约束，64位的Linux则分别支持47位（128TB）的进程虚拟地址空间和46位（64TB）的物理地址空间，64位的Windows系统甚至只支持44位（16TB）的物理地址空间。尽管Linux下64位指针的高18位不能用来寻址，但剩余的46位指针所能支持的64TB内存在今天仍然能够充分满足大型服务器的需要。鉴于此，ZGC的染色指针技术继续盯上了这剩下的46位指针宽度，将其高4位提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过finalize()方法才能被访问到。当然，由于这些标志位进一步压缩了原本就只有46位的地址空间，也直接导致ZGC能够管理的内存不可以超过4TB（2的42次幂） 。
- 2、什么情况下会发生栈溢出？
- 栈的大小可以通过-Xss参数进行设置，当递归层次太深的时候，就会发生栈溢出。比如循环调用，递归等。
- 3、CopyOnWriteArrayList 的设计思想?
- 1、 读写分离，读和写分开
- 2、 最终一致性
- 3、 使用另外开辟空间的思路，来解决并发冲突
- 4、为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？
- 当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。
- 5、CopyOnWriteArrayList可以用于什么应用场景？
- CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException。在CopyOnWriteArrayList中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。
- 1、 由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc；
- 2、 不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求；
- CopyOnWriteArrayList透露的思想
- 1、 读写分离，读和写分开
- 2、 最终一致性
- 3、 使用另外开辟空间的思路，来解决并发冲突
- 6、线程的 sleep()方法和 yield()方法有什么区别？
- 1、 sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
- 2、 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；
- 3、 sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；
- 4、 sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。
- 7、safepoint是什么？
- STW并不会只发生在内存回收的时候。现在程序员这么卷，碰到几次safepoint的问题几率也是比较大的。
- 当发生GC时，用户线程必须全部停下来，才可以进行垃圾回收，这个状态我们可以认为JVM是安全的（safe），整个堆的状态是稳定的。
- 如果在GC前，有线程迟迟进入不了safepoint，那么整个JVM都在等待这个阻塞的线程，造成了整体GC的时间变长。
- 8、什么是IO密集
- IO密集型，即该任务需要大量的IO，即大量的阻塞。在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力浪费在等待。所以在IO密集型任务中使用多线程可以大大的加速程序运行，即时在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。
- 9、线程和进程区别
- 什么是线程和进程?
- 进程
- 一个在内存中运行的应用程序。 每个正在系统上运行的程序都是一个进程
- 线程
- 进程中的一个执行任务（控制单元）， 它负责在程序里独立执行。
- 一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据
- 进程与线程的区别
- 1、 根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位
- 2、 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
- 3、 包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
- 4、 内存分配：同一进程的线程共享本进程的地址空间和资源，而进程与进程之间的地址空间和资源是相互独立的
- 5、 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃有可能导致整个进程都死掉。所以多进程要比多线程健壮。
- 6、 执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行
- 10、CAS 的会产生什么问题？
- ABA 问题：
- 比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。
- 循环时间长开销大：
- 对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。
- 只能保证一个共享变量的原子操作：
- 当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。
- 11、一个线程运行时发生异常会怎样？
- 12、什么是自旋
- 13、什么是上下文切换?
- 14、对象在哪块内存分配？
- 15、什么是FutureTask?使用ExecutorService启动任务。
- 16、方法区
- 17、本地方法栈
- 18、SynchronizedMap和ConcurrentHashMap有什么区别？
- 19、用过ConcurrentHashMap，讲一下他和HashTable的不同之处？
- 20、能够找到 Reference Chain 的对象，就一定会存活么？
- 21、synchronized和ReentrantLock的区别
- 22、JVM 数据运行区，哪些会造成 OOM 的情况？
- 23、类的实例化顺序
- 24、什么是线程池？有哪几种创建方式？
- 25、Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？
- 26、Java中垃圾回收有什么目的？什么时候进行垃圾回收？
- 27、synchronized、volatile、CAS 比较
- 28、程序计数器
- 29、对象分配内存是否线程安全？
- 30、谈谈双亲委派模型
- 31、为什么使用Executor框架比使用应用创建和管理线程好？
- 32、GC 是什么? 为什么要有 GC

### 5. 并发编程面试题

- 1、ThreadLocal是什么？有什么用？
- ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。
- 简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。
- 2、说一下 Atomic的原理？
- Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。
- 3、内存溢出和内存泄漏的区别？
- 内存溢出 OutOfMemory，指程序在申请内存时，没有足够的内存空间供其使用。
- 内存泄露 Memory Leak，指程序在申请内存后，无法释放已申请的内存空间，内存泄漏最终将导致内存溢出。
- 4、你有哪些手段来排查 OOM 的问题？
- 1、 增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录
- 2、 同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域
- 3、 使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用
- 5、JVM垃圾回收机制，何时触发MinorGC等操作
- 当young gen中的eden区分配满的时候触发MinorGC(新生代的空间不够放的时候).
- 6、Java 中能创建 volatile 数组吗？
- 能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。
- 7、介绍一下类文件结构吧！
- 魔数: 确定这个文件是否为一个能被虚拟机接收的 Class 文件。Class 文件版本 ：Class 文件的版本号，保证编译正常执行。常量池 ：常量池主要存放两大常量：字面量和符号引用。访问标志 ：标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。当前类索引,父类索引 ：类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。接口索引集合 ：接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按implents(如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。字段表集合 ：描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。方法表集合 ：类中的方法。属性表集合 ：在 Class 文件，字段表，方法表中都可以携带自己的属性表集合。
- 8、Java中notify 和 notifyAll有什么区别？
- notify() 方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。
- 9、可以描述一下 class 文件的结构吗？
- 1、 Class 文件包含了 Java 虚拟机的指令集、符号表、辅助信息的字节码(Byte Code)，是实现跨操作系统和语言无关性的基石之一。
- 2、 一个 Class 文件定义了一个类或接口的信息，是以 8 个字节为单位，没有分隔符，按顺序紧凑排在一起的二进制流。
- 3、 用 "无符号数" 和 "表" 组成的伪结构来存储数据。
- 4、 无符号数：基本数据类型，用来描述数字、索引引用、数量值、字符串值，如u1、u2 分别表示 1 个字节、2 个字节
- 10、 表：无符号数和其他表组成，命名一般以 "_info" 结尾
- 组成部分
- 1、 魔数 Magic Number
- Class 文件头 4 个字节，0xCAFEBABE
- 作用是确定该文件是 Class 文件
- 2、 版本号
- 4 个字节，前 2 个是次版本号 Minor Version，后 2 个主版本号 Major Version
- 从 45 (JDK1.0) 开始，如 0x00000032 转十进制就是 50，代表 JDK 6
- 低版本的虚拟机跑不了高版本的 Class 文件
- 3、 常量池
- 常量容量计数值(constant_pool_count)，u2，从 1 开始。如 0x0016 十进制 22 代表有
- 21 项常量
- 每项常量都是一个表，目前 17 种
- 特点：Class 文件中最大数据项目之一、第一个出现表数据结构
- 4、 访问标志
- 2 个字节，表示类或接口的访问标志
- 5、 类索引、父类索引、接口索引集合
- 类索引(this_class)、父类索引(super_class)，u2
- 接口索引集合(interfaces)，u2 集合
- 类索引确定类的全限定名、父类索引确定父类的全限定名、接口索引集合确定实现接口
- 索引值在常量池中查找对应的常量
- 6、 字段表(field_info)集合
- 描述接口或类申明的变量
- fields_count，u2，表示字段表数量；后面接着相应数量的字段表
- 9 种字段访问标志
- 7、 方法表(method_info)集合
- 描述接口或类申明的方法
- methods_count，u2，表示方法表数量；后面接着相应数量的方法表
- 12 种方法访问标志
- 方法表结构与字段表结构一致
- 8、 属性表(attribute_info)集合
- class 文件、字段表、方法表可携带属性集合，描述特有信息
- 预定义 29 项属性，可自定义写入不重名属性
- 10、Java 程序是怎样运行的？
- 首先通过 Javac 编译器将 .java 转为 JVM 可加载的 .class 字节码文件。
- Javac 是由 Java 编写的程序，编译过程可以分为：① 词法解析，通过空格分割出单词、操作符、控制符等信息，形成 token 信息流，传递给语法解析器。② 语法解析，把 token 信息流按照 Java 语法规则组装成语法树。③ 语义分析，检查关键字使用是否合理、类型是否匹配、作用域是否正确等。④ 字节码生成，将前面各个步骤的信息转换为字节码。
- 字节码必须通过类加载过程加载到 JVM 后才可以执行，执行有三种模式，解释执行、JIT 编译执行、JIT 编译与解释器混合执行（主流 JVM 默认执行的方式）。混合模式的优势在于解释器在启动时先解释执行，省去编译时间。
- 之后通过即时编译器 JIT 把字节码文件编译成本地机器码。
- Java 程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会认定其为"热点代码"，热点代码的检测主要有基于采样和基于计数器两种方式，为了提高热点代码的执行效率，虚拟机会把它们编译成本地机器码，尽可能对代码优化，在运行时完成这个任务的后端编译器被称为即时编译器。
- 还可以通过静态的提前编译器 AOT 直接把程序编译成与目标机器指令集相关的二进制代码。
- 11、什么是AQS
- 12、什么是并发容器的实现？
- 13、本地方法区(线程私有)
- 14、类加载是什么？
- 15、复制算法（copying）
- 16、垃圾收集算法
- 17、JVM 的内存模型以及分区情况和作用
- 18、为什么wait和notify方法要在同步块中调用？
- 19、Java中interrupted 和 isInterrupted方法的区别？
- 20、有哪些 GC 算法？
- 21、可达性分析
- 22、Java的双亲委托机制是什么？
- 23、线程的调度策略
- 24、线程池中 submit() 和 execute() 方法有什么区别？
- 25、对象分配规则
- 26、Java中用到的线程调度算法是什么？
- 27、Java里有哪些引用类型？
- 28、字符串常量存放在哪个区域？
- 29、什么是本地方法栈
- 30、notify() 和 notifyAll() 有什么区别？
- 31、说说Java 垃圾回收机制
- 32、多线程应用场景

## 第3章 JVM（180道）

### 1. 面试题1

- 1、JAVA弱引用

  弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。
  

- 2、什么是堆

  存放对象实例，所有的对象和数组都要在堆上分配。 是 JVM 所管理的内存中最大的一块区域。
  

- 3、什么是程序计数器

  当前线程所执行的行号指示器。是 JVM 内存区域最小的一块区域。执行字节码工作时就是利用程序计数器来选取下一条需要执行的字节码指令。
  

- 4、各种回收器，各自优缺点，重点CMS、G1

  图来源于《深入理解Java虚拟机：JVM高级特效与最佳实现》，图中两个收集器之间有连线，说明它们可以配合使用.
  1、 Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，但可能会产生较长的停顿，只使用一个线程去回收。
  2、 ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。
  3、 Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。
  4、 Parallel Old收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程“标记－整理”算法
  5、 CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担。CMS无法处理浮动垃圾。CMS的“标记-清除”算法，会导致大量空间碎片的产生。
  6、 G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器、以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征。
  

- 5、可以描述一下 class 文件的结构吗？

  1、 Class 文件包含了 Java 虚拟机的指令集、符号表、辅助信息的字节码(Byte Code)，是实现跨操作系统和语言无关性的基石之一。
  2、 一个 Class 文件定义了一个类或接口的信息，是以 8 个字节为单位，没有分隔符，按顺序紧凑排在一起的二进制流。
  3、 用 "无符号数" 和 "表" 组成的伪结构来存储数据。
  4、 无符号数：基本数据类型，用来描述数字、索引引用、数量值、字符串值，如u1、u2 分别表示 1 个字节、2 个字节
  10、 表：无符号数和其他表组成，命名一般以 "_info" 结尾
  组成部分
  1、 魔数 Magic Number
  Class 文件头 4 个字节，0xCAFEBABE
  作用是确定该文件是 Class 文件
  2、 版本号
  4 个字节，前 2 个是次版本号 Minor Version，后 2 个主版本号 Major Version
  从 45 (JDK1.0) 开始，如 0x00000032 转十进制就是 50，代表 JDK 6
  低版本的虚拟机跑不了高版本的 Class 文件
  3、 常量池
  4、 访问标志
  5、 类索引、父类索引、接口索引集合
  6、 字段表(field_info)集合
  7、 方法表(method_info)集合
  8、 属性表(attribute_info)集合
  

- 6、类的实例化顺序

  比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序
  先静态、先父后子。
  先静态：父静态 > 子静态
  优先级：父类 > 子类 静态代码块 > 非静态代码块 > 构造函数
  一个类的实例化过程：
  1、 父类中的static代码块，当前类的static
  2、 顺序执行父类的普通代码块
  3、 父类的构造函数
  4、 子类普通代码块
  5、 子类（当前类）的构造函数，按顺序执行。
  6、 子类方法的执行，
  

- 7、怎么打出线程栈信息？

  输入jps，获得进程号。top -Hp pid 获取本进程中所有线程的CPU耗时性能 jstack pid命令查看当前java进程的堆栈状态 或者 jstack -l > /tmp/output.txt 把堆栈信息打到一个txt文件。可以使用fastthread 堆栈定位（fastthread.io）
  

- 8、程序计数器是什么？

  程序计数器是一块较小的内存空间，可以看作当前线程所执行字节码的行号指示器。字节码解释器工作时通过改变计数器的值选取下一条执行指令。分支、循环、跳转、线程恢复等功能都需要依赖计数器完成。是唯一在虚拟机规范中没有规定内存溢出情况的区域。
  如果线程正在执行 Java 方法，计数器记录正在执行的虚拟机字节码指令地址。如果是本地方法，计数器值为 Undefined。
  

- 9、JVM的引用类型有哪些？

  引用内型：
  强引用：
  当内存不足的时候，JVM宁可出现OutOfMemoryError错误停止，也需要进行保存，并且不会将此空间回收。在引用期间和栈有联系就无法被回收
  软引用：
  当内存不足的时候，进行对象的回收处理，往往用于高速缓存中；mybatis就是其中
  弱引用：
  不管内存是否紧张，只要有垃圾了就立即回收
  幽灵引用：
  和没有引用是一样的
  

- 10、Serial 与 Parallel GC 之间的不同之处？

  Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而parallel 收集器使用多个 GC 线程来执行。
  

- 11、JVM新生代中为什么要分为Eden和Survivor？
- 12、老年代
- 13、常用JVM基本配置参数
- 14、如何判断一个类是无用的类?
- 15、什么是 Class 文件？ Class 文件主要的信息结构有哪些？
- 16、Java 堆的结构是什么样子的？什么是堆中的永久代（Perm Gen space）
- 17、如何判断对象可以被回收
- 18、JVM有哪些内存区域？(JVM的内存布局是什么？)
- 19、说说CMS垃圾收集器的工作原理
- 20、类加载是什么？
- 21、JAVA虚引用
- 22、对于JDK自带的监控和性能分析工具用过哪些？
- 23、什么是指令重排序？
- 24、有哪些类加载器？
- 25、堆和栈的区别
- 26、Java会存在内存泄漏吗？请简单描述。
- 27、生产环境服务器变慢，如何诊断处理？
- 28、什么是逃逸分析？
- 29、java中会存在内存泄漏吗，请简单描述。
- 30、程序计数器为什么是私有的?

### 2. 面试题2

- 1、GC Roots 有哪些？

  1、 GC Roots 是一组必须活跃的引用。用通俗的话来说，就是程序接下来通过直接引用或者间接引用，能够访问到的潜在被使用的对象。
  2、 GC Roots 包括：Java 线程中，当前所有正在被调用的方法的引用类型参数、局部变量、临时值等。也就是与我们栈帧相关的各种引用。所有当前被加载的 Java 类。Java 类的引用类型静态变量。运行时常量池里的引用类型常量（String 或 Class 类型）。JVM 内部数据结构的一些引用，比如 sun.jvm.hotspot.memory.Universe 类。用于同步的监控对象，比如调用了对象的 wait() 方法。JNI handles，包括 global handles 和 local handles。
  3、 这些 GC Roots 大体可以分为三大类，下面这种说法更加好记一些：活动线程相关的各种引用。类的静态变量的引用。JNI 引用。
  4、 有两个注意点：我们这里说的是活跃的引用，而不是对象，对象是不能作为 GC Roots 的。GC 过程是找出所有活对象，并把其余空间认定为“无用”；而不是找出所有死掉的对象，并回收它们占用的空间。所以，哪怕 JVM 的堆非常的大，基于 tracing 的 GC 方式，回收速度也会非常快。
  

- 2、说说Java 垃圾回收机制

  在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。
  

- 3、介绍一下类文件结构吧！

  魔数: 确定这个文件是否为一个能被虚拟机接收的 Class 文件。Class 文件版本 ：Class 文件的版本号，保证编译正常执行。常量池 ：常量池主要存放两大常量：字面量和符号引用。访问标志 ：标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。当前类索引,父类索引 ：类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。接口索引集合 ：接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按implents(如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。字段表集合 ：描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。方法表集合 ：类中的方法。属性表集合 ：在 Class 文件，字段表，方法表中都可以携带自己的属性表集合。
  

- 4、分代收集算法

  当前主流 VM 垃圾收集都采用”分代收集” (Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如 JVM 中的新生代、老年代、永久代， 这样就可以根据各年代特点分别采用最适当的 GC 算法
  

- 5、堆溢出的原因？

  堆用于存储对象实例，只要不断创建对象并保证 GC Roots 到对象有可达路径避免垃圾回收，随着对象数量的增加，总容量触及最大堆容量后就会 OOM，例如在 while 死循环中一直 new 创建实例。
  堆 OOM 是实际应用中最常见的 OOM，处理方法是通过内存映像分析工具对 Dump 出的堆转储快照分析，确认内存中导致 OOM 的对象是否必要，分清到底是内存泄漏还是内存溢出。
  如果是内存泄漏，通过工具查看泄漏对象到 GC Roots 的引用链，找到泄露对象是通过怎样的引用路径、与哪些 GC Roots 关联才导致无法回收，一般可以准确定位到产生内存泄漏代码的具***置。
  如果不是内存泄漏，即内存中对象都必须存活，应当检查 JVM 堆参数，与机器内存相比是否还有向上调整的空间。再从代码检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。
  

- 6、Tomcat是怎么打破双亲委派机制的呢？

  是通过重写ClassLoader#loadClass和ClassLoader#findClass 实现的。可以看图中的WebAppClassLoader，它加载自己目录下的.class文件，并不会传递给父类的加载器。但是，它却可以使用 SharedClassLoader 所加载的类，实现了共享和分离的功能。
  

- 7、你知道哪些垃圾收集器？

  序列号
  最基础的收集器，使用复制算法、单线程工作，只用一个处理器或一条线程完成垃圾收集，进行垃圾收集时必须暂停其他所有工作线程。
  Serial 是虚拟机在客户端模式的默认新生代收集器，简单高效，对于内存受限的环境它是所有收集器中额外内存消耗最小的，对于处理器核心较少的环境，Serial 由于没有线程交互开销，可获得最高的单线程收集效率。
  新品
  Serial 的多线程版本，除了使用多线程进行垃圾收集外其余行为完全一致。
  ParNew 是虚拟机在服务端模式的默认新生代收集器，一个重要原因是除了 Serial 外只有它能与 CMS 配合。自从 JDK 9 开始，ParNew 加 CMS 不再是官方推荐的解决方案，官方希望它被 G1 取代。
  并行清理
  新生代收集器，基于复制算法，是可并行的多线程收集器，与 ParNew 类似。
  特点是它的关注点与其他收集器不同，Parallel Scavenge 的目标是达到一个可控制的吞吐量，吞吐量就是处理器用于运行用户代码的时间与处理器消耗总时间的比值。
  串行旧
  Serial 的老年代版本，单线程工作，使用标记-整理算法。
  Serial Old 是虚拟机在客户端模式的默认老年代收集器，用于服务端有两种用途：① JDK5 及之前与 Parallel Scavenge 搭配。② 作为CMS 失败预案。
  平行老
  Parallel Scavenge 的老年代版本，支持多线程，基于标记-整理算法。JDK6 提供，注重吞吐量可考虑 Parallel Scavenge 加 Parallel Old。
  不育系
  以获取最短回收停顿时间为目标，基于标记-清除算法，过程相对复杂，分为四个步骤：初始标记、并发标记、重新标记、并发清除。
  初始标记和重新标记需要 STW（Stop The World，系统停顿），初始标记仅是标记 GC Roots 能直接关联的对象，速度很快。并发标记从 GC Roots 的直接关联对象开始遍历整个对象图，耗时较长但不需要停顿用户线程。重新标记则是为了修正并发标记期间因用户程序运作而导致标记产生变动的那部分记录。并发清除清理标记阶段判断的已死亡对象，不需要移动存活对象，该阶段也可与用户线程并发。
  缺点：① 对处理器资源敏感，并发阶段虽然不会导致用户线程暂停，但会降低吞吐量。② 无法处理浮动垃圾，有可能出现并发失败而导致 Full GC。③ 基于标记-清除算法，产生空间碎片。
  G1
  开创了收集器面向局部收集的设计思路和基于 Region 的内存布局，主要面向服务端，最初设计目标是替换 CMS。
  G1 之前的收集器，垃圾收集目标要么是整个新生代，要么是整个老年代或整个堆。而 G1 可面向堆任何部分来组成回收集进行回收，衡量标准不再是分代，而是哪块内存中存放的垃圾数量最多，回收受益最大。
  跟踪各 Region 里垃圾的价值，价值即回收所获空间大小以及回收所需时间的经验值，在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先处理回收价值最大的 Region。这种方式保证了 G1 在有限时间内获取尽可能高的收集效率。
  G1 运作过程：
  初始标记：标记 GC Roots 能直接关联到的对象，让下一阶段用户线程并发运行时能正确地在可用 Region 中分配新对象。需要 STW 但耗时很短，在 Minor GC 时同步完成。
  并发标记：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆的对象图。耗时长但可与用户线程并发，扫描完成后要重新处理 SATB 记录的在并发时有变动的对象。
  最终标记：对用户线程做短暂暂停，处理并发阶段结束后仍遗留下来的少量 SATB 记录。
  筛选回收：对各 Region 的回收价值排序，根据用户期望停顿时间制定回收计划。必须暂停用户线程，由多条收集线程并行完成。
  可由用户指定期望停顿时间是 G1 的一个强大功能，但该值不能设得太低，一般设置为100~300 ms。
  

- 8、JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用

  当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM主要动机在于可以指定最大堆大小，通过压缩OOP 可以节省一定的内存。通过-XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。
  

- 9、invokedynamic 指令是干什么的？

  Java 7 开始，新引入的字节码指令，可以实现一些动态类型语言的功能。Java 8 的 Lambda 表达式就是通过 invokedynamic 指令实现，使用方法句柄实现。
  

- 10、动态改变构造

  OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理， OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。
  

- 11、怎样通过 Java 程序来判断 JVM 是 32 位 还是 64位？
- 12、引用计数法
- 13、在老年代-标记整理算法
- 14、Minor GC与Full GC分别在什么时候发生？
- 15、怎么获取 Java 程序使用的内存？堆使用的百分比？
- 16、在新生代-复制算法
- 17、JIT 是什么？
- 18、双亲委派模型是什么？
- 19、列举一些你知道的打破双亲委派机制的例子。为什么要打破？
- 20、谈谈你知道的垃圾回收算法
- 21、线上常用的 JVM 参数有哪些？
- 22、各种回收算法
- 23、JVM 有哪些运行时内存区域？
- 24、说说线程栈
- 25、JAVA8 与元数据
- 26、说说你知道的几种主要的JVM参数
- 27、生产环境用的什么JDK？如何配置的垃圾收集器？
- 28、本地方法栈的作用？
- 29、JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的
- 30、GC日志的real、user、sys是什么意思？
- 31、GC 是什么? 为什么要有 GC

### 3. 面试题3

- 1、ZGC 了解吗？

  JDK11 中加入的具有实验性质的低延迟垃圾收集器，目标是尽可能在不影响吞吐量的前提下，实现在任意堆内存大小都可以把停顿时间限制在 10ms 以内的低延迟。
  基于 Region 内存布局，不设分代，使用了读屏障、染色指针和内存多重映射等技术实现可并发的标记-整理，以低延迟为首要目标。
  ZGC 的 Region 具有动态性，是动态创建和销毁的，并且容量大小也是动态变化的。
  

- 2、safepoint是什么？

  STW并不会只发生在内存回收的时候。现在程序员这么卷，碰到几次safepoint的问题几率也是比较大的。
  当发生GC时，用户线程必须全部停下来，才可以进行垃圾回收，这个状态我们可以认为JVM是安全的（safe），整个堆的状态是稳定的。
  如果在GC前，有线程迟迟进入不了safepoint，那么整个JVM都在等待这个阻塞的线程，造成了整体GC的时间变长。
  

- 3、JVM 提供的常用工具

  jps：
  用来显示本地的 Java 进程，可以查看本地运行着几个 Java 程序，并显示他们的进程号。 命令格式：jps
  jinfo：
  运行环境参数：Java System 属性和 JVM 命令行参数，Java class path 等信息。 命令格式：jinfo 进程 pid
  jstat：
  监视虚拟机各种运行状态信息的命令行工具。 命令格式：jstat -gc 123 250 20
  jstack：
  可以观察到 JVM 中当前所有线程的运行情况和线程当前状态。 命令格式：jstack 进程 pid
  jmap：
  观察运行中的 JVM 物理内存的占用情况（如：产生哪些对象，及其数量）。 命令格式：jmap [option] pid
  

- 4、CMS 收集器（多线程标记清除算法）

  Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间， 和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂。整个过程分为以下 4 个阶段：
  初始标记
  只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。
  并发标记
  进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。
  重新标记
  为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。
  并发清除
  清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作， 所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。
  

- 5、对象都是优先分配在年轻代上的吗？

  不是。当新生代内存不够时，老年代分配担保。而大对象则是直接在老年代分配。
  

- 6、有哪些 GC 算法？

  标记-清除算法
  分为标记和清除阶段，首先从每个 GC Roots 出发依次标记有引用关系的对象，最后清除没有标记的对象。
  执行效率不稳定，如果堆包含大量对象且大部分需要回收，必须进行大量标记清除，导致效率随对象数量增长而降低。
  存在内存空间碎片化问题，会产生大量不连续的内存碎片，导致以后需要分配大对象时容易触发 Full GC。
  标记-复制算法
  为了解决内存碎片问题，将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当使用的这块空间用完了，就将存活对象复制到另一块，再把已使用过的内存空间一次清理掉。主要用于进行新生代。
  实现简单、运行高效，解决了内存碎片问题。代价是可用内存缩小为原来的一半，浪费空间。
  HotSpot 把新生代划分为一块较大的 Eden 和两块较小的 Survivor，每次分配内存只使用 Eden 和其中一块 Survivor。垃圾收集时将 Eden 和 Survivor 中仍然存活的对象一次性复制到另一块 Survivor 上，然后直接清理掉 Eden 和已用过的那块 Survivor。HotSpot 默认Eden 和 Survivor 的大小比例是 8:1，即每次新生代中可用空间为整个新生代的 90%。
  标记-整理算法
  标记-复制算法在对象存活率高时要进行较多复制操作，效率低。如果不想浪费空间，就需要有额外空间分配担保，应对被使用内存中所有对象都存活的极端情况，所以老年代一般不使用此算法。
  老年代使用标记-整理算法，标记过程与标记-清除算法一样，但不直接清理可回收对象，而是让所有存活对象都向内存空间一端移动，然后清理掉边界以外的内存。
  标记-清除与标记-整理的差异在于前者是一种非移动式算法而后者是移动式的。如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活的区域，是一种极为负重的操作，而且移动必须全程暂停用户线程。如果不移动对象就会导致空间碎片问题，只能依赖更复杂的内存分配器和访问器解决。
  

- 7、有什么堆外内存的排查思路？

  进程占用的内存，可以使用top命令，看RES段占用的值。如果这个值大大超出我们设定的最大堆内存，则证明堆外内存占用了很大的区域。
  使用gdb可以将物理内存dump下来，通常能看到里面的内容。更加复杂的分析可以使用perf工具，或者谷歌开源的gperftools。那些申请内存最多的native函数，很容易就可以找到。
  

- 8、SWAP会影响性能么？

  当操作系统内存不足的时候，会将部分数据写入到SWAP交换分中，但是SWAP的性能是比较低的。如果应用的访问量较大，需要频繁申请和销毁内存，就容易发生卡顿。一般高并发场景下，会禁用SWAP。
  

- 9、你知道哪些JVM性能调优

  设定堆内存大小
  1、 -Xmx：堆内存最大限制。设定新生代大小。新生代不宜太小，否则会有大量对象涌入老年代
  2、 -XX:NewSize：新生代大小
  3、 -XX:NewRatio 新生代和老生代占比
  4、 -XX:SurvivorRatio：伊甸园空间和幸存者空间的占比
  5、 设定垃圾回收器 年轻代用 -XX:+UseParNewGC 年老代用-XX:+UseConcMarkSweepGC
  

- 10、你都有哪些手段用来排查内存溢出？

  （这个话题很大，可以从实践环节中随便摘一个进行总结，下面举例一个最普通的）
  你可以来一个中规中矩的回
  内存溢出包含很多种情况，我在平常工作中遇到最多的就是堆溢出。有一次线上遇到故障，重新启动后，使用jstat命令，发现Old区在一直增长。我使用jmap命令，导出了一份线上堆栈，然后使用MAT进行分析。通过对GC Roots的分析，我发现了一个非常大的HashMap对象，这个原本是有位同学做缓存用的，但是一个无界缓存，造成了堆内存占用一直上升。后来，将这个缓存改成 guava的Cache，并设置了弱引用，故障就消失了。
  这个回答不是十分出彩，但着实是常见问题，让人挑不出毛病。
  

- 11、JIT是什么？
- 12、Java 中堆和栈有什么区别？
- 13、方法区
- 14、你能保证 GC 执行吗？
- 15、说说G1垃圾收集器的工作原理
- 16、方法区的作用是什么？
- 17、ParNew 垃圾收集器（Serial+多线程）
- 18、你知道哪些内存分配与回收策略？
- 19、什么是栈
- 20、Minor Gc和Full GC 有什么不同呢？
- 21、JVM怎么判断一个对象是不是要回收？
- 22、说一下Java对象的创建过程
- 23、怎么看死锁的线程？
- 24、JVM垃圾回收机制，何时触发MinorGC等操作
- 25、GC垃圾回收算法与垃圾收集器的关系？
- 26、永久代
- 27、谈谈JVM中，对类加载器的认识
- 28、描述一下什么情况下，对象会从年轻代进入老年代
- 29、可达性分析
- 30、描述一下JVM加载class文件的原理机制？

### 4. 面试题4

- 1、类加载的过程是什么？

  加载
  该阶段虚拟机需要完成三件事：① 通过一个类的全限定类名获取定义类的二进制字节流。② 将字节流所代表的静态存储结构转化为方法区的运行时数据区。③ 在内存中生成对应该类的 Class 实例，作为方法区这个类的数据访问入口。
  验证
  确保 Class 文件的字节流符合约束。如果虚拟机不检查输入的字节流，可能因为载入有错误或恶意企图的字节流而导致系统受攻击。验证主要包含四个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证。
  验证重要但非必需，因为只有通过与否的区别，通过后对程序运行期没有任何影响。如果代码已被反复使用和验证过，在生产环境就可以考虑关闭大部分验证缩短类加载时间。
  准备
  为类静态变量分配内存并设置零值，该阶段进行的内存分配仅包括类变量，不包括实例变量。如果变量被 final 修饰，编译时 Javac 会为变量生成 ConstantValue 属性，准备阶段虚拟机会将变量值设为代码值。
  解析
  将常量池内的符号引用替换为直接引用。
  符号引用以一组符号描述引用目标，可以是任何形式的字面量，只要使用时能无歧义地定位目标即可。与虚拟机内存布局无关，引用目标不一定已经加载到虚拟机内存。
  直接引用是可以直接指向目标的指针、相对偏移量或能间接定位到目标的句柄。和虚拟机的内存布局相关，引用目标必须已在虚拟机的内存中存在。
  初始化
  直到该阶段 JVM 才开始执行类中编写的代码。准备阶段时变量赋过零值，初始化阶段会根据程序员的编码去初始化类变量和其他资源。初始化阶段就是执行类构造方法中的 `` 方法，该方法是 Javac 自动生成的。
  

- 2、谈谈 JVM 中的常量池

  JDK 1.8 开始
  1、 字符串常量池：存放在堆中，包括 String 对象执行 intern() 方法后存的地方、双引号直接引用的字符串
  2、 运行时常量池：存放在方法区，属于元空间，是类加载后的一些存储区域，大多数是类中 constant_pool 的内容
  3、 类文件常量池：constant_pool，JVM 定义的概念
  

- 3、JVM 内存区域

  JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。
  线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。
  线程共享区域随虚拟机的启动/关闭而创建/销毁。
  直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于Channel与 Buffer的IO方式, 它可以使用Native函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。
  

- 4、G1 收集器

  Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器， G1 收集器两个最突出的改进是：
  1、 基于标记-整理算法，不产生内存碎片。
  2、 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率
  

- 5、堆的作用是什么？

  堆是虚拟机所管理的内存中最大的一块，被所有线程共享的，在虚拟机启动时创建。堆用来存放对象实例，Java 里几乎所有对象实例都在堆分配内存。堆可以处于物理上不连续的内存空间，逻辑上应该连续，但对于例如数组这样的大对象，多数虚拟机实现出于简单、存储高效的考虑会要求连续的内存空间。
  堆既可以被实现成固定大小，也可以是可扩展的，可通过 -Xms 和 -Xmx 设置堆的最小和最大容量，当前主流 JVM 都按照可扩展实现。如果堆没有内存完成实例分配也无法扩展，抛出 OutOfMemoryError。
  

- 6、如何查看 JVM 当前使用的是什么垃圾收集器？

  -XX:+PrintCommandLineFlags 参数可以打印出所选垃圾收集器和堆空间大小等设置
  如果开启了 GC 日志详细信息，里面也会包含各代使用的垃圾收集器的简称
  

- 7、GC的回收流程是怎样的？

  GC回收流程如下：
  1、 对于整个的GC流程里面，那么最需要处理的就是新生代和老年代的内存清理操作，而元空间（永久代）都不在GC范围内
  2、 当现在有一个新的对象产生，那么对象一定需要内存空间，平均每个栈内存存4k，每个堆内存存8k，那么对象一定需要进行堆空间的申请
  3、 首先会判断Eden区是否有内存空间，如果此时有内存空间，则直接将新对象保存在伊甸园区。
  4、 但是如果此时在伊甸园区内存不足，那么会自动执行一个Minor GC 操作，将伊甸园区的无用内存空间进行清理，Minor GC的清理范围只在Eden园区，清理之后会继续判断Eden园区的内存空间是否充足？如果内存空间充足，则将新对象直接在Eden园区进行空间分配。
  5、 如果执行Minor GC 之后发现伊甸园区的内存空间依然不足，那么这个时候会执行存活区的判断，如果存活区有剩余空间，则将Eden园区部分活跃对象保存在存活区，那么随后继续判断Eden园区的内存空间是否充足，如果充足怎则将新对象直接在Eden园区进行空间分配。
  6、 此时如果存活区没有内存空间，则继续判断老年区。则将部分存活对象保存在老年代，而后存活区将有空余空间。
  7、 如果这个时候老年代也满了，那么这个时候将产生Major GC（Full GC）,那么这个时候将进行老年代的清理
  8、 如果老年代执行Full GC之后，无法进行对象的保存，则会产生OOM异常,OutOfMemoryError异常
  

- 8、类的实例化顺序

  1、 父类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行
  2、 子类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行
  3、 父类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行
  4、 父类构造方法
  5、 子类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行
  6、 子类构造方法
  

- 9、工作中常用的 JVM 配置参数有哪些？

  Java 8 为例
  日志
  1、 -XX:+PrintFlagsFinal，打印JVM所有参数的值
  2、 -XX:+PrintGC，打印GC信息
  3、 -XX:+PrintGCDetails，打印GC详细信息
  4、 -XX:+PrintGCTimeStamps，打印GC的时间戳
  5、 -Xloggc:filename，设置GC log文件的位置
  6、 -XX:+PrintTenuringDistribution，查看熬过收集后剩余对象的年龄分布信息
  内存设置
  1、 -Xms，设置堆的初始化内存大小
  2、 -Xmx，设置堆的最大内存
  3、 -Xmn，设置新生代内存大小
  4、 -Xss，设置线程栈大小
  5、 -XX:NewRatio，新生代与老年代比值
  6、 -XX:SurvivorRatio，新生代中Eden区与两个Survivor区的比值，默认为8，即Eden:Survivor:Survivor=8:1:1
  7、 -XX:MaxTenuringThreshold，从年轻代到老年代，最大晋升年龄。CMS 下默认为 6，G1 下默认为 15
  8、 -XX:MetaspaceSize，设置元空间的大小，第一次超过将触发 GC
  9、 -XX:MaxMetaspaceSize，元空间最大值
  10、 -XX:MaxDirectMemorySize，用于设置直接内存的最大值，限制通过 DirectByteBuffer 申请的内存
  11、 -XX:ReservedCodeCacheSize，用于设置 JIT 编译后的代码存放区大小，如果观察到这个值有限制，可以适当调大，一般够用即可
  设置垃圾收集相关
  1、 -XX:+UseSerialGC，设置串行收集器
  2、 -XX:+UseParallelGC，设置并行收集器
  3、 -XX:+UseConcMarkSweepGC，使用CMS收集器
  4、 -XX:ParallelGCThreads，设置Parallel GC的线程数
  5、 -XX:MaxGCPauseMillis，GC最大暂停时间 ms
  6、 -XX:+UseG1GC，使用G1垃圾收集器
  CMS 垃圾回收器相关
  1、 -XX:+UseCMSInitiatingOccupancyOnly
  2、 -XX:CMSInitiatingOccupancyFraction，与前者配合使用，指定MajorGC的发生时机
  3、 -XX:+ExplicitGCInvokesConcurrent，代码调用 System.gc() 开始并行 FullGC，建议加上这个参数
  4、 -XX:+CMSScavengeBeforeRemark，表示开启或关闭在 CMS 重新标记阶段之前的清除（YGC）尝试，它可以降低 remark 时间，建议加上
  5、 -XX:+ParallelRefProcEnabled，可以用来并行处理 Reference，以加快处理速度，缩短耗时
  G1 垃圾回收器相关
  1、 -XX:MaxGCPauseMillis，用于设置目标停顿时间，G1 会尽力达成
  2、 -XX:G1HeapRegionSize，用于设置小堆区大小，建议保持默认
  3、 -XX:InitiatingHeapOccupancyPercent，表示当整个堆内存使用达到一定比例（默认是 45%），并发标记阶段就会被启动
  4、 -XX:ConcGCThreads，表示并发垃圾收集器使用的线程数量，默认值随 JVM 运行的平台不同而变动，不建议修改
  参数查询官网地址：
  https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html
  建议面试时最好能记住 CMS 和 G1的参数，特点突出使用较多，被问的概率大
  

- 10、Java里有哪些引用类型？

  1、 强引用 这种引用属于最普通最强硬的一种存在，只有在和 GC Roots 断绝关系时，才会被消灭掉。
  2、 软引用 软引用用于维护一些可有可无的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。可以看到，这种特性非常适合用在缓存技术上。比如网页缓存、图片缓存等。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java 虚拟机就会把这个软引用加入到与之关联的引用队列中。
  3、 弱引用 弱引用对象相比较软引用，要更加无用一些，它拥有更短的生命周期。当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。弱引用拥有更短的生命周期，在 Java 中，用 java.lang.ref.WeakReference 类来表示。它的应用场景和软引用类似，可以在一些对内存更加敏感的系统里采用。
  4、 虚引用 这是一种形同虚设的引用，在现实场景中用的不是很多。虚引用必须和引用队列（ReferenceQueue）联合使用。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。实际上，虚引用的 get，总是返回 null。
  

- 11、本地方法区(线程私有)
- 12、什么是本地方法栈
- 13、栈溢出的原因？
- 14、Java的内存模型是什么？（JMM是什么？）
- 15、方法区溢出的原因？
- 16、JVM 监控与分析工具你用过哪些？介绍一下。
- 17、说说类加载的过程
- 18、MinorGC、MajorGC、FullGC 什么时候发生？
- 19、谈谈你知道的垃圾收集器
- 20、复制算法（copying）
- 21、垃圾收集算法
- 22、JVM的永久代中会发生垃圾回收么
- 23、类加载器双亲委派模型机制？
- 24、为什么需要双亲委派模式？
- 25、讲讲什么情况下会出现内存溢出，内存泄漏？
- 26、JVM 如何确定垃圾对象？
- 27、OSGI（ 动态模型系统）
- 28、你平时工作中用过的JVM常用基本配置参数有哪些？
- 29、invokedynamic指令是干什么的？
- 30、程序计数器
- 31、强引用、软引用、弱引用、虚引用是什么？

### 5. 面试题5

- 1、谈谈动态年龄判断

  1、 这里涉及到 -XX:TargetSurvivorRatio 参数，Survivor 区的目标使用率默认 50，即 Survivor 区对象目标使用率为 50%。
  2、 Survivor 区相同年龄所有对象大小的总和 (Survivor 区内存大小 * 这个目标使用率)时，大于或等于该年龄的对象直接进入老年代。
  3、 当然，这里还需要考虑参数 -XX:MaxTenuringThreshold 晋升年龄最大阈值
  

- 2、类初始化的情况有哪些？

  遇到 new、getstatic、putstatic 或 invokestatic 字节码指令时，还未初始化。典型场景包括 new 实例化对象、读取或设置静态字段、调用静态方法。
  对类反射调用时，还未初始化。
  初始化类时，父类还未初始化。
  虚拟机启动时，会先初始化包含 main 方法的主类。
  使用 JDK7 的动态语言支持时，如果 MethodHandle 实例的解析结果为指定类型的方法句柄且句柄对应的类还未初始化。
  口定义了默认方法，如果接口的实现类初始化，接口要在其之前初始化。
  其余所有引用类型的方式都不会触发初始化，称为被动引用。被动引用实例：① 子类使用父类的静态字段时，只有父类被初始化。② 通过数组定义使用类。③ 常量在编译期会存入调用类的常量池，不会初始化定义常量的类。
  接口和类加载过程的区别：初始化类时如果父类没有初始化需要初始化父类，但接口初始化时不要求父接口初始化，只有在真正使用父接口时（如引用接口中定义的常量）才会初始化。
  

- 3、GC 是什么？为什么要有 GC？

  GC 是垃 圾收 集的 意思 ，内存 处理 是编 程人 员容 易出 现问 题的 地方 ，忘记 或者 错误的内 存回 收会 导致 程序 或系 统的 不稳 定甚 至崩 溃， Java 提供 的 GC 功能 可以 自动监测 对象 是否 超过 作用 域从 而达 到自 动回 收内 存的 目的 ，Java 语言 没有 提供 释放已分配内存的 显示 操作 方法 。Java 程序 员不 用担 心内 存管 理， 因为 垃圾 收集 器会自动 进行 管理 。要 请求 垃圾 收集 ，可 以调 用下 面的 方法 之一 ：System.gc() 或Runtime.getRuntime().gc() ，但 JVM 可以 屏蔽 掉线 示的 垃圾 回收 调用 。
  垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在 Java 诞生初期，垃圾回收是 Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今 Java 的垃圾回收机制已经成为被诟病的东。移动智能终端用户通常觉得 iOS 的系统比 Android 系统有更好的用户体验，其中一个深层次的原因就在于 Android 系统中垃圾回收的不可预知性。
  

- 4、MinorGC，MajorGC、FullGC都什么时候发生？

  MinorGC在年轻代空间不足的时候发生，MajorGC指的是老年代的GC，出现MajorGC一般经常伴有MinorGC。
  FullGC有三种情况。
  1、 当老年代无法再分配内存的时候
  2、 元空间不足的时候
  3、 显示调用System.gc的时候。另外，像CMS一类的垃圾回收器，在MinorGC出现promotion failure的时候也会发生FullGC
  

- 5、Java的双亲委托机制是什么？

  它的意思是，除了顶层的启动类加载器以外，其余的类加载器，在加载之前，都会委派给它的父加载器进行加载。这样一层层向上传递，直到祖先们都无法胜任，它才会真正的加载。
  Java默认是这种行为。当然Java中也有很多打破双亲行为的骚操作，比如SPI（JDBC驱动加载），OSGI等。
  

- 6、在 Java 中，对象什么时候可以被垃圾回收？

  当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。
  

- 7、有哪些打破了双亲委托机制的案例？

  1、 Tomcat可以加载自己目录下的class文件，并不会传递给父类的加载器。
  2、 Java的SPI，发起者是 BootstrapClassLoader， BootstrapClassLoader已经是最上层的了。它直接获取了 AppClassLoader进行驱动加载，和双亲委派是相反的。。
  

- 8、JVM 年轻代到年老代的晋升过程的判断条件是什么呢？

  1、 部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代。
  2、 如果对象的大小大于Eden的二分之一会直接分配在old，如果old也分配不下，会做一次majorGC，如果小于eden的一半但是没有足够的空间，就进行minorgc也就是新生代GC。
  3、 minor gc后，survivor仍然放不下，则放到老年代
  4、 动态年龄判断 ，大于等于某个年龄的对象超过了survivor空间一半 ，大于等于某个年龄的对象直接进入老年代
  

- 9、JVM 数据运行区，哪些会造成 OOM 的情况？

  除了数据运行区，其他区域均有可能造成 OOM 的情况。
  **堆溢出：**java.lang.OutOfMemoryError: Java heap space
  **栈溢出：**java.lang.StackOverflowError
  **永久代溢出：**java.lang.OutOfMemoryError: PermGen space
  

- 10、JVM 类加载机制

  JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化。
  加载
  加载是类加载过程中的一个阶段， 这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象， 作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。
  验证
  这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
  准备
  准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：
  实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080， 将 v 赋值为 8080 的 put static 指令是程序被编译后， 存放于类构造器方法之中。
  但是注意如果声明为：
  public static final int v = 8080;
  在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080。
  解析
  解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的
  public static int v = 8080;
  实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080， 将 v 赋值为 8080 的 put static 指令是程序被编译后， 存放于类构造器方法之中。但是注意如果声明为：
  在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080。
  解析
  解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的
  public static final int v = 8080;
  在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080。
  解析
  解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：
  1、 CONSTANT_Class_info
  2、 CONSTANT_Field_info
  3、 CONSTANT_Method_info
  等类型的常量。
  符号引用
  符号引用与虚拟机实现的布局无关， 引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。
  直接引用
  直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。
  初始化
  初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。
  类构造器
  初始化阶段是执行类构造器方法的过程。方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子方法执行之前，父类的方法已经执行完毕， 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成()方法。
  注意以下几种情况不会执行类初始化：
  1、 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
  2、 定义对象数组，不会触发该类的初始化。
  3、 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。
  4、 通过类名获取 Class 对象，不会触发类的初始化。
  5、 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
  6、 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。
  

- 11、字符串常量存放在哪个区域？
- 12、对象的访问方式有哪些？
- 13、说一下 JVM 调优的工具？
- 14、对象分配内存是否线程安全？
- 15、什么时候会造成堆外内存溢出？
- 16、你都用过G1垃圾回收器的哪几个重要参数？
- 17、双亲委派
- 18、Parallel Old 收集器（多线程标记整理算法）
- 19、Java 程序是怎样运行的？
- 20、请解释StackOverflowError和OutOfMemeryError的区别？
- 21、分区收集算法
- 22、串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？
- 23、栈帧都有哪些数据？
- 24、对象在哪块内存分配？
- 25、运行时常量池溢出的原因？
- 26、safepoint 是什么？
- 27、JVM调优命令有哪些？
- 28、你说你做过JVM参数调优和参数配置，请问如何查看JVM系统默认值
- 29、Java 中会存在内存泄漏?简述一下
- 30、对象是怎么从年轻代进入老年代的？
- 31、什么情况下会发生栈内存溢出？

### 6. 面试题6

- 1、类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？

  双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。
  1、 假设有一个开发者自己编写了一个名为java.lang.Object的类，想借此欺骗JVM。现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类。
  2、 然而幸运的是，双亲委托模型不会让他成功。因为JVM会优先在Bootstrap ClassLoader的路径下找到java.lang.Object类，并载入它
  Java的类加载是否一定遵循双亲委托模型？
  1、 在实际开发中，我们可以通过自定义ClassLoader，并重写父类的loadClass方法，来打破这一机制。
  2、 SPI就是打破了双亲委托机制的(SPI：服务提供发现)。
  

- 2、生产环境 CPU 占用过高，你如何解决？

  1、 top + H 指令找出占用 CPU 最高的进程的 pid
  2、 top -H -p
  在该进程中找到，哪些线程占用的 CPU 最高的线程，记录下 tid
  3、 jstack -l
  threads.txt，导出进程的线程栈信息到文本，导出出现异常的话，加上 -F 参数
  4、 将 tid 转换为十六进制，在 threads.txt 中搜索，查到对应的线程代码执行栈，在代码中查找占 CPU 比较高的原因。其中 tid 转十六进制，可以借助 Linux 的 printf "%x" tid 指令
  我用上述方法查到过，jvm 多条线程疯狂 full gc 导致的CPU 100% 的问题和 JDK1.6 HashMap 并发 put 导致线程 CPU 100% 的问题
  

- 3、JVM 的内存模型是什么？

  JVM 试图定义一种统一的内存模型，能将各种底层硬件以及操作系统的内存访问差异进行封装，使 Java 程序在不同硬件以及操作系统上都能达到相同的并发效果。它分为工作内存和主内存，线程无法对主存储器直接进行操作，如果一个线程要和另外一个线程通信，那么只能通过主存进行交换。
  

- 4、你知道哪些GC类型？

  Minor GC：发生在年轻代的 GC。Major GC：发生在老年代的 GC。Full GC：全堆垃圾回收。比如 Metaspace 区引起年轻代和老年代的回收。
  

- 5、如何判断一个常量是废弃常量 ？

  运行时常量池主要回收的是废弃的常量。假如在常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。
  

- 6、对象的内存布局了解吗？

  对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。
  对象头占 12B，包括对象标记和类型指针。对象标记存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁标志、偏向线程 ID 等，这部分占 8B，称为 Mark Word。Mark Word 被设计为动态数据结构，以便在极小的空间存储更多数据，根据对象状态复用存储空间。
  类型指针是对象指向它的类型元数据的指针，占 4B。JVM 通过该指针来确定对象是哪个类的实例。
  实例数据是对象真正存储的有效信息，即本类对象的实例成员变量和所有可见的父类成员变量。存储顺序会受到虚拟机分配策略参数和字段在源码中定义顺序的影响。相同宽度的字段总是被分配到一起存放，在满足该前提条件的情况下父类中定义的变量会出现在子类之前。
  对齐填充不是必然存在的，仅起占位符作用。虚拟机的自动内存管理系统要求任何对象的大小必须是 8B 的倍数，对象头已被设为 8B 的 1 或 2 倍，如果对象实例数据部分没有对齐，需要对齐填充补全。
  

- 7、Java对象的布局了解过吗？

  对象头区域此处存储的信息包括两部分：
  1、对象自身的运行时数据( MarkWord )，占8字节 存储 hashCode、GC 分代年龄、锁类型标记、偏向锁线程 ID 、 CAS 锁指向线程 LockRecord 的指针等， synconized 锁的机制与这个部分( markwork )密切相关，用 markword 中最低的三位代表锁的状态，其中一位是偏向锁位，另外两位是普通锁位。
  2、对象类型指针( Class Pointer )，占4字节 对象指向它的类元数据的指针、 JVM 就是通过它来确定是哪个 Class 的实例。
  实例数据区域 此处存储的是对象真正有效的信息，比如对象中所有字段的内容
  对齐填充区域 JVM 的实现 HostSpot 规定对象的起始地址必须是 8 字节的整数倍，换句话来说，现在 64 位的 OS 往外读取数据的时候一次性读取 64bit 整数倍的数据，也就是 8 个字节，所以 HotSpot 为了高效读取对象，就做了"对齐"，如果一个对象实际占的内存大小不是 8byte 的整数倍时，就"补位"到 8byte 的整数倍。所以对齐填充区域的大小不是固定的。
  

- 8、谈谈双亲委派模型

  1、 Parents Delegation Model，这里的 Parents 翻译成双亲有点不妥，类加载向上传递的过程中只有单亲；parents 更多的是多级向上的意思。
  2、 除了顶层的启动类加载器，其他的类加载器在加载之前，都会委派给它的父加载器进行加载，一层层向上传递，直到所有父类加载器都无法加载，自己才会加载该类。
  3、 双亲委派模型，更好地解决了各个类加载器协作时基础类的一致性问题，避免类的重复加载；防止核心API库被随意篡改。
  JDK 9 之前
  1、 启动类加载器（Bootstrp ClassLoader），加载 /lib/rt.jar、-Xbootclasspath
  2、 扩展类加载器（Extension ClassLoader）sun.misc.Launcher$ExtClassLoader，加载 /lib/ext、java.ext.dirs
  3、 应用程序类加载器（Application ClassLoader，sun.misc.Launcher$AppClassLoader），加载 CLASSPTH、-classpath、-cp、Manifest
  4、 自定义类加载器
  JDK 9 开始 Extension ClassLoader 被 Platform ClassLoader 取代，启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader
  类加载代码逻辑
  protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    // 首先，检查请求的类是否已经被加载过了
    Class c = findLoadedClass(name);
    if (c == null) {
      try {
        if (parent != null) {
          c = parent.loadClass(name, false);
        } else {
          c = findBootstrapClassOrNull(name);
        }
      } catch (ClassNotFoundException e) {
        // 如果父类加载器抛出ClassNotFoundException
        // 说明父类加载器无法完成加载请求
      }
      if (c == null) {
        // 在父类加载器无法加载时
        // 再调用本身的findClass方法来进行类加载
        c = findClass(name);
      }
    }
    if (resolve) {
      resolveClass(c);
    }
    return c;
  }
  

- 9、CMS分为哪几个阶段?

  CMS已经弃用。生活美好，时间有限，不建议再深入研究了。如果碰到问题，直接祭出回收过程即可。
  1、 初始标记
  2、 并发标记
  3、 并发预清理
  4、 并发可取消的预清理
  5、 重新标记
  6、 并发清理
  

- 10、解释 Java 堆空间及 GC？

  当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。
  

- 11、调优命令有哪些？
- 12、Java 中 WeakReference 与 SoftReference 的区别？
- 13、JRE、JDK、JVM 及 JIT 之间有什么不同？
- 14、CMS都有哪些问题？
- 15、Java 8 为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢？
- 16、64 位 JVM 中，int 的长度是多数？
- 17、介绍一下 JVM 中垃圾收集器有哪些？ 他们特点分别是什么？
- 18、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代？
- 19、遇到过堆外内存溢出吗？
- 20、对象的访问定位有哪几种方式?
- 21、什么是分布式垃圾回收（DGC）？它是如何工作的？
- 22、遇到过元空间溢出吗？
- 23、说说ZGC垃圾收集器的工作原理
- 24、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
- 25、说说类加载的过程
- 26、Serial 垃圾收集器（单线程、 复制算法）
- 27、如何写一段简单的死锁代码？
- 28、如何找到死锁的线程？
- 29、直接内存是什么？
- 30、新生代与复制算法

## 第4章 MySQL（150道）

### 1. 面试题1

- 1、什么是存储过程？用什么来调用？

  存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。
  

- 2、优化数据库的方法

  1、  选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM
  2、  使用连接(JOIN)来代替子查询
  3、  适用联合(UNION)来代替手动创建的临时表
  4、  事务处理
  5、  锁定表、优化事务处理
  6、  适用外键，优化锁定表
  7、  建立索引
  8、  优化查询语句
  

- 3、完整性约束包括哪些？

  数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。
  分为以下四类：
  1、 实体完整性：规定表的每一行在表中是惟一的实体。
  2、 域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。
  3、 参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。
  4、 用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。
  与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、foreign key、check、UNIQUE) 。
  

- 4、使用B树的好处

  B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。
  

- 5、视图有哪些特点？哪些使用场景？

  「视图特点：」
  1、 视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。
  2、 视图是由基本表(实表)产生的表(虚表)。
  3、 视图的建立和删除不影响基本表。
  4、 对视图内容的更新(添加，删除和修改)直接影响基本表。
  5、 当视图来自多个基本表时，不允许添加和删除数据。
  「视图用途：」 简化sql查询，提高开发效率，兼容老的表结构。
  「视图的常见使用场景：」
  1、 重用SQL语句；
  2、 简化复杂的SQL操作。
  3、 使用表的组成部分而不是整个表；
  4、 保护数据
  5、 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。
  

- 6、事务是如何通过日志来实现的

  因为事务在修改页时，要先记 undo，在记 undo 之前要记 undo 的 redo， 然后修改数据页，再记数据页修改的 redo。 Redo（里面包括 undo 的修改） 一定要比数据页先持久化到磁盘。
  当事务需要回滚时，因为有 undo，可以把数据页回滚到前镜像的 状态，崩溃恢复时，如果 redo log 中事务没有对应的 commit 记录，那么需要用 undo把该事务的修改回滚到事务开始之前。
  如果有 commit 记录，就用 redo 前滚到该事务完成时并提交掉。
  

- 7、索引有哪几种类型？

  1、 主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。
  2、 唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。
  3、 普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。
  4、 全文索引：是目前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。
  5、 覆盖索引：查询列要被所建的索引覆盖，不必读取数据行
  6、 组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并
  

- 8、谈谈六种关联查询，使用场景。

  1、 交叉连接
  2、 内连接
  3、 外连接
  4、 联合查询
  5、 全连接
  6、 交叉连接
  

- 9、试述视图的优点？

  (1) 视图能够简化用户的操作 (2) 视图使用户能以多种角度看待同一数据； (3) 视图为数据库提供了一定程度的逻辑独立性； (4) 视图能够对机密数据提供安全保护。
  

- 10、MySQL自增主键用完了怎么办？

  自增主键一般用int类型，一般达不到最大值，可以考虑提前分库分表的。
  

- 11、为什么要尽量设定一个主键？
- 12、存储时期
- 13、创建索引的三种方式
- 14、为什么要使用数据库
- 15、实践中如何优化MySQL
- 16、MySQL如何优化DISTINCT？
- 17、什么是触发器？触发器的使用场景有哪些？
- 18、如何显示前50行？
- 20、B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？
- 21、MySQL中有哪几种锁，列举一下？
- 22、超键、候选键、主键、外键分别是什么？
- 23、为什么官方建议使用自增长主键作为索引？
- 24、什么情况下设置了索引但无法使用
- 25、MySQL中有哪几种锁，列举一下？
- 26、什么是基本表？什么是视图？
- 27、索引哪些情况会失效
- 28、一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。
- 29、视图有哪些特点？哪些使用场景？
- 30、数据表损坏的修复方式有哪些？

### 2. 面试题2

- 1、innoDB的B+Tree 存储整行数据和主键的值得区别？

  1、 整行数据：innoDB的B+Tree存储了整行数据的是主键索引，也被成为聚凑索引。
  2、 存储主键的值：成为非主键索引，也被称为非聚凑索引
  

- 2、读写分离常见方案？

  1、 应用程序根据业务逻辑来判断，增删改等写操作命令发给主库，查询命令发给备库。
  2、 利用中间件来做代理，负责对数据库的请求识别出读还是写，并分发到不同的数据库中。（如：amoeba，MySQL-proxy）
  

- 3、六种关联查询

  1、 交叉连接（CROSS JOIN）
  2、 内连接（INNER JOIN）
  3、 外连接（LEFT JOIN/RIGHT JOIN）
  4、 联合查询（UNION与UNION ALL）
  5、 全连接（FULL JOIN）
  6、 交叉连接（CROSS JOIN）
  SELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id=B.id或者SELECT * FROM A INNER JOIN B ON A.id=B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN
  内连接分为三类
  1、 等值连接：ON A.id=B.id
  2、 不等值连接：ON A.id > B.id
  3、 自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid
  外连接（LEFT JOIN/RIGHT JOIN）
  左外连接：
  LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN
  右外连接：
  RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN
  联合查询（UNION与UNION ALL）
  SELECT * FROM A UNION SELECT * FROM B UNION ...
  1、 就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并
  2、 如果使用UNION ALL，不会合并重复的记录行
  3、 效率 UNION 高于 UNION ALL
  全连接（FULL JOIN）
  SELECT * FROM A LEFT JOIN B ON A.id=B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id=B.id
  MySQL不支持全连接
  

- 4、什么是存储过程？有哪些优缺点？

  存储过程，就是一些编译好了的SQL语句，这些SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后给这些代码块取一个名字，在用到这个功能的时候调用即可。
  优点：
  1、 存储过程是一个预编译的代码块，执行效率比较高
  2、 存储过程在服务器端运行，减少客户端的压力
  3、 允许模块化程序设计，只需要创建一次过程，以后在程序中就可以调用该过程任意次，类似方法的复用
  4、 一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率
  5、 可以一定程度上确保数据安全
  缺点：
  1、 调试麻烦
  2、 可移植性不灵活
  3、 重新编译问题
  

- 5、优化关联查询

  1、 确定ON或者USING子句中是否有索引。
  2、 确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。
  

- 6、主键和候选键有什么区别？

  表格的每一行都由主键唯一标识,一个表只有一个主键。
  主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。
  

- 7、既然提到了InnoDB使用户的B+树的索引模型

  那么你知道为什么采用B+树吗？这和Hash索引比较起来有什么缺点吗？
  因为hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点，父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。
  

- 8、MySQL_fetch_array和MySQL_fetch_object的区别是什么？

  以下是MySQL_fetch_array和MySQL_fetch_object的区别：
  MySQL_fetch_array（） – 将结果行作为关联数组或来自数据库的常规数组返回。
  MySQL_fetch_object – 从数据库返回结果行作为对象。
  

- 9、对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题：

  1、 索引的目的是什么？
  快速访问数据表中的特定信息，提高检索速度
  创建唯一性索引，保证数据库表中每一行数据的唯一性。
  加速表和表之间的连接
  使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间
  2、 索引对数据库系统的负面影响是什么？
  负面影响：
  创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。
  3、 为数据表建立索引的原则有哪些？
  在最频繁使用的、用以缩小查询范围的字段上建立索引。
  在频繁使用的、需要排序的字段上建立索引
  4、 什么情况下不宜建立索引？
  对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。
  对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等
  

- 10、MySQL如何优化DISTINCT？

  DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。
  1
  SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;
  

- 11、什么是幻读，脏读，不可重复读呢？
- 12、linux添加索引
- 13、B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？
- 14、数据库中间件了解过吗，sharding jdbc，mycat？
- 15、为什么要使用视图？什么是视图？
- 16、NULL是什么意思
- 17、MySQL中InnoDB引擎的行锁是怎么实现的？
- 18、优化器的执行过程？
- 19、什么是最左前缀原则？什么是最左匹配原则
- 20、LIKE声明中的％和_是什么意思？
- 21、使用乐观锁
- 22、varchar(50)中50的涵义
- 23、主从同步延迟的解决办法
- 24、MySQL 遇到过死锁问题吗，你是如何解决的？
- 25、主键使用自增ID还是UUID，为什么？
- 26、什么是数据库事务？
- 27、怎么查询SQL语句是否使用了索引查询？
- 28、什么是死锁？怎么解决？
- 29、主键使用自增ID还是UUID？
- 30、MVCC熟悉吗，它的底层原理？

### 3. 面试题3

- 1、隔离级别与锁的关系

  回答这个问题，可以先阐述四种隔离级别，再阐述它们的实现原理。隔离级别就是依赖锁和MVCC实现的。
  

- 2、实践中如何优化MySQL

  最好是按照以下顺序优化：
  1、 SQL语句及索引的优化
  2、 数据库表结构的优化
  3、 系统配置的优化
  4、 硬件的优化
  

	- 详细可以查看 阿里P8架构师谈：MySQL慢查询优化、索引优化、以及表等优化总结

- 3、优化子查询

  1、 用关联查询替代
  2、 优化GROUP BY和DISTINCT
  3、 这两种查询据可以使用索引来优化，是最有效的优化方法
  4、 关联查询中，使用标识列分组的效率更高
  5、 如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。
  6、 WITH ROLLUP超级聚合，可以挪到应用程序处理
  

- 4、前缀索引

  1、 语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。
  2、 前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。
  3、 实操的难度：在于前缀截取的长度。
  4、 我们可以利用select count(*)/count(distinct left(password,prefixLen));，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）
  

- 5、MySQL5.6和MySQL5.7对索引做了哪些优化？

  1、 MySQL5.6引入了索引下推优化，默认是开启的。
  2、 例子：user表中（a,b,c）构成一个索引。
  3、 select * from user where a='23' and b like '%eqw%' and c like 'dasd'。
  4、 解释：如果没有索引下推原则，则MySQL会通过a='23' 先查询出一个对应的数据。然后返回到MySQL服务端。MySQL服务端再基于两个like模糊查询来校验and查询出的数据是否符合条件。这个过程就设计到回表操作。
  5、 如果使用了索引下推技术，则MySQL会首先返回返回条件a='23'的数据的索引，然后根据模糊查询的条件来校验索引行数据是否符合条件，如果符合条件，则直接根据索引来定位对应的数据，如果不符合直接reject掉。因此，有了索引下推优化，可以在有like条件的情况下，减少回表的次数。
  

- 6、MySQL有关权限的表有哪几个呢？

  MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在MySQL数据库里，由MySQL_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。
  1、 user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。
  2、 db权限表：记录各个帐号在各个数据库上的操作权限。
  3、 table_priv权限表：记录数据表级的操作权限。
  4、 columns_priv权限表：记录数据列级的操作权限。
  5、 host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。
  

- 7、MySQL中都有哪些触发器？

  MySQL 数据库中有六种触发器：
  1、 Before Insert
  2、 After Insert
  3、 Before Update
  4、 After Update
  5、 Before Delete
  6、 After Delete
  

- 8、大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？

  当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：
  1、 限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；
  2、 读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；
  3、 缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；
  还有就是通过分库分表的方式进行优化，主要有垂直分区、垂直分表和水平分区、水平分表
  垂直分区
  1、 根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。
  2、 简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。
  垂直拆分的优点：
  可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
  垂直拆分的缺点：
  主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；
  垂直分表
  把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中
  适用场景
  1、 如果一个表中某些列常用，另外一些列不常用
  2、 可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数
  缺点
  1、 有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差
  2、 对于应用层来说，逻辑算法增加开发成本
  3、 管理冗余列，查询所有数据需要join操作
  水平分区
  1、 保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。
  2、 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。
  1、 水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。
  2、 水平拆分能够支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨界点Join性能较差，逻辑复杂。
  《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。
  水平分表：
  表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数
  适用场景
  1、 表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。
  2、 需要把数据存放在多个介质上。
  水平切分的缺点
  1、 给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作
  2、 在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数
  数据库分片的两种常见方案：
  客户端代理：
  分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。
  中间件代理：
  在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。
  分库分表后面临的问题
  事务支持
  分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。
  跨库join
  只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品
  跨节点的count,order by,group by以及聚合函数问题
  这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。
  数据迁移，容量规划，扩容等问题
  来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。
  ID问题
  一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由、一些常见的主键生成策略
  UUID 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 Twitter的分布式自增ID算法Snowflake 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。
  跨分片的排序分页问题
  一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：
  

- 9、B+ Tree索引和Hash索引区别？

  1、 hash索引适合等值查询，但是无法进行范围查询。
  2、 hash索引没办法利用索引完成排序。
  3、 hash索引不支持多列联合索引的最左匹配规则。
  4、 如果有大量重复健值得情况下，hash索引的效率会很低，因为哈希碰撞问题。
  

- 10、数据库索引的原理，为什么要用 B+树，为什么不用二叉树？

  可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？
  为什么不是一般二叉树？
  如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。
  为什么不是平衡二叉树呢？
  我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。
  那为什么不是B树而是B+树呢？
  1）B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。
  2）B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。
  

- 11、MySQL的binlog有几种录入格式？分别有什么区别？
- 12、字段为什么要求定义为not null？
- 13、一条Sql的执行顺序？
- 14、SQL注入漏洞产生的原因？如何防止？
- 15、如何选择合适的分布式主键方案呢？
- 16、B树和B+树的区别，数据库为什么使用B+树而不是B树？
- 17、何时使用聚簇索引与非聚簇索引
- 18、你可以用什么来确保表格里的字段只接受特定范围里的值?
- 19、百万级别或以上的数据，你是如何删除的？
- 20、列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？
- 21、数据库的乐观锁和悲观锁是什么？怎么实现的？
- 22、什么是最左前缀原则？什么是最左匹配原则？
- 23、如果一个表有一列定义为TIMESTAMP，将发生什么？
- 24、说出一些数据库优化方面的经验?
- 25、select for update 含义
- 26、MyISAM索引与InnoDB索引的区别？
- 27、varchar(50)中50的涵义
- 28、完整性约束包括哪些？
- 29、索引的底层实现原理和优化
- 30、MySQL中int(20)和char(20)以及varchar(20)的区别

### 4. 面试题4

- 1、一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。

  1、 如果A表TID是自增长,并且是连续的,B表的ID为索引 select * from a,b where a.tid = b.id and a.tid>500000 limit 200;
  2、 如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。 select * from b , (select tid from a limit 50000,200) a where b.id = a .tid;
  

- 2、SQL语句优化的一些方法

  1、 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
  2、 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：
  select id from t where num is null
  -- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：
  select id from t where num=0
  3、 应尽量避免在 where 子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描。
  4、 应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：
  select id from t where num=10 or num=20
  -- 可以这样查询：
  select id from t where num=10 union all select id from t where num=20
  5、in 和 not in 也要慎用，否则会导致全表扫描，如：
  select id from t where num in(1,2,3) 
  -- 对于连续的数值，能用 between 就不要用 in 了：
  select id from t where num between 1 and 3
  6、 下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。
  7、 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：
  select id from t where num=@num
  -- 可以改为强制查询使用索引：
  select id from t with(index(索引名)) where num=@num
  8、 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：
  select id from t where num/2=100
  -- 应改为:
  select id from t where num=100*2
  9、 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：
  select id from t where substring(name,1,3)=’abc’
  -- name以abc开头的id应改为:
  select id from t where name like ‘abc%’
  10、 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
  

- 3、什么是数据库连接池?为什么需要数据库连接池呢?

  「连接池基本原理：」 数据库连接池原理：在内部对象池中，维护一定数量的数据库连接，并对外暴露数据库连接的获取和返回方法。
  「应用程序和数据库建立连接的过程：」
  1、 通过TCP协议的三次握手和数据库服务器建立连接
  2、 发送数据库用户账号密码，等待数据库验证用户身份
  3、 完成身份验证后，系统可以提交SQL语句到数据库执行
  

- 4、 把连接关闭，TCP四次挥手告别。

  「数据库连接池好处：」
  1、 资源重用 (连接复用)
  2、 更快的系统响应速度
  3、 新的资源分配手段
  4、 统一的连接管理，避免数据库连接泄漏
  4、事物的四大特性(ACID)介绍一下?
  关系性数据库需要遵循ACID规则，具体内容如下：
  ![99_6.png][99_6.png]
  1、 原子性：
  事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
  2、 一致性：
  执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
  3、 隔离性：
  并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
  4、 持久性：
  一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
  

- 5、索引分类？

  单列索引
  1、 普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。
  2、 唯一索引：索引列中的值必须是唯一的，但是允许为空值，
  3、 主键索引：是一种特殊的唯一索引，不允许有空值。
  组合索引：
  多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。
  全文索引：
  只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT    类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有"你是个靓仔，靓女 ..."   通过靓仔，可能就可以找到该条记录
  空间索引：
  空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。在创建空间索引时，使用SPATIAL关键字。要求，引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。
  

- 6、锁的优化策略

  1\、读写分离
  2\、分段加锁
  3\、减少锁持有的时间
  4\、多个线程尽量以相同的顺序去获取资源
  不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。
  

- 7、limit 1000000 加载很慢的话，你是怎么解决的呢？

  方案一：如果id是连续的，可以这样，返回上次查询的最大记录(偏移量)，再往下limit
  select id，name from employee where id>1000000 limit 10.
  方案二：在业务允许的情况下限制页数：
  建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。
  方案三：order by + 索引（id为索引）
  select id，name from employee order by id  limit 1000000，10
  方案四：利用延迟关联或者子查询优化超多分页场景。（先快速定位需要获取的id段，然后再关联）
  SELECT a.* FROM employee a, (select id from employee where 条件 LIMIT 1000000,10 ) b where a.id=b.id
  

- 8、什么是事务的隔离级别？MySQL的默认隔离级别是什么？

  为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。
  隔离级别	脏读	不可重复读	幻影读
  READ-UNCOMMITTED	√	√	√
  READ-COMMITTED	×	√	√
  REPEATABLE-READ	×	×	√
  SERIALIZABLE			
  SQL 标准定义了四个隔离级别：
  1、 READ-UNCOMMITTED(读取未提交)：
  最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
  2、 READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
  3、 REPEATABLE-READ(可重复读)：
  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
  4、 SERIALIZABLE(可串行化)：
  最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
  注意：
  1、 这里需要注意的是：MySQL 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别
  2、 事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。
  3、 因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。
  4、 InnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。
  

- 9、视图的使用场景有哪些？

  视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构
  下面是视图的常见使用场景：
  1、 重用SQL语句；
  2、 简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；
  3、 使用表的组成部分而不是整个表；
  4、 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；
  5、 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。
  

- 10、MYSQL数据库服务器性能分析的方法命令有哪些?

  Show status, 一些值得监控的变量值：
  1、 Bytes_received和Bytes_sent 和服务器之间来往的流量。
  2、 Com_*服务器正在执行的命令。
  3、 Created_*在查询执行期限间创建的临时表和文件。
  4、 Handler_*存储引擎操作。
  5、 Select_*不同类型的联接执行计划。
  6、 Sort_*几种排序信息。
  Show profiles 是MySql用来分析当前会话SQL语句执行的资源消耗情况
  

- 11、列值为NULL时，查询是否会用到索引？
- 12、MySQL里记录货币用什么字段类型好
- 13、在高并发情况下，如何做到安全的修改同一行数据？
- 14、B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，
- 15、SQL语言包括哪几部分？每部分都有哪些操作关键字？
- 16、优化特定类型的查询语句
- 17、什么是数据库事务？
- 18、谈谈MySQL的Explain
- 19、视图的优点，缺点，讲一下？
- 20、MyISAM Static和MyISAM Dynamic有什么区别？
- 21、隔离级别与锁的关系
- 22、如何优化长难的查询语句？有实战过吗？
- 23、B+Tree的页子节点都可以存放哪些东西？
- 24、SQL语句的语法顺序：
- 25、什么是锁？
- 26、你怎么看到为表格定义的所有索引？
- 27、MySQL里记录货币用什么字段类型比较好？
- 28、数据库的乐观锁和悲观锁。
- 29、MySQL有关权限的表都有哪几个？
- 30、索引不适合哪些场景

### 5. 面试题5

- 1、NOW（）和CURRENT_DATE（）有什么区别？

  NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。
  CURRENT_DATE（）仅显示当前年份，月份和日期。
  

- 2、CHAR和VARCHAR的区别？

  1.CHAR和VARCHAR类型在存储和检索方面有所不同
  2.CHAR列长度固定为创建表时声明的长度，长度值范围是1到255
  当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。
  

- 3、主键索引与唯一索引的区别

  1、 主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。
  2、 主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。
  3、 唯一性索引列允许空值，而主键列不允许为空值。
  4、 主键列在创建时，已经默认为空值 ++ 唯一索引了。
  5、 一个表最多只能创建一个主键，但可以创建多个唯一索引。
  6、 主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。
  7、 主键可以被其他表引用为外键，而唯一索引不能。 ？
  

- 4、MySQL中有哪些不同的表格？

  共有5种类型的表格：
  1、 MyISAM
  2、 Heap
  3、 Merge
  4、 INNODB
  5、 ISAM
  

- 5、SQL的生命周期？

  1、 应用服务器与数据库服务器建立一个连接
  2、 数据库进程拿到请求sql
  3、 解析并生成执行计划，执行
  4、 读取数据到内存并进行逻辑处理
  5、 通过步骤一的连接，发送结果到客户端
  6、 关掉连接，释放资源
  

- 6、你怎么看到为表格定义的所有索引？

  索引是通过以下方式为表格定义的：
  SHOW INDEX FROM <tablename>;
  

- 7、数据库为什么使用B+树而不是B树

  1、 B树只适合随机检索，而B+树同时支持随机检索和顺序检索；
  2、 B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；
  3、 B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。
  4、 B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。
  5、 增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。
  

- 8、数据库三大范式是什么

  第一范式：每个列都不可以再拆分。
  第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。
  第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。
  在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。
  

- 9、怎么优化SQL查询语句吗

  1、 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引
  2、 用索引可以提高查询
  3、 SELECT子句中避免使用*号，尽量全部大写SQL
  4、 应尽量避免在 where 子句中对字段进行 is null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，使用 IS NOT NULL
  5、 where 子句中使用 or 来连接条件，也会导致引擎放弃使用索引而进行全表扫描
  6、 in 和 not in 也要慎用，否则会导致全表扫描
  

- 10、覆盖索引、回表等这些，了解过吗？

  1、 覆盖索引： 查询列要被所建的索引覆盖，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。
  2、 回表：二级索引无法直接查询所有列的数据，所以通过二级索引查询到聚簇索引后，再查询到想要的数据，这种通过二级索引查询出来的过程，就叫做回表。
  

	- MySQL覆盖索引与回表

- 11、NULL是什么意思
- 12、MySQL中in 和exists的区别。
- 13、500台db，在最快时间之内重启。
- 14、MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？
- 15、NOW（）和CURRENT_DATE（）有什么区别？
- 16、超键、候选键、主键、外键分别是什么？
- 17、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？
- 18、为什么要使用视图？什么是视图？
- 19、索引的一些潜规则
- 20、myisamchk是用来做什么的？
- 21、如何在Unix和MySQL时间戳之间进行转换？
- 22、什么是索引？
- 23、日常工作中你是怎么优化SQL的？
- 24、MYSQL的主从延迟，你怎么解决？
- 25、索引的底层实现
- 26、SQL语言包括哪几部分？每部分都有哪些操作关键字？
- 27、500台db，在最快时间之内重启。
- 28、MySQL中TEXT数据类型的最大长度
- 29、数据库存储日期格式时，如何考虑时区转换问题？

## 第5章 MyBatis（60道）

### 1. MyBatis面试题

- 1、Hibernate 和 MyBatis 的区别

  相同点
  都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。
  不同点
  映射关系
  MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单
  Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂
  SQL优化和移植性
  Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。
  MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。
  

- 2、Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？

  第一种是使用标签，逐一定义列名和对象属性名之间的映射关系。
  第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对
  象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能
  找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工
  作。
  有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性
  逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。
  

- 3、Mybatis编程步骤 ？

  1、 创建SQLSessionFactory
  2、 通过SQLSessionFactory创建SQLSession
  3、 通过SQLSession执行数据库操作
  4、 调用session.commit()提交事物 Step5：调用session.close()关闭会话
  

- 4、Mapper 编写有哪几种方式？

  第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口，mapper 接口实现类、mapper.xml 文件
  1、 在 sqlMapConfig.xml 中配置 mapper.xml 的位置
  <mappers>
      <mapper resource="mapper.xml 文件的地址" />
      <mapper resource="mapper.xml 文件的地址" />
  </mappers>
  2、 定义 mapper 接口
  3、 实现类集成 SqlSessionDaoSupport
  mapper 方法中可以 this.getSqlSession()进行数据增删改查。
  4、 spring 配置
  <bean id=" " class="mapper 接口的实现">
      <property name="sqlSessionFactory"
      ref="sqlSessionFactory"></property>
  </bean>
  第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：
  1、 在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和mappre 接口的名称相同且在同一个目录，这里可以不用配置
  2、 定义 mapper 接口：
  <mappers>
      <mapper resource="mapper.xml 文件的地址" />
      <mapper resource="mapper.xml 文件的地址" />
  </mappers>
  3、 mapper.xml 中的 namespace 为 mapper 接口的地址
  4、 mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致
  5、 Spring 中定义
  <bean id="" class="org.mybatis.spring.mapper.MapperFactoryBean">
      <property name="mapperInterface" value="mapper 接口地址" />
      <property name="sqlSessionFactory" ref="sqlSessionFactory" />
  </bean>
  第三种：使用 mapper 扫描器：
  1、 mapper.xml 文件编写：
  mapper.xml 中的 namespace 为 mapper 接口的地址；
  mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；
  如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml中进行配置。
  2、 定义 mapper 接口：
  注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录
  3、 配置 mapper 扫描器：
  <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
      <property name="basePackage" value="mapper 接口包地址
      "></property>
      <property name="sqlSessionFactoryBeanName"
      value="sqlSessionFactory"/>
  </bean>
  4、 使用扫描器后从 spring 容器中获取 mapper 的实现对象。
  

- 5、Mybatis 是否可以映射 Enum 枚举类？

  Mybatis 可以映射枚举类，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一
  列上。映射方式为自定义一个 TypeHandler，实现 TypeHandler 的 setParameter()和
  getResult()接口方法。TypeHandler 有两个作用，一是完成从 javaType 至 jdbcType 的转换，
  二是完成 jdbcType 至 javaType 的转换，体现为 setParameter()和 getResult()两个方法，分别
  代表设置 sql 问号占位符参数和获取列查询结果。
  

- 6、Mybatis是如何进行分页的？分页插件的原理是什么？

  Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。
  分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。
  举例：
  select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10
  

- 7、Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？

  1、 Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association
  指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否
  启用延迟加载 lazyLoadingEnabled=true|false。
  2、 它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方
  法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单
  独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的
  对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原
  理。
  

- 8、什么是 MyBatis 的接口绑定,有什么好处？

  接口映射就是在 MyBatis 中任意定义接口,然后把接口里面的方法和 SQL 语句绑定,我们
  直接调用接口方法就可以,这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选
  择和设置.
  

- 9、Mybatis中如何指定使用哪一种Executor执行器？

  在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。
  配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。
  

- 10、在mapper中如何传递多个参数?

  1、 第一种：
  DAO层的函数
  public UserselectUser(String name,String area);
          对应的xml,#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数一致往后加即可。
  <select id="selectUser"resultMap="BaseResultMap">
      select *  fromuser_user_t   whereuser_name = #{0} anduser_area=#{1}
  </select>
  2、 第二种： 使用 @param 注解:
  public interface usermapper {
      user selectuser(@param(“username”) string username,@param(“hashedpassword”) string hashedpassword);
  }
  然后,就可以在xml像下面这样使用(推荐封装为一个map,作为单个参数传递给mapper):
  <select id=”selectuser” resulttype=”user”>
          select id, username, hashedpassword
          from some_table
          where username = #{username}
          and hashedpassword = #{hashedpassword}
          </select>
  3、 第三种：多个参数封装成map
  try {
          //映射文件的命名空间.SQL片段的ID，就可以调用对应的映射文件中的SQL
          //由于我们的参数超过了两个，而方法中只有一个Object参数收集，因此我们使用Map集合来装载我们的参数
          Map < String, Object > map = new HashMap();
          map.put("start", start);
          map.put("end", end);
          return sqlSession.selectList("StudentID.pagination", map);
          } catch (Exception e) {
          e.printStackTrace();
          sqlSession.rollback();
          throw e;
          } finally {
          MybatisUtil.closeSqlSession();
          }
  

- 11、传统JDBC开发存在什么问题？
- 12、MyBatis 实现一对一有几种方式?具体怎么操作的？
- 13、MyBatis的功能架构是怎样的
- 14、#{}和${}的区别
- 15、IBatis 和 MyBatis 在核心处理类分别叫什么？
- 16、Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？
- 17、Mybatis的编程步骤是什么样的？
- 18、MyBatis框架适用场合：
- 19、Mybatis映射文件中，如果A标签通过include引用了B标签的内容
- 20、Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？
- 21、MyBatis 的好处是什么？
- 22、使用MyBatis的mapper接口调用时有哪些要求？
- 23、#{}和${}的区别是什么？
- 24、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？
- 25、JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？

### 2. MyBatis面试题

- 1、Mybatis 分页查询？

  Mybatis本身有分页查询，但是并不是正真的分页查询，它是把数据查出来放在内存里面，你想要什么就给你什么。 我们使用Mybatis实现分页查询的时候，是要实现真分页查询，就是要用sql语句来实现分页查询。MySQL和Oracle两种数据库的实现方法是不一样的。 MySQL：select * from table limit N , M; 其中：N表示从第几页开始，M表示每页显示的条数。比如：数据库中有30条数据，要求每页显示10条，显示第2页的所有数据。 SQL语句就可以写成：Limit 10 , 20; Oracle实现分页查询：采用伪列ROWNUM
  

- 2、Mybatis能执行一对多，一对一的联系查询吗，有哪些实现方法

  能，不止可以一对多，一对一还可以多对多，一对多
  实现方式：
  1、 单独发送一个SQL去查询关联对象，赋给主对象，然后返回主对象
  2、 使用嵌套查询，似JOIN查询，一部分是A对象的属性值，另一部分是关联对 象 B的属性值，好处是只要发送一个属性值，就可以把主对象和关联对象查出来
  3、 子查询
  

- 3、使用 MyBatis 的 mapper 接口调用时有哪些要求？

	- 1、 Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同
	- 2、 Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的 parameterType 的类型相同
	- 3、 Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的 resultType 的类型相同
	- 4、 Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径。

- 4、MyBatis是什么？

	- Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。
	- MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。

- 5、#{}和${}的区别是什么？

	- Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用Prepared Statement的set方法来赋值；Mybatis在处理时，就是把{}替换成变量的值；使用#{}可以有效的防止SQL注入，提高系统安全性。

- 6、为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？

	- Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。

- 7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？

	- Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。
	- 而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。

- 8、什么情况下用注解绑定,什么情况下用 xml 绑定？

	- 当 Sql 语句比较简单时候,用注解绑定；当 SQL 语句比较复杂时候,用 xml 绑定,一般用xml 绑定的比较多

- 9、Mybais 常用注解 ？

	- @Insert ： 插入sql , 和xml insert sql语法完全一样
	- @Select ： 查询sql, 和xml select sql语法完全一样
	- @Update ： 更新sql, 和xml update sql语法完全一样
	- @Delete ： 删除sql, 和xml delete sql语法完全一样
	- @Param ： 入参
	- @Results ：结果集合
	- @Result ： 结果

- 10、MyBatis的框架架构设计是怎么样的

	- 这张图从上往下看。MyBatis的初始化，会从mybatis-config.xml配置文件，解析构造成Configuration这个类，就是图中的红框。
	- 1、 加载配置：配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。
	- 2、 SQL解析：当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数。
	- 3、 SQL执行：将最终得到的SQL和参数拿到数据库进行执行，得到操作数据库的结果。
	- 4、 结果映射：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、JavaBean或者基本数据类型，并将最终结果返回。

- 11、Mybaits的优点有什么？
- 12、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？
- 13、接口绑定有几种实现方式,分别是怎么实现的?
- 14、Mybaits的优点：
- 15、在mapper中如何传递多个参数
- 16、Mybatis是否可以映射Enum枚举类？
- 17、Mybatis的一级缓存和二级缓存？
- 18、Mybatis的映射文件 ？
- 19、Mybatis 比 IBatis 比较大的几个改进是什么？
- 20、什么是DBMS
- 21、什么是MyBatis的接口绑定？有哪些实现方式？
- 22、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？
- 23、#{}和${}的区别是什么？
- 24、MyBatis编程步骤是什么样的？
- 25、如何获取生成的主键

## 第6章 Spring（150道）

### 1. Spring面试题

- 1、什么是不同类型的微服务测试？

	- 在使用微服务时，由于有多个微服务协同工作，测试变得非常复杂。因此，测试分为不同的级别。
	- 在底层，我们有面向技术的测试，如单元测试和性能测试。这些是完全自动化的。
	- 在中间层面，我们进行了诸如压力测试和可用性测试之类的探索性测试。
	- 在顶层， 我们的 验收测试数量很少。这些验收测试有助于利益相关者理解和验证软件功能。

- 2、Nginx与Ribbon的区别

	- Nginx是反向代理同时可以实现负载均衡，nginx拦截客户端请求采用负载均衡策略根据upstream配置进行转发，相当于请求通过nginx服务器进行转发。Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端采用轮询策略对服务直接访问，全程在客户端操作。

- 3、什么是 Hystrix 断路器？我们需要它吗？

	- 由于某些原因，employee-consumer 公开服务会引发异常。在这种情况下使用 Hystrix 我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法返回一些默认值
	- 中断，并且员工使用者将一起跳过 firtsPage 方法，并直接调用回退方法。 断路器的目的是给第一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可能发生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。

- 4、SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？

	- 启动类上面的注解是@SpringBootApplication，它也是 SpringBoot 的核心注解，主要组合包含了以下 3 个注解：
	- @SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。
	- @EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。
	- @ComponentScan：Spring组件扫描。

- 5、什么是 AOP什么是目标对象?

	- 被一个或者多个切面所通知的对象。它通常是一个代理对象。也指被通知（advised）对象。

- 6、如何重新加载SpringBoot上的更改，而无需重新启动服务器？

	- 这可以使用DEV工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat将重新启动。
	- SpringBoot有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。
	- 开发人员可以重新加载SpringBoot上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。SpringBoot在发布它的第一个版本时没有这个功能。
	- 这是开发人员最需要的功能。DevTools模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供H2数据库控制台以更好地测试应用程序。

- 7、如何在自定义端口上运行 SpringBoot应用程序?

	- 在 application.properties中指定端口serverport=8090。

- 8、SpringBoot 有哪些优点？

	- SpringBoot 主要有如下优点：
	- 1、 容易上手，提升开发效率，为 Spring 开发提供一个更快、更简单的开发框架。
	- 2、 开箱即用，远离繁琐的配置。
	- 3、 提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。
	- 4、 SpringBoot总结就是使编码变简单、配置变简单、部署变简单、监控变简单等等

- 9、SpringBoot常用的starter有哪些？

	- 1、 spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持
	- 2、 spring-boot-starter-data-jpa 数据库支持
	- 3、 spring-boot-starter-data-Redis Redis数据库支持
	- 4、 spring-boot-starter-data-solr solr支持
	- 5、 mybatis-spring-boot-starter 第三方的mybatis集成starter

- 10、如何实现 SpringBoot 应用程序的安全性？

	- 为了实现 SpringBoot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。

- 11、什么是Spring Actuator？它有什么优势？
- 12、SpringData 项目所支持的关系数据存储技术：
- 13、什么是SpringBoot ？
- 14、Spring框架的事务管理有哪些优点？
- 15、什么是 AOP 代理?
- 16、Async异步调用方法
- 17、使用Spring框架的好处是什么？
- 18、解释JDBC抽象和DAO模块。
- 19、SpringBoot、Spring MVC 和 Spring 有什么区别？
- 20、@ResponseBody注解的作用
- 21、什么是微服务
- 22、ZuulFilter常用有那些方法
- 23、可以通过多少种方式完成依赖注入？
- 24、链路跟踪Sleuth
- 25、SpringBoot 最大的优势是什么呢？
- 26、在Spring AOP 中，关注点和横切关注的区别是什么？
- 27、开启SpringBoot特性有哪几种方式？（创建SpringBoot项目的两种方式）
- 28、@Required 注解有什么用？
- 29、什么是Spring的MVC框架？
- 30、运行 SpringBoot 有哪几种方式？
- 31、如何实现动态Zuul网关路由转发

### 2. Spring面试题

- 1、SpringBoot运行项目的几种方式？

	- 打包用命令或者放到容器中运行
	- 1、 打成jar包，使用java -jar xxx.jar运行
	- 2、 打成war包，放到tomcat里面运行
	- 直接用maven插件运行 maven spring-boot：run
	- 直接执行main方法运行

- 2、IOC的优点是什么？

	- IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。

- 3、在Spring MVC应用程序中使用WebMvcTest注释有什么用处？

	- WebMvcTest注释用于单元测试Spring MVC应用程序。我们只想启动ToTestController。执行此单元测试时，不会启动所有其他控制器和映射。
	- @WebMvcTest(value = ToTestController.class, secure = false):

- 4、什么是Spring Cloud？

	- 根据Spring Cloud的官方网站，Spring Cloud为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，领导选举，分布式会话，集群状态）。

- 5、eureka服务注册与发现原理

	- 1、 每30s发送⼼跳检测重新进⾏租约，如果客户端不能多次更新租约，它将在90s内从服务器注册中⼼移除。
	- 2、 注册信息和更新会被复制到其他Eureka 节点，来⾃任何区域的客户端可以查找到注册中⼼信息，每30s发⽣⼀次复制来定位他们的服务，并进⾏远程调⽤。
	- 3、 客户端还可以缓存⼀些服务实例信息，所以即使Eureka全挂掉，客户端也是可以定位到服务地址的。

- 6、SpringBoot 配置文件的加载顺序

	- 由jar包外向jar包内进行寻找;
	- 优先加载带profile
	- jar包外部的application-{profile}.properties或application.yml(带spring.profile配置文件
	- jar包内部的application-{profile}.properties或application.yml(带spring.profile配置文件
	- 再来加载不带profile
	- jar包外部的application.properties或application.yml(不带spring.profile配置文件
	- jar包内部的application.properties或application.yml(不带spring.profile配置文件

- 7、什么是 spring 装配

	- 当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。

- 8、为什么要用SpringBoot

	- 快速开发，快速整合，配置简化、内嵌服务容器

- 9、怎么样把ModelMap里面的数据放入Session里面？

	- 可以在类上面加上@SessionAttributes注解,里面包含的字符串就是要放入session里面的key。

- 10、什么是微服务架构中的DRY？

	- DRY代表不要重复自己。它基本上促进了重用代码的概念。这导致开发和共享库，这反过来导致紧密耦合。

- 11、使用Spring Cloud有什么优势？
- 12、负载平衡的意义什么？
- 13、SpringBoot 中的 starter 到底是什么 ?
- 14、Spring对DAO的支持
- 15、介绍一下 WebApplicationContext
- 16、什么是 Spring Framework？
- 17、为什么要使用 Spring Cloud 熔断器？
- 18、Spring Cloud的版本关系
- 19、SpringBoot、Spring MVC 和 Spring 有什么区别
- 20、DiscoveryClient的作用
- 21、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?
- 22、什么是Spring的内部bean？
- 23、SpringBoot 的核心配置文件有哪几个？它们的区别是什么？
- 24、网关与过滤器有什么区别
- 25、描述一下 DispatcherServlet 的工作流程
- 26、SpringBoot集成mybatis的过程
- 27、什么是 Aspect 切面
- 28、Spring Cloud Gateway
- 29、Zuul网关如何搭建集群
- 30、什么是 JavaConfig？
- 31、使用 SpringBoot 启动连接到内存数据库 H2 的 JPA 应用程序需要哪些依赖项？

### 3. Spring面试题

- 1、SpringBoot 的配置文件有哪几种格式？它们有什么区别？
- .properties 和 .yml，它们的区别主要是书写格式不同。
- 1、 properties
- app.user.name = javastack
- 2、 yml
- app:
-  user:
-  name: javastack
- 另外，.yml 格式不支持 @PropertySource 注解导入配置。
- 2、如何重新加载 SpringBoot上的更改，而无需重新启动服务器？
- 使用DEV工具来实现。 通过这种依赖关系，可以节省任何更改，嵌入式 tomcat将重新启动。 使用SpringBoot有一个开发工具Dev Tools模块，可以重新加载 SpringBoot上的更改，而无需重新启动服务器。消除每次手动部署更改的需要。 SpringBoot在发布它的第一个版本时没有这个功能。该模块将在生产环境中被禁用。它还提供H2数据库控制台以更好地测试应用程序。
- 3、创建一个 SpringBoot Project 的最简单的方法是什么？
- Spring Initializr是启动 SpringBoot Projects 的一个很好的工具。
- 我们需要做一下几步：
- 1、 登录 Spring Initializr，按照以下方式进行选择：
- 2、 选择 com.in28minutes.SpringBoot 为组
- 3、 选择 studet-services 为组件
- 4、 选择下面的依赖项
- Web
- Actuator
- DevTools
- 5、 点击生 GenerateProject
- 6、 将项目导入 Eclipse。文件 - 导入 - 现有的 Maven 项目
- 4、SpringBoot 2、X 有什么新特性？与 1、X 有什么区别？
- 1、 配置变更
- 2、 JDK 版本升级
- 3、 第三方类库升级
- 4、 响应式 Spring 编程支持
- 5、 HTTP/2 支持
- 6、 配置属性绑定
- 7、 更多改进与加强
- 5、为什么要选择微服务架构？
- 这是一个非常常见的微服务面试问题，你应该准备好了！微服务架构提供了许多优点。这里有几个：
- 1、 微服务可以轻松适应其他框架或技术。
- 2、 单个进程的失败不会影响整个系统。
- 3、 为大企业和小型团队提供支持。
- 4、 可以在相对较短的时间内独立部署。
- 6、什么是 CSRF 攻击？
- CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。
- 7、什么是SpringBoot？
- 多年来，随着新功能的增加，spring变得越来越复杂。只需访问https://spring.io/projects 页面，我们就会看到可以在我们的应用程序中使用的所有Spring项目的不同功能。如果必须启动一个新的Spring项目，我们必须添加构建路径或添加Maven依赖关系，配置应用程序服务器，添加spring配置。因此，开始一个新的spring项目需要很多努力，因为我们现在必须从头开始做所有事情。
- SpringBoot是解决这个问题的方法。SpringBoot已经建立在现有spring框架之上。使用spring启动，我们避免了之前我们必须做的所有样板代码和配置。因此，SpringBoot可以帮助我们以最少的工作量，更加健壮地使用现有的Spring功能。
- 8、SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？
- 启动类上面的注解是@SpringBootApplication，它也是 SpringBoot 的核心注解，主要组合包含了以下 3 个注解：
- @SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。
- @EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：
- @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。
- @ComponentScan：Spring组件扫描。
- 9、为什么我们需要微服务容器？
- 要管理基于微服务的应用程序，容器是最简单的选择。它帮助用户单独部署和开发。您还可以使用Docker将微服务封装到容器的镜像中。没有任何额外的依赖或工作，微服务可以使用这些元素。
- 10、微服务之间是如何独⽴通讯的
- 1、 Dubbo 使⽤的是 RPC 通信，⼆进制传输，占⽤带宽⼩；
- 2、 Spring Cloud 使⽤的是 HTTP RESTFul ⽅式。
- 11、SpringBoot 实现热部署有哪几种方式？
- 12、Spring MVC 框架有什么用？
- 13、微服务架构有哪些优势？
- 14、SpringBoot 有哪几种读取配置的方式？
- 15、列举 Spring Framework 的优点。
- 16、运行 SpringBoot 有哪几种方式？
- 17、Spring Cloud Bus
- 18、spring-boot-starter-parent 有什么用 ?
- 19、解释不同方式的自动装配
- 20、什么是耦合？
- 21、为什么人们会犹豫使用微服务？
- 22、运行 SpringBoot 有哪几种方式？
- 23、什么是无所不在的语言？
- 24、有哪些不同类型的IOC（依赖注入）方式？
- 25、SpringCloud Config 可以实现实时刷新吗？
- 26、如何在自定义端口上运行 SpringBoot 应用程序？
- 27、为什么我们需要 spring-boot-maven-plugin?
- 28、什么是JavaConfig？
- 29、列举 Spring Framework 的优点。
- 30、负载平衡的意义什么？
- 31、spring cloud 断路器的作用是什么？

### 4. Spring面试题

- 1、什么是REST / RESTful以及它的用途是什么？
- Representational State Transfer（REST）/ RESTful Web服务是一种帮助计算机系统通过Internet进行通信的架构风格。这使得微服务更容易理解和实现。
- 微服务可以使用或不使用RESTful API实现，但使用RESTful API构建松散耦合的微服务总是更容易。
- 2、如何在SpringBoot中禁用Actuator端点安全性？
- 默认情况下，所有敏感的HTTP端点都是安全的，只有具有ACTUATOR角色的用户才能访问它们。安全性是使用标准的HttpServletRequest.isUserInRole方法实施的。 我们可以使用
- 来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。
- 3、您使用了哪些 starter maven 依赖项？
- 使用了下面的一些依赖项：
- spring-boot-starter-activemq
- spring-boot-starter-security
- 这有助于增加更少的依赖关系，并减少版本的冲突。
- 4、什么是 AOP 引入?
- 引入允许我们在已存在的类中增加新的方法和属性。
- 5、我们如何监视所有 SpringBoot 微服务？
- SpringBoot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。
- 6、如何使用 SpringBoot 部署到不同的服务器？
- 你需要做下面两个步骤：
- 在一个项目中生成一个 war 文件。
- 将它部署到你最喜欢的服务器（websphere 或者 Weblogic 或者 Tomcat and so on）。
- **第一步：**这本入门指南应该有所帮助：
- https://spring.io/guides/gs/convert-jar-to-war/
- **第二步：**取决于你的服务器。
- 7、SpringBoot 自动配置原理是什么？
- 注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，
- @EnableAutoConfiguration 给容器导入META-INF/spring.factories 里定义的自动配置类。
- 筛选有效的自动配置类。
- 每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能
- 8、SpringBoot 的配置文件有哪几种格式？它们有什么区别？
- .properties 和 .yml，它们的区别主要是书写格式不同。
- properties
- app.user.name = javastack
- yml
- app:
-   user:
-     name: javastack
- 9、Zookeeper如何 保证CP
- 当向注册中⼼查询服务列表时，我们可以容忍注册中⼼返回的是⼏分钟以前的注册信息，但不能接受服务直接down掉不可⽤。也就是说，服务注册功能对可⽤性的要求要⾼于⼀致性。但是zk会出现这样⼀种情况，当master节点因为⽹络故障与其他节点失去联系时，剩余节点会重新进⾏leader选举。问题在于，选举leader的时间太⻓，30 ~ 120s, 且选举期间整个zk集群都是不可⽤的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因⽹络问题使得zk集群失去master节点是较⼤概率会发⽣的事，虽然服务能够最终恢复，但是漫⻓的选举时间导致的注册⻓期不可⽤是不能容忍的。
- 10、SpringCloud主要项目
- Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架"SpringBoot化"的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是Kafka, ActiveMQ这样的角色。
- 11、什么是 Spring Batch?
- 12、SpringBoot 如何设置支持跨域请求？
- 13、Spring Cloud Security
- 14、解释Spring框架中bean的生命周期。
- 15、我们如何连接一个像 MySQL 或者Orcale 一样的外部数据库？
- 16、@Required 注解有什么用？
- 17、什么是Spring beans?
- 18、Spring Cloud和SpringBoot版本对应关系
- 19、如果在拦截请求中，我想拦截get方式提交的方法,怎么配置
- 20、什么是YAML？
- 21、运行 SpringBoot 有哪几种方式？
- 22、spring 提供了哪些配置方式？
- 23、如何在 SpringBoot 启动的时候运行一些特定的代码？
- 24、如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？
- 25、康威定律是什么？
- 26、什么是 AOP Aspect 切面
- 27、什么是切点（JoinPoint）
- 28、SpringBoot如何实现打包
- 29、如何使用 SpringBoot 实现分页和排序？
- 30、保护 SpringBoot 应用有哪些方法？
- 31、什么是Netflix Feign？它的优点是什么？

### 5. Spring面试题

- 1、为什么我们不建议在实际的应用程序中使用 Spring Data Rest?
- 我们认为 Spring Data Rest 很适合快速原型制造！在大型应用程序中使用需要谨慎。
- 通过 Spring Data REST 你可以把你的数据实体作为 RESTful 服务直接。
- 当你设计 RESTful 服务器的时候，最佳实践表明，你的接口应该考虑到两件重要的事情：
- 你的模型范围。
- 你的客户。
- 通过 With Spring Data REST，你不需要再考虑这两个方面，只需要作为 TEST 服务实体。
- 这就是为什么我们建议使用 Spring Data Rest 在快速原型构造上面，或者作为项目的初始解决方法。对于完整演变项目来说，这并不是一个好的注意。
- 2、Ribbon是什么？
- 1、 Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法
- 2、 Ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等。简单的说，就是在配置文件中列出后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。（有点类似Nginx）
- 3、如何禁用特定的自动配置类？
- 若发现任何不愿使用的特定自动配置类，可以使用@EnableAutoConfiguration的排除属性。
- //By using "exclude"
- @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
- 另一方面，如果类别不在类路径上，则可以使用excludeName类注解，并且指定完全限定名。
- //By using "excludeName"
- @EnableAutoConfiguration(excludeName={Foo.class})
- 此外，SpringBoot还具有控制排除自动配置类列表的功能，可以通过使用spring.autoconfigure.exclude property来实现。可以将其添加到 propertie应用程序中，并且可以添加逗号分隔的多个类。
- //By using property file
- spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
- 4、自动装配有哪些方式？
- Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。
- 自动装配的不同模式：
- 1、 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。byName
- 2、 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。byType
- 3、 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。构造函数
- 4、 它通过调用类的构造函数来注入依赖项。它有大量的参数。autodetect
- 5、 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。
- 5、spring 支持集中 bean scope？
- Spring bean 支持 5 种 scope：
- 1、 Singleton - 每个 Spring IoC 容器仅有一个单实例。
- 2、 Prototype - 每次请求都会产生一个新的实例。
- 3、 Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。
- 4、 Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。
- 5、 Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。 Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。 在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。 如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。
- 6、 仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。
- 6、SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？
- 启动类上面的注解是@SpringBootApplication，它也是 SpringBoot 的核心注解，主要组合包含了以下 3 个注解：
- @SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。
- @EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项， 例如：java 如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration、class })。
- @ComponentScan：Spring组件扫描。
- 7、什么是 Spring Framework？
- 1、 Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。
- 2、 它是轻量级、松散耦合的。
- 3、 它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。
- 4、 它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。
- 8、如何不通过任何配置来选择 Hibernate 作为 JPA 的默认实现？
- 因为 SpringBoot 是自动配置的。
- 下面是我们添加的依赖项:
- spring-boot-stater-data-jpa 对于 Hibernate 和 JPA 有过渡依赖性。
- 当 SpringBoot 在类路径中检测到 Hibernate 中，将会自动配置它为默认的 JPA 实现。
- 9、Spring由哪些模块组成?
- 以下是Spring 框架的基本模块：
- 1、 Core module
- 2、 Bean module
- 3、 Context module
- 4、 Expression Language module
- 5、 JDBC module
- 6、 ORM module
- 7、 OXM module
- 8、 Java Messaging Service(JMS) module
- 9、 Transaction module
- 10、 Web module
- 11、 Web-Servlet module
- 12、 Web-Struts module
- 13、 Web-Portlet module
- 10、什么是双因素身份验证？
- 双因素身份验证为帐户登录过程启用第二级身份验证。
- 图11： 双因素认证的表示 – 微服务访谈问题
- 因此，假设用户必须只输入用户名和密码，那么这被认为是单因素身份验证。
- 11、SpringBoot 可以兼容老 Spring 项目吗，如何做？
- 12、什么是DispatcherServlet
- 13、SpringBoot如何配置log4j？
- 14、spring 支持哪些 ORM 框架
- 15、Spring Cloud Task
- 16、什么是 spring 的内部 bean？
- 17、什么是 AOP 连接点
- 18、Mock或Stub有什么区别？
- 19、什么是feigin？它的优点是什么？
- 20、解释基于注解的切面实现
- 21、你如何理解 SpringBoot 配置加载顺序？
- 22、SpringBoot 打成的 jar 和普通的 jar 有什么区别 ?
- 23、Spring Cloud Zookeeper
- 24、什么是织入。什么是织入应用的不同点？
- 25、如何覆盖SpringBoot项目的默认属性？
- 26、我们如何监视所有SpringBoot微服务？
- 27、什么是SpringBoot？
- 28、服务雪崩效应产生的原因
- 29、使用Spring通过什么方式访问Hibernate?
- 30、如何使用SpringBoot实现分页和排序？
- 31、SpringBoot 2.X 有什么新特性？与 1.X 有什么区别？

## 第7章 SpringBoot（150道）

### 1. SpringBoot面试题

- 1、spring-boot-starter-parent 有什么用 ?
- 我们都知道，新创建一个 SpringBoot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：
- 1、 定义了 Java 编译版本为 1.8 。
- 2、 使用 UTF-8 格式编码。
- 3、 继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。
- 4、 执行打包操作的配置。
- 5、 自动化的资源过滤。
- 6、 自动化的插件配置。
- 7、 针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。
- 2、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。
- cas和oauth是一个解决单点登录的组件，shiro主要是负责权限安全方面的工作，所以功能点不一致。但往往需要单点登陆和权限控制一起来使用，所以就有 cas+shiro或者oauth+shiro这样的组合。
- token一般是客户端登录后服务端生成的令牌，每次访问服务端会进行校验，一般保存到内存即可，也可以放到其他介质；Redis可以做Session共享，如果前端web服务器有几台负载，但是需要保持用户登录的状态，这场景使用比较常见。
- 我们公司使用oauth+shiro这样的方式来做后台权限的管理，oauth负责多后台统一登录认证，shiro负责给登录用户赋予不同的访问权限。
- 3、SpringBoot、Spring MVC 和 Spring 有什么区别？
- 1、 Spring
- Spring最重要的特征是依赖注入。所有 SpringModules 不是依赖注入就是 IOC 控制反转。
- 当我们恰当的使用 DI 或者是 IOC 的时候，我们可以开发松耦合应用。松耦合应用的单元测试可以很容易的进行。
- 2、 Spring MVC
- Spring MVC 提供了一种分离式的方法来开发 Web 应用。通过运用像 DispatcherServelet，MoudlAndView 和 ViewResolver 等一些简单的概念，开发 Web 应用将会变的非常简单。
- 3、 SpringBoot
- Spring 和 SpringMVC 的问题在于需要配置大量的参数。
- SpringBoot 通过一个自动配置和启动的项来目解决这个问题。为了更快的构建产品就绪应用程序，SpringBoot 提供了一些非功能性特征。
- 4、什么是SpringBoot
- 1、 用来简化spring应用的初始搭建以及开发过程 使用特定的方式来进行配置（properties或yml文件）
- 2、 创建独立的spring引用程序 main方法运行
- 3、 嵌入的Tomcat 无需部署war文件
- 4、 简化maven配置
- 5、开启 SpringBoot 特性有哪几种方式？
- 1、 继承spring-boot-starter-parent项目
- 2、 导入spring-boot-dependencies项目依赖
- 6、什么是YAML?
- YAML是一种人类可读的数据序列化语言。它通常用于配置文件。 与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML文件就更加结构化，而且更少混淆。可以看出YAML具有分层配置数据。
- 7、什么是Spring Profiles？
- Spring Profiles允许用户根据配置文件（dev，test，prod等）来注册bean。因此，当应用程序在开发中运行时，只有某些bean可以加载，而在PRODUCTION中，某些其他bean可以加载。假设我们的要求是Swagger文档仅适用于QA环境，并且禁用所有其他文档。这可以使用配置文件来完成。SpringBoot使得使用配置文件非常简单。
- 8、如何在 SpringBoot 中添加通用的 JS 代码？
- 在源文件夹下，创建一个名为 static 的文件夹。然后，你可以把你的静态的内容放在这里面。
- 例如，myapp.js 的路径是 resources\static\js\myapp.js
- **
- 你可以参考它在 jsp 中的使用方法：**
- 错误：HAL browser gives me unauthorized error - Full authenticaition is required to access this resource.
- 该如何来修复这个错误呢？
- 两种方法：
- 方法 1：关闭安全验证
- application.properties
- management.security.enabled:FALSE
- 方法二：在日志中搜索密码并传递至请求标头中
- 9、SpringBoot 有哪几种读取配置的方式？
- SpringBoot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationProperties 来绑定变量。
- 10、SpringBoot 是否可以使用 XML 配置 ?
- SpringBoot 推荐使用 Java 配置而非 XML 配置，但是 SpringBoot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。
- 11、如何重新加载 SpringBoot 上的更改，而无需重新启动服务器？SpringBoot项目如何热部署？
- 12、什么是 Spring Batch？
- 13、什么是 Spring Data REST?
- 14、什么是 JavaConfig？
- 15、什么是SpringBoot？
- 16、我们如何连接一个像 MySQL 或者Orcale 一样的外部数据库？
- 17、SpringBoot中的监视器是什么?
- 18、SpringBoot有哪些优点？
- 19、保护 SpringBoot 应用有哪些方法？
- 20、创建一个 SpringBoot Project 的最简单的方法是什么？
- 21、如何在自定义端口上运行 SpringBoot 应用程序？
- 22、什么是YAML？
- 23、SpringBoot 如何设置支持跨域请求？
- 24、SpringBoot 打成的 jar 和普通的 jar 有什么区别 ?
- 25、SpringBoot 配置文件的加载顺序
- 26、SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？
- 27、SpringBoot 支持哪些日志框架？推荐和默认的日志框架是哪个？
- 28、如何使用 SpringBoot 实现分页和排序？
- 29、Springboot 有哪些优点？
- 30、SpringBoot 有哪些优点？
- 31、SpringBoot性能如何优化

### 2. SpringBoot面试题

- 1、SpringBoot自动配置的原理是什么？
- SpringBoot启动的时候通过@EnableAutoConfiguration注解找到META-INF/spring.factories配置文件中所有的自动配置类，并对其进行加载，而这些自动配置类的类名都是以AutoConfiguration结尾来命名的，它实际上就是一个javaConfig形式的Spring容器配置类，它们都有一个@EnableConfigurationPerperties的注解，通过这个注解启动XXXProperties命名的类去加载全局配置中的属性，如server.port,而XXXProperties通过@ConfigurationProperties注解将全局配置文件中的属性与自己的属性进行绑定。
- 2、SpringBoot 配置加载顺序?
- 1、 properties文件 2、YAML文件 3、系统环境变量 4、命令行参数
- 3、spring boot初始化环境变量流程?
- 1、 调用prepareEnvironment方法去设置环境变量
- 2、 接下来有三个方法getOrCreateEnvironment，configureEnvironment，environmentPrepared
- 3、 getOrCreateEnvironment去初始化系统环境变量
- 4、 configureEnvironment去初始化命令行参数
- 5、 environmentPrepared当广播到来的时候调用onApplicationEnvironmentPreparedEvent方法去使用postProcessEnvironment方法load yml和properties变量
- 4、运行 SpringBoot 有哪几种方式？
- 1、 打包用命令或者者放到容器中运行
- 2、 用 Maven/ Gradle 插件运行
- 3、 直接执行 main 方法运行
- 5、SpringBoot 中如何解决跨域问题 ?
- 跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 SpringBoot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。
- @Configuration
- public class CorsConfig implements WebMvcConfigurer {
- @Override
- public void addCorsMappings(CorsRegistry registry) {
-     registry.addMapping("/**")
-             .allowedOrigins("*")
-             .allowCredentials(true)
-             .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
-             .maxAge(3600);
- }
- }
- 6、SpringBoot如何配置log4j？
- 在引用log4j之前，需要先排除项目创建时候带的日志，因为那个是Logback，然后再引入log4j的依赖，引入依赖之后，去src/main/resources目录下的log4j-spring.properties配置文件，就可以开始对应用的日志进行配置使用。
- 7、SpringBoot运行项目的几种方式？
- 打包用命令或者放到容器中运行
- 1、 打成jar包，使用java -jar xxx.jar运行
- 2、 打成war包，放到tomcat里面运行
- 直接用maven插件运行 maven spring-boot：run
- 直接执行main方法运行
- 8、什么是JavaConfig？
- Spring JavaConfig是Spring社区的产品，它提供了配置Spring IoC容器的纯Java方法。因此它有助于避免使用XML配置。使用JavaConfig的优点在于：
- 面向对象的配置。由于配置被定义为JavaConfig中的类，因此用户可以充分利用Java中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean方法等。
- 减少或消除XML配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在XML和Java之间来回切换。
- JavaConfig为开发人员提供了一种纯Java方法来配置与XML配置概念相似的Spring容器。
- 从技术角度来讲，只使用JavaConfig配置类来配置容器是可行的，但实际上很多人认为将JavaConfig与XML混合匹配是理想的。
- 类型安全和重构友好。JavaConfig提供了一种类型安全的方法来配置Spring容器。由于Java 5.0对泛型的支持，现在可以按类型而不是按名称检索bean，不需要任何强制转换或基于字符串的查找
- 9、运行 SpringBoot 有哪几种方式？
- 1、 打包用命令或者放到容器中运行
- 2、 用 Maven/ Gradle 插件运行
- 3、 直接执行 main 方法运行
- 10、SpringBoot 常用的 Starter 有哪些？
- 1、 spring-boot-starter-web ：提供 Spring MVC + 内嵌的 Tomcat 。
- 2、 spring-boot-starter-data-jpa ：提供 Spring JPA + Hibernate 。
- 3、 spring-boot-starter-data-Redis ：提供 Redis 。
- 4、 mybatis-spring-boot-starter ：提供 MyBatis 。
- 11、SpringBoot与SpringCloud 区别
- 12、如何集成SpringBoot和ActiveMQ？
- 13、SpringBoot 有哪几种读取配置的方式？
- 14、SpringBoot 2.X 有什么新特性？与 1.X 有什么区别？
- 15、SpringData 项目所支持的关系数据存储技术：
- 16、如何在自定义端口上运行SpringBoot应用程序？
- 17、SpringBoot默认支持的日志框架有哪些？可以进行哪些设置？
- 18、Spring Initializr 是创建 SpringBoot Projects 的唯一方法吗？
- 19、Async异步调用方法
- 20、您使用了哪些starter maven依赖项？
- 21、SpringBoot 有哪些优点？
- 22、如何给静态变量赋值？
- 23、SpringBoot、Spring MVC 和 Spring 有什么区别？
- 24、如何实现SpringBoot应用程序的安全性？
- 25、SpringBoot微服务中如何实现 session 共享 ?
- 26、SpringBoot 中的监视器是什么？
- 27、我们如何监视所有 SpringBoot 微服务？
- 28、你如何理解 SpringBoot 配置加载顺序？
- 29、如何禁用特定的自动配置类？
- 30、什么是CSRF攻击？
- 31、什么是 WebSockets？

### 3. SpringBoot面试题

- 1、在 Spring Initializer 中，如何改变一个项目的包名字？
- 好消息是你可以定制它。点击链接“转到完整版本”。你可以配置你想要修改的包名称！
- 2、SpringBoot 的配置文件有哪几种格式？它们有什么区别？
- .properties 和 .yml，它们的区别主要是书写格式不同。
- properties
- app.user.name = javastack
- yml
- app:
-   user:
-     name: javastack
- 3、什么是 Swagger？你用 SpringBoot 实现了它吗？
- Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。
- 4、spring boot 核心配置文件是什么？bootstrap、properties 和 application、properties 有何区别 ?
- 单纯做 SpringBoot 开发，可能不太容易遇到 bootstrap、properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。
- spring boot 核心的两个配置文件：
- bootstrap (、 yml 或者 、 properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud 配置就会使用这个文件。且 boostrap 里面的属性不能被覆盖；
- application (、 yml 或者 、 properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。
- 5、什么是Spring Initializer?
- 这个问题并不难，但面试官总是以此测试候选人的专业知识。
- Spring Initializer是一个网络应用程序，它可以生成一个SpringBoot项目，包含快速启动所需的一切。和往常一样，我们需要一个好的项目框架；它有助于你正确创建项目结构/框架。
- 6、SpringBoot Starter 的工作原理是什么？
- SpringBoot 在启动的时候会干这几件事情：
- 1、 SpringBoot 在启动时会去依赖的 Starter 包中寻找 resources/META-INF/spring.factories 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包。
- 2、 根据 spring.factories 配置加载 AutoConfigure 类
- 3、 根据 @Conditional 注解的条件，进行自动配置并将 Bean 注入 Spring Context
- 总结一下，其实就是 SpringBoot 在启动的时候，按照约定去读取 SpringBoot Starter 的配置信息，再根据配置信息对资源进行初始化，并注入到 Spring 容器中。这样 SpringBoot 启动完毕后，就已经准备好了一切资源，使用过程中直接注入对应 Bean 资源即可。
- 这只是简单的三连环问答，不知道有多少同学能够完整的回答出来。
- 其实 SpringBoot 中有很多的技术点可以挖掘，今天给大家整理了十个高频 SpringBoot 面试题，希望可以在后期的面试中帮助到大家。
- 7、SpringBoot 中的 starter 到底是什么 ?
- 首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性(spring、factories)注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter
- 8、SpringBoot 最大的优势是什么呢？
- SpringBoot 的最大的优势是“约定优于配置“。“约定优于配置“是一种软件设计范式，开发人员按照约定的方式来进行编程，可以减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。
- SpringBoot 中 “约定优于配置“的具体产品体现在哪里。
- SpringBoot Starter、SpringBoot Jpa 都是“约定优于配置“的一种体现。都是通过“约定优于配置“的设计思路来设计的，SpringBoot Starter 在启动的过程中会根据约定的信息对资源进行初始化；SpringBoot Jpa 通过约定的方式来自动生成 Sql ，避免大量无效代码编写。具体详细可以参考：SpringBoot 为什么这么火？
- 9、SpringBoot集成mybatis的过程
- 添加mybatis的starter maven依赖
- <dependency>
-     <groupId>org.mybatis.spring.boot</groupId>
-     <artifactId>mybatis-spring-boot-starter</artifactId>
-     <version>1.3.2</version>
- </dependency>
- 在mybatis的接口中 添加@Mapper注解
- 在application.yml配置数据源信息
- 10、如何集成SpringBoot和ActiveMQ？
- 对于集成SpringBoot和ActiveMQ，我们使用spring-boot-starter-activemq 依赖关系。 它只需要很少的配置，并且不需要样板代码。
- 11、如何在SpringBoot中禁用Actuator端点安全性？
- 12、RequestMapping 和 GetMapping 的不同之处在哪里？
- 13、SpringBoot的自动配置原理是什么
- 14、什么是 Spring Profiles？
- 15、spring-boot-starter-parent有什么用？
- 16、SpringBoot的配置文件有哪几种格式？区别是什么？
- 17、如何在 SpringBoot 中禁用 Actuator 端点安全性？
- 18、运行 SpringBoot 有哪几种方式？
- 19、SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？
- 20、SpringBoot 怎么用好自动配置，精髓:
- 21、SpringBoot需要独立的容器运行？
- 22、如何重新加载 SpringBoot 上的更改，而无需重新启动服务器？SpringBoot项目如何热部署？
- 23、什么是Spring Batch？
- 24、@RestController和@Controller的区别
- 25、SpringBoot自动配置的原理
- 26、什么是JavaConfig？
- 27、比较一下 Spring Security 和 Shiro 各自的优缺点 ?
- 28、JPA 和 Hibernate 有哪些区别？JPA 可以支持动态 SQL 吗？
- 29、SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？
- 30、path=”users”, collectionResourceRel=”users” 如何与 Spring Data Rest 一起使用？
- 31、SpringBoot有哪些优点？

### 4. SpringBoot面试题

- 1、spring boot 核心的两个配置文件：
- 1、 bootstrap (.yml 或.properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；
- 2、 application (. yml 或者 . properties)：由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。
- 2、是否可以在Spring boot中更改嵌入式Tomcat服务器的端口?
- 是的，更改端口是可行的。可以使用application.properties文件更改端口。但需要提到“server.port”（即server.port=8081）。确保项目类路径中有application.properties；后续工作将由REST Spring框架接手。如果提到server.port=0，那么它将自动分配任何可用的端口。
- 3、如何在 SpringBoot 启动的时候运行一些特定的代码？
- 可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个 run 方法
- 4、什么是 CSRF 攻击？
- CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。
- 5、bootstrap.yml和application.yml有什么区别?
- 1、 Spring Cloud 构建于 SpringBoot 之上，在 SpringBoot 中有两种上下文，一种是 bootstrap，另外一种是 application。
- 2、 application 配置文件这个容易理解，主要用于 SpringBoot 项目的自动化配置。
- 3、 bootstrap 是应用程序的父上下文，也就是说 bootstrap 加载优先于 applicaton。
- 4、 bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。
- 5、 这两个上下文共用一个环境，它是任何Spring应用程序的外部属性的来源。
- 6、 bootstrap 里面的属性会优先加载，它们默认也不能被本地相同配置覆盖。
- 7、 boostrap 由父 ApplicationContext 加载，比 applicaton 优先加载
- 8、 boostrap 里面的属性不能被覆盖
- 6、SpringBoot的缺点
- 我觉得是为难人，SpringBoot在目前我觉得没有什么缺点，非要找一个出来我觉得就是
- 由于不用自己做的配置，报错时很难定位。
- 7、SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？
- 启动类上面的注解是@SpringBootApplication，它也是 SpringBoot 的核心注解，主要组合包含了以下 3 个注解：
- @SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。
- @EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能：
- @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。
- @ComponentScan：Spring组件扫描。
- 8、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?
- 思考一下在你的虚拟机上部署应用程序需要些什么。
- 第一步：安装 Java
- 第二部：安装 Web 或者是应用程序的服务器（Tomat/Wbesphere/Weblogic 等等）
- 第三部：部署应用程序 war 包
- 如果我们想简化这些步骤，应该如何做呢？
- 让我们来思考如何使服务器成为应用程序的一部分？
- 你只需要一个安装了 Java 的虚拟机，就可以直接在上面部署应用程序了，
- 是不是很爽？
- 这个想法是嵌入式服务器的起源。
- 当我们创建一个可以部署的应用程序的时候，我们将会把服务器（例如，tomcat）嵌入到可部署的服务器中。
- 例如，对于一个 SpringBoot 应用程序来说，你可以生成一个包含 Embedded Tomcat 的应用程序 jar。你就可以像运行正常 Java 应用程序一样来运行 web 应用程序了。
- 嵌入式服务器就是我们的可执行单元包含服务器的二进制文件（例如，tomcat.jar）。
- 9、SpringBoot 的自动配置是如何实现的？
- SpringBoot 项目的启动注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：
- 1、 @Configuration
- 2、 @ComponentScan
- 3、 @EnableAutoConfiguration
- 其中 @EnableAutoConfiguration 是实现自动配置的入口，该注解又通过 @Import 注解导入了AutoConfigurationImportSelector，在该类中加载 META-INF/spring.factories 的配置信息。然后筛选出以 EnableAutoConfiguration 为 key 的数据，加载到 IOC 容器中，实现自动配置功能！
- 10、什么是FreeMarker模板？
- FreeMarker是一个基于Java的模板引擎，最初专注于使用MVC软件架构进行动态网页生成。使用Freemarker的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理html页面设计。最后使用freemarker可以将这些结合起来，给出最终的输出页面。
- 11、如何在 SpringBoot 启动的时候运行一些特定的代码？
- 12、SpringBoot 还提供了其它的哪些 Starter Project Options？
- 13、什么是 SpringBoot？
- 14、什么是执行器停机？
- 15、什么是JavaConfig？
- 16、SpringBoot 中如何实现定时任务 ?
- 17、Spring 、SpringBoot 和 Spring Cloud 的关系?
- 18、什么是 FreeMarker 模板？
- 19、RequestMapping 和 GetMapping 的不同之处在哪里？
- 20、如何使用 SpringBoot 实现全局异常处理？
- 21、我们如何监视所有SpringBoot微服务？
- 22、SpringBoot 自动配置原理是什么？
- 23、SpringBoot的核心注解是哪个？它主要由哪几个注解组成的？
- 24、SpringBoot的启动器有哪几种?
- 25、YAML 配置的优势在哪里 ?
- 26、如何重新加载 SpringBoot上的更改，而无需重新启动服务器？
- 27、SpringBoot 支持哪些日志框架？推荐和默认的日志框架是哪个？
- 28、SpringBoot 的配置文件有哪几种格式？它们有什么区别？
- 29、什么是SpringBoot ？
- 30、SpringBoot 实现热部署有哪几种方式？
- 31、SpringBoot 的核心注解是哪个？它主要由哪几个注解组成的？

### 5. SpringBoot面试题

- 1、什么是 SpringBoot Stater ？
- 启动器是一套方便的依赖没描述符，它可以放在自己的程序中。你可以一站式的获取你所需要的 Spring 和相关技术，而不需要依赖描述符的通过示例代码搜索和复制黏贴的负载。
- 例如，如果你想使用 Sping 和 JPA 访问数据库，只需要你的项目包含 spring-boot-starter-data-jpa 依赖项，你就可以完美进行。
- 2、SpringBoot多数据源事务如何管理
- 第一种方式是在service层的@TransactionManager中使用transactionManager指定DataSourceConfig中配置的事务
- 第二种是使用jta-atomikos实现分布式事务管理
- 3、SpringBoot 中的 starter 到底是什么 ?
- 首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter
- 4、SpringBoot 有哪几种读取配置的方式？
- SpringBoot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationProperties 来绑定变量
- 5、SpringBoot 支持哪些日志框架？推荐和默认的日志框架是哪个？
- SpringBoot 支持 Java Util Logging, Log4j2, Lockback 作为日志框架，如果你使用 Starters 启动器，SpringBoot 将使用 Logback 作为默认日志框架.
- 6、spring boot扫描流程?
- 1、 调用run方法中的refreshContext方法
- 2、 用AbstractApplicationContext中的refresh方法
- 3、 委托给invokeBeanFactoryPostProcessors去处理调用链
- 4、 其中一个方法postProcessBeanDefinitionRegistry会去调用processConfigBeanDefinitions解析beandefinitions
- 5、 在processConfigBeanDefinitions中有一个parse方法，其中有componentScanParser.parse的方法，这个方法会扫描当前路径下所有Component组件
- 7、什么是SpringBoot？
- 用来简化spring应用的初始搭建以及开发过程，使用特定的方式来进行配置（properties或yml文件）创建独立的spring引用程序 main方法运行，嵌入的Tomcat 无需部署war文件，简化maven配置，自动配置spring添加对应功能starter自动化配置
- 8、SpringBoot 支持哪些日志框架？推荐和默认的日志框架是哪个？
- SpringBoot 支持 Java Util Logging, Log4j2, Lockback 作为日志框架，如果你使用 Starters 启动器，SpringBoot 将使用 Logback 作为默认日志框架，但是不管是那种日志框架他都支持将配置文件输出到控制台或者文件中。
- 9、如何重新加载SpringBoot上的更改，而无需重新启动服务器？
- 这可以使用DEV工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat将重新启动。SpringBoot有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载SpringBoot上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。SpringBoot在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供H2数据库控制台以更好地测试应用程序。
- <dependency>
- <groupId>org.springframework.boot</groupId>
- <artifactId>spring-boot-devtools</artifactId>
- <optional>true</optional>
- 10、什么是 YAML？
- YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。
- 11、为什么我们需要 spring-boot-maven-plugin?
- 12、如何使用 SpringBoot 生成一个 WAR 文件？
- 13、运行 SpringBoot 有哪几种方式？
- 14、JPA 和 Hibernate 有哪些区别？
- 15、当 SpringBoot 应用程序作为 Java 应用程序运行时，后台会发生什么？
- 16、你如何理解 SpringBoot 配置加载顺序？
- 17、SpringBoot 自动配置原理是什么？
- 18、SpringBoot、Spring MVC 和 Spring 有什么区别
- 19、如何在SpringBoot中禁用Actuator端点安全性？
- 20、你能否举一个以 ReadOnly 为事务管理的例子？
- 21、spring boot监听器流程?
- 22、如何使用SpringBoot实现分页和排序？
- 23、SpringBoot常用的starter有哪些？
- 24、为什么我们不建议在实际的应用程序中使用 Spring Data Rest?
- 25、SpringBoot支持什么前端模板，
- 26、spring-boot-starter-parent 有什么用 ?
- 27、SpringBoot 自动配置原理
- 28、什么是 JavaConfig？
- 29、保护 SpringBoot 应用有哪些方法？
- 30、什么是 Spring Batch?
- 31、spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?

## 第8章 SpringCloud（150道）

### 1. SpringCloud面试题

- 1、Spring Cloud和各子项目版本对应关系
- 1、 Edgware.SR6：我理解为最低版本号
- 2、 Greenwich.SR2 :我理解为最高版本号
- 3、 Greenwich.BUILD-SNAPSHOT（快照）：是一种特殊的版本，指定了某个当前的开发进度的副本。不同于常规的版本，几乎每天都要提交更新的版本，如果每次提交都申明一个版本号那不是版本号都不够用？
- Component	Edgware.SR6	Greenwich.SR2	Greenwich.BUILD-SNAPSHOT
- spring-cloud-aws	1.2.4.RELEASE	2.1.2.RELEASE	2.1.3.BUILD-SNAPSHOT
- spring-cloud-bus	1.3.4.RELEASE	2.1.2.RELEASE	2.1.3.BUILD-SNAPSHOT
- spring-cloud-cli	1.4.1.RELEASE	2.0.0.RELEASE	2.0.1.BUILD-SNAPSHOT
- spring-cloud-commons	1.3.6.RELEASE	2.1.2.RELEASE	2.1.3.BUILD-SNAPSHOT
- spring-cloud-contract	1.2.7.RELEASE	2.1.2.RELEASE	2.1.3.BUILD-SNAPSHOT
- spring-cloud-config	1.4.7.RELEASE	2.1.3.RELEASE	2.1.4.BUILD-SNAPSHOT
- spring-cloud-netflix	1.4.7.RELEASE	2.1.2.RELEASE	2.1.3.BUILD-SNAPSHOT
- spring-cloud-security	1.2.4.RELEASE	2.1.3.RELEASE	2.1.4.BUILD-SNAPSHOT
- spring-cloud-cloudfoundry	1.1.3.RELEASE	2.1.2.RELEASE	2.1.3.BUILD-SNAPSHOT
- spring-cloud-consul	1.3.6.RELEASE	2.1.2.RELEASE	2.1.3.BUILD-SNAPSHOT
- spring-cloud-sleuth	1.3.6.RELEASE	2.1.1.RELEASE	2.1.2.BUILD-SNAPSHOT
- spring-cloud-stream	Ditmars.SR5	Fishtown.SR3	Fishtown.BUILD-SNAPSHOT
- spring-cloud-zookeeper	1.2.3.RELEASE	2.1.2.RELEASE	2.1.3.BUILD-SNAPSHOT
- spring-boot	1.5.21.RELEASE	2.1.5.RELEASE	2.1.8.BUILD-SNAPSHOT
- spring-cloud-task	1.2.4.RELEASE	2.1.2.RELEASE	2.1.3.BUILD-SNAPSHOT
- spring-cloud-vault	1.1.3.RELEASE	2.1.2.RELEASE	2.1.3.BUILD-SNAPSHOT
- spring-cloud-gateway	1.0.3.RELEASE	2.1.2.RELEASE	2.1.3.BUILD-SNAPSHOT
- spring-cloud-openfeign	2.1.2.RELEASE	2.1.3.BUILD-SNAPSHOT	
- spring-cloud-function	1.0.2.RELEASE	2.0.2.RELEASE	2.0.3.BUILD-SNAPSHOT
- 2、什么是客户证书？
- 客户端系统用于向远程服务器发出经过身份验证的请求的一种数字证书称为客户端证书。客户端证书在许多相互认证设计中起着非常重要的作用，为请求者的身份提供了强有力的保证。
- 3、Spring Cloud OpenFeign
- 基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。
- Spring Cloud的版本关系
- Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。为了管理Spring Cloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个Spring Cloud版本对应的子项目版本。
- 为了避免Spring Cloud版本号与子项目版本号混淆，Spring Cloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本，Brixton是第二个版本。
- 当Spring Cloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个"service releases"版本，简称SRX版本，比如Greenwich.SR2就是Spring Cloud发布的Greenwich版本的第2个SRX版本。目前Spring Cloud的最新版本是Hoxton。
- 4、在使用微服务架构时，您面临哪些挑战？
- 开发一些较小的微服务听起来很容易，但开发它们时经常遇到的挑战如下。
- 自动化组件：难以自动化，因为有许多较小的组件。因此，对于每个组件，我们必须遵循Build，Deploy和Monitor的各个阶段。
- 易感性：将大量组件维护在一起变得难以部署，维护，监控和识别问题。它需要在所有组件周围具有很好的感知能力。
- 配置管理：有时在各种环境中维护组件的配置变得困难。
- 调试：很难找到错误的每一项服务。维护集中式日志记录和仪表板以调试问题至关重要。
- 5、springcloud核⼼组件及其作⽤，以及springcloud⼯作原理：
- springcloud由以下⼏个核⼼组件构成：
- 1、 Eureka：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从⽽知道其他服务在哪⾥
- 2、 Ribbon：服务间发起请求的时候，基于Ribbon做负载均衡，从⼀个服务的多台机器中选择⼀台
- 3、 Feign：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求
- 4、 Hystrix：发起请求是通过Hystrix的线程池来⾛的，不同的服务⾛不同的线程池，实现了不同服务调⽤的隔离，避免了服务雪崩的问题
- 5、 Zuul：如果前端、移动端要调⽤后端系统，统⼀从Zuul⽹关进⼊，由Zuul⽹关转发请求给对应的服务
- 6、接⼝限流⽅法？
- 限制 总并发数（⽐如 数据库连接池、线程池）
- 1、 限制 瞬时并发数（如 nginx 的 limit_conn 模块，⽤来限制 瞬时并发连接数）
- 2、 限制 时间窗⼝内的平均速率（如 Guava 的 RateLimiter、nginx 的 limit_req模块，限制每秒的平均速率）
- 3、 限制 远程接⼝ 调⽤速率
- 4、 限制 MQ 的消费速率
- 5、 可以根据⽹络连接数、⽹络流量、CPU或内存负载等来限流
- 7、Spring Cloud Task
- Spring Cloud Task的目标是为SpringBoot应用程序提供创建短运行期微服务的功能。在Spring Cloud Task中，我们可以灵活地动态运行任何任务，按需分配资源并在任务完成后检索结果。Tasks是Spring Cloud Data Flow中的一个基础项目，允许用户将几乎任何SpringBoot应用程序作为一个短期任务执行。
- 8、什么是Oauth？
- 开放授权协议，这允许通过在HTTP服务上启用客户端应用程序（例如第三方提供商Facebook，GitHub等）来访问资源所有者的资源。因此，您可以在不使用其凭据的情况下与另一个站点共享存储在一个站点上的资源。
- OAuth允许像Facebook这样的第三方使用最终用户的帐户信息，同时保证其安全（不使用或暴露用户的密码）。它更像是代表用户的中介，同时为服务器提供访问所需信息的令牌。
- 9、为什么在微服务中需要Reports报告和Dashboards仪表板？
- 报告和仪表板主要用于监视和维护微服务。有多种工具可以帮助实现此目的。报告 和仪表板可用于： 找出哪些微服务公开了哪些资源。 找出组件发生变化时受影响的服务。 提供一个简单的点，只要需要文档，就可以访问它。 部署的组件的版本。
- 10、什么是微服务架构中的DRY？
- DRY代表不要重复自己。它基本上促进了重用代码的概念。这导致开发和共享库，这反过来导致紧密耦合。
- 11、服务雪崩？
- 12、什么是Idempotence以及它在哪里使用？
- 13、什么是服务熔断
- 14、SpringBoot和SpringCloud的区别？
- 15、谈一下领域驱动设计
- 16、什么是Feign？
- 17、什么是Spring Cloud Bus？我们需要它吗？
- 18、什么是凝聚力？
- 19、eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？
- 20、Spring Cloud Bus
- 21、什么是Spring Cloud Gateway?
- 22、SpringCloud有几种调用接口方式
- 23、为什么要使用 Spring Cloud 熔断器？
- 24、Spring Cloud Config
- 25、什么是微服务中的反应性扩展？
- 26、列举微服务技术栈
- 27、什么是Netflix Feign？它的优点是什么？
- 28、您对Distributed Transaction有何了解？
- 29、微服务架构的优缺点是什么？
- 30、访问RESTful微服务的方法是什么？

### 2. SpringCloud面试题

- 1、设计微服务的最佳实践是什么？
- 以下是设计微服务的最佳实践：
- 图4：设计微服务的最佳实践 – 微服务访谈问题
- 2、什么是REST / RESTful以及它的用途是什么？
- Representational State Transfer（REST）/ RESTful Web服务是一种帮助计算机系统通过Internet进行通信的架构风格。这使得微服务更容易理解和实现。
- 微服务可以使用或不使用RESTful API实现，但使用RESTful API构建松散耦合的微服务总是更容易。
- 3、什么是feigin？它的优点是什么？
- 1、 feign采用的是基于接口的注解
- 2、 feign整合了ribbon，具有负载均衡的能力
- 3、 整合了Hystrix，具有熔断的能力
- 使用:
- 1、 添加pom依赖。
- 2、 启动类添加@EnableFeignClients
- 3、 定义一个接口@FeignClient(name=“xxx”)指定调用哪个服务
- 4、负载平衡的意义什么？
- 在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。
- 5、服务网关的作用
- 1、 简化客户端调用复杂度，统一处理外部请求。
- 2、 数据裁剪以及聚合，根据不同的接口需求，对数据加工后对外。
- 3、 多渠道支持，针对不同的客户端提供不同的网关支持。
- 4、 遗留系统的微服务化改造，可以作为新老系统的中转组件。
- 5、 统一处理调用过程中的安全、权限问题。
- 6、服务降级底层是如何实现的？
- Hystrix实现服务降级的功能是通过重写HystrixCommand中的getFallback()方法，当Hystrix的run方法或construct执行发生错误时转而执行getFallback()方法。
- 7、微服务的端到端测试意味着什么？
- 端到端测试 验证工作流中的所有流程，以检查一切是否按预期工作。它还确保系统以统一的方式工作，从而满足业务需求。
- 8、spring cloud 断路器的作用是什么？
- 在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。
- 9、什么是端到端微服务测试？
- 端到端测试验证了工作流中的每个流程都正常运行。这可确保系统作为一个整体协同工作并满足所有要求。
- 通俗地说，你可以说端到端测试是一种测试，在特定时期后测试所有东西。
- 图14：测试层次 – 微服务面试问题
- 10、Spring Cloud Security
- 安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。
- 11、网关与过滤器有什么区别
- 12、在Spring MVC应用程序中使用WebMvcTest注释有什么用处？
- 13、微服务之间是如何独立通讯的
- 14、什么是Spring Cloud？
- 15、Ribbon底层实现原理
- 16、什么是断路器
- 17、分布式配置中心有那些框架？
- 18、分布式配置中心的作用？
- 19、为什么需要学习Spring Cloud
- 20、Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别
- 21、什么是消费者驱动的合同（CDC）？
- 22、什么是幂等性?它是如何使用的？
- 23、微服务架构有哪些优势？
- 24、dubbo服务注册与发现原理
- 25、什么是持续监测？
- 26、@LoadBalanced注解的作用
- 27、什么是Spring Cloud？
- 28、Mock或Stub有什么区别？
- 29、您对Mike Cohn的测试金字塔了解多少？
- 30、SpringCloud限流：

### 3. SpringCloud面试题

- 1、什么是 Hystrix 断路器？我们需要它吗？
- 由于某些原因，employee-consumer 公开服务会引发异常。在这种情况下使用 Hystrix 我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法返回一些默认值
- 中断，并且员工使用者将一起跳过 firtsPage 方法，并直接调用回退方法。 断路器的目的是给第一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可能发生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。
- 2、springcloud如何实现服务的注册?
- 1、 服务发布时，指定对应的服务名,将服务注册到 注册中心(eureka zookeeper)
- 2、 注册中心加@EnableEurekaServer,服务用@EnableDiscoveryClient，然后用ribbon或feign进行服务直接的调用发现。
- 3、微服务架构如何运作？
- 微服务架构具有以下组件：
- 图5：微服务 架构 – 微服务面试问题
- 客户端 – 来自不同设备的不同用户发送请求。
- 身份提供商 – 验证用户或客户身份并颁发安全令牌。
- API网关 – 处理客户端请求。
- 静态内容 – 容纳系统的所有内容。
- 管理 – 在节点上平衡服务并识别故障。
- 服务发现 – 查找微服务之间通信路径的指南。
- 内容交付网络 – 代理服务器及其数据中心的分布式网络。
- 远程服务 – 启用驻留在IT设备网络上的远程访问信息。
- 4、Web，RESTful API在微服务中的作用是什么？
- 微服务架构基于一个概念，其中所有服务应该能够彼此交互以构建业务功能。因此，要实现这一点，每个微服务必须具有接口。这使得Web API成为微服务的一个非常重要的推动者。RESTful API基于Web的开放网络原则，为构建微服务架构的各个组件之间的接口提供了最合理的模型。
- 5、什么是服务降级
- consumer 端：consumer 如果发现某个provider出现异常情况，⽐如，经常超时(可能是熔断引起的降级)，数据错误，这时，consumer可以采取⼀定的策略，降级provider的逻辑，基本的有直接返回固定的数据。
- provider 端：当provider 发现流量激增的时候，为了保护⾃身的稳定性，也可能考虑降级服务。
- 1、 直接给consumer返回固定数据
- 2、 需要实时写⼊数据库的，先缓存到队列⾥，异步写⼊数据库。
- 6、什么是Eureka的自我保护模式，
- 默认情况下，如果Eureka Service在一定时间内没有接收到某个微服务的心跳，Eureka Service会进入自我保护模式，在该模式下Eureka Service会保护服务注册表中的信息，不在删除注册表中的数据，当网络故障恢复后，Eureka Servic 节点会自动退出自我保护模式
- 7、什么是不同类型的双因素身份认证？
- 执行双因素身份验证需要三种类型的凭据：
- 1、 一件你知道的事情——比如密码、密码或屏幕锁定模式。
- 2、 您拥有的物理凭证，如OTP、电话或ATM卡，换句话说，您在外部或第三方设备中拥有的任何类型的凭证。
- 3、 您的物理身份–如语音认证或生物特征安全，如指纹或眼睛扫描仪。
- 8、Spring Cloud Sleuth
- Spring Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。
- 9、你所知道微服务的技术栈有哪些？列举一二
- 10、Spring Cloud Bus
- 用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。
- 11、如何在SpringBoot应用程序中实现Spring安全性？
- 12、既然Nginx可以实现网关？为什么还需要使用Zuul框架
- 13、Eureka如何 保证AP
- 14、什么是不同类型的微服务测试？
- 15、eureka的缺点：
- 16、Nginx与Ribbon的区别
- 17、多个消费者调⽤同⼀接⼝，eruka默认的分配⽅式是什么？
- 18、什么是 Spring Cloud Bus？
- 19、Eureka怎么实现高可用
- 20、什么是Spring Cloud Zuul（服务网关）
- 21、什么是客户证书？
- 22、Ribbon和Feign的区别？
- 23、微服务测试的主要障碍是什么？
- 24、spring cloud 和dubbo区别?
- 25、21、在Spring MVC应用程序中使用WebMvcTest注释有什么用处？
- 26、我们可以用微服务创建状态机吗？
- 27、微服务之间是如何独⽴通讯的
- 28、如何覆盖SpringBoot项目的默认属性？
- 29、什么是Hystrix?
- 30、服务注册和发现是什么意思？Spring Cloud 如何实现？

### 4. SpringCloud面试题

- 1、什么是有界上下文？
- 有界上下文是域驱动设计的核心模式。DDD战略设计部门的重点是处理大型模型和团队。DDD通过将大型模型划分为不同的有界上下文并明确其相互关系来处理大型模型。
- 2、ZuulFilter常用有那些方法
- 1、 Run()：过滤器的具体业务逻辑
- 2、 shouldFilter()：判断过滤器是否有效
- 3、 filterOrder()：过滤器执行顺序
- 4、 filterType()：过滤器拦截位置
- 3、Spring Cloud Gateway
- Spring cloud gateway是spring官方基于Spring 5.0、SpringBoot2.0和Project Reactor等技术开发的网关，Spring Cloud Gateway旨在为微服务架构提供简单、有效和统一的API路由管理方式，Spring Cloud Gateway作为Spring Cloud生态系统中的网关，目标是替代Netflix Zuul，其不仅提供统一的路由方式，并且还基于Filer链的方式提供了网关基本的功能，例如：安全、监控/埋点、限流等。
- 4、Spring Cloud Netflix
- Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。
- 1、 Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；
- 2、 Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；
- 3、 Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；
- 4、 Feign：基于Ribbon和Hystrix的声明式服务调用组件；
- 5、 Zuul：API网关组件，对请求提供路由及过滤功能。
- 5、负载均衡的意义是什么?
- 在计算中，负载均衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载均衡旨在优化资源使用，最大吞吐量，最小响应时间并避免任何单一资源的过载。使用多个组件进行负载均衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务进程。
- 6、Spring Cloud OpenFeign
- Feign是一个声明性的Web服务客户端。它使编写Web服务客户端变得更容易。要使用Feign，我们可以将调用的服务方法定义成抽象方法保存在本地添加一点点注解就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。
- 7、什么是耦合？
- 组件之间依赖关系强度的度量被认为是耦合。一个好的设计总是被认为具有高内聚力和低耦合性。
- 8、Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别
- ZooKeeper保证的是CP,Eureka保证的是AP，ZooKeeper在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的。Eureka各个节点是平等关系,只要有一台Eureka就可以保证服务可用,而查询到的数据并不是最新的自我保护机制会导致Eureka不再从注册列表移除因长时间没收到心跳而应该过期的服务。Eureka仍然能够接受新服务的注册和查询请求,但是不会被同步到其他节点(高可用)。当网络稳定时,当前实例新的注册信息会被同步到其他节点中(最终一致性)。Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper一样使得整个注册系统瘫痪。
- 1、 ZooKeeper有Leader和Follower角色,Eureka各个节点平等
- 2、 ZooKeeper采用过半数存活原则,Eureka采用自我保护机制解决分区问题
- 3、 Eureka本质上是一个工程,而ZooKeeper只是一个进程
- 9、网关的作用是什么
- 统一管理微服务请求，权限控制、负载均衡、路由转发、监控、安全控制黑名单和白名单等
- 10、什么是Eureka
- Eureka作为SpringCloud的服务注册功能服务器，他是服务注册中心，系统中的其他服务使用Eureka的客户端将其连接到Eureka Service中，并且保持心跳，这样工作人员可以通过Eureka Service来监控各个微服务是否运行正常。
- 11、什么是Spring Cloud？
- 12、Spring Cloud Sleuth
- 13、您对微服务架构中的语义监控有何了解？
- 14、微服务的缺点：
- 15、我们如何在测试中消除非决定论？
- 16、谈谈服务降级、熔断、服务隔离
- 17、Spring Cloud 实现服务注册和发现的原理是什么？
- 18、Spring Cloud 和dubbo区别?
- 19、SpringBoot支持哪些嵌入式容器？
- 20、您对微服务有何了解？
- 21、Spring Cloud的版本关系
- 22、Spring Cloud Gateway
- 23、Spring Cloud Task
- 24、Spring Cloud Zookeeper
- 25、Spring Cloud Zookeeper
- 26、eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？
- 27、服务注册和发现是什么意思？Spring Cloud如何实现？
- 28、Spring Cloud Consul
- 29、Actuator在SpringBoot中的作用
- 30、22。你能否给出关于休息和微服务的要点？
- 31、什么是 Hystrix？

### 5. SpringCloud面试题

- 1、什么是Hystrix？它如何实现容错？
- Hystrix是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。
- 通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作。
- 思考以下微服务
- 假设如果上图中的微服务9失败了，那么使用传统方法我们将传播一个异常。但这仍然会导致整个系统崩溃。
- 随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达1000.这是hystrix出现的地方 我们将使用Hystrix在这种情况下的Fallback方法功能。我们有两个服务employee-consumer使用由employee-consumer公开的服务。
- 简化图如下所示
- 现在假设由于某种原因，employee-producer公开的服务会抛出异常。我们在这种情况下使用Hystrix定义了一个回退方法。这种后备方法应该具有与公开服务相同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。
- 2、为什么我们需要微服务容器？
- 要管理基于微服务的应用程序，容器是最简单的选择。它帮助用户单独部署和开发。您还可以使用Docker将微服务封装到容器的镜像中。没有任何额外的依赖或工作，微服务可以使用这些元素。
- 3、springcloud和dubbo有哪些区别
- 1、 Dubbo具有调度、发现、监控、治理等功能，⽀持相当丰富的服务治理能⼒。Dubbo架构下，注册中⼼对等集群，并会缓存服务列表已被数据库失效时继续提供发现功能，本身的服务发现结构有很强的可⽤性与健壮性，⾜够⽀持⾼访问量的⽹站。
- 2、 虽然Dubbo ⽀持短连接⼤数据量的服务提供模式，但绝⼤多数情况下都是使⽤⻓连接⼩数据量的模式提供服务使⽤的。所以，对于类似于电商等同步调⽤场景多并且能⽀撑搭建Dubbo 这套⽐较复杂环境的成本的产品⽽⾔，Dubbo 确实是⼀个可以考虑的选择。但如果产品业务中由于后台业务逻辑复杂、时间⻓⽽导致异步逻辑⽐较多的话，可能Dubbo 并不合适。同时，对于⼈⼿不⾜的初创产品⽽⾔，这么重的架构维护起来也不是很⽅便。
- 3、 Spring Cloud由众多⼦项⽬组成，如Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，提供了搭建分布式系统及微服务常⽤的⼯具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、⼀次性token、全局锁、选主、分布式会话和集群状态等，满⾜了构建微服务所需的所有解决⽅案。⽐如使⽤Spring Cloud Config 可以实现统⼀配置中⼼，对配置进⾏统⼀管理；使⽤Spring Cloud Netflix 可以实现Netflix 组件的功能 - 服务发现（Eureka）、智能路由（Zuul）、客户端负载均衡（Ribbon）。
- 4、 Dubbo 提供了各种 Filter，对于上述中“⽆”的要素，可以通过扩展 Filter 来完善。
- 5、 dubbo的开发难度较⼤，原因是dubbo的jar包依赖问题很多⼤型⼯程⽆法解决。
- 4、SpringCloud Config 可以实现实时刷新吗？
- springcloud config实时刷新采用SpringCloud Bus消息总线。
- 5、Zookeeper如何 保证CP
- 当向注册中⼼查询服务列表时，我们可以容忍注册中⼼返回的是⼏分钟以前的注册信息，但不能接受服务直接down掉不可⽤。也就是说，服务注册功能对可⽤性的要求要⾼于⼀致性。但是zk会出现这样⼀种情况，当master节点因为⽹络故障与其他节点失去联系时，剩余节点会重新进⾏leader选举。问题在于，选举leader的时间太⻓，30 ~ 120s, 且选举期间整个zk集群都是不可⽤的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因⽹络问题使得zk集群失去master节点是较⼤概率会发⽣的事，虽然服务能够最终恢复，但是漫⻓的选举时间导致的注册⻓期不可⽤是不能容忍的。
- 6、微服务之间如何独立通讯的?
- 同步通信：dobbo通过 RPC 远程过程调用、springcloud通过 REST 接口json调用 等。
- 异步：消息队列，如：RabbitMq、ActiveM、Kafka 等。
- 7、什么是OAuth？
- OAuth 代表开放授权协议。这允许通过在HTTP服务上启用客户端应用程序（例如第三方提供商Facebook，GitHub等）来访问资源所有者的资源。因此，您可以在不使用其凭据的情况下与另一个站点共享存储在一个站点上的资源。
- 8、eureka服务注册与发现原理
- 1、 每30s发送⼼跳检测重新进⾏租约，如果客户端不能多次更新租约，它将在90s内从服务器注册中⼼移除。
- 2、 注册信息和更新会被复制到其他Eureka 节点，来⾃任何区域的客户端可以查找到注册中⼼信息，每30s发⽣⼀次复制来定位他们的服务，并进⾏远程调⽤。
- 3、 客户端还可以缓存⼀些服务实例信息，所以即使Eureka全挂掉，客户端也是可以定位到服务地址的。
- 9、Zuul与Nginx有什么区别？
- Zuul是java语言实现的，主要为java服务提供网关服务，尤其在微服务架构中可以更加灵活的对网关进行操作。Nginx是使用C语言实现，性能高于Zuul，但是实现自定义操作需要熟悉lua语言，对程序员要求较高，可以使用Nginx做Zuul集群。
- 10、什么是Spring Cloud？
- 在微服务中，SpringCloud是一个提供与外部系统集成的系统。它是一个敏捷的框架，可以短平快构建应用程序。与有限数量的数据处理相关联，它在微服务体系结构中起着非常重要的作用。 以下为 Spring Cloud 的核心特性：
- 1、 版本化/分布式配置。
- 2、 服务注册和发现。
- 3、 服务和服务之间的调用。
- 4、 路由。
- 5、 断路器和负载平衡。
- 6、 分布式消息传递。
- 11、使⽤中碰到的坑
- 12、什么是微服务
- 13、Spring Cloud Netflix(重点，这些组件用的最多)
- 14、什么是耦合和凝聚力？
- 15、Spring Cloud Consul
- 16、什么是Spring Cloud Config?
- 17、负载平衡的意义什么？
- 18、Spring Cloud Config
- 19、SpringCloud 和 Dubbo 有哪些区别?
- 20、架构师在微服务架构中的角色是什么？
- 21、为什么要选择微服务架构？
- 22、熔断的原理，以及如何恢复？
- 23、什么是Semantic监控？
- 24、SpringCloud由什么组成
- 25、SpringCloud的优缺点
- 26、什么是Netflix Feign？它的优点是什么？
- 27、PACT如何运作？
- 28、服务注册和发现是什么意思？Spring Cloud如何实现？
- 29、微服务限流 dubbo限流：dubbo提供了多个和请求相关的filter：ActiveLimitFilter ExecuteLimitFilter TPSLimiterFilter
- 30、Spring Cloud Stream

## 第9章 Redis（150道）

### 1. Redis面试题

- 1、为什么Redis需要把所有数据放到内存中？
- Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以Redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响Redis的性能。在内存越来越便宜的今天，Redis将会越来越受欢迎。
- 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。
- 2、查看Redis使用情况及状态信息用什么命令？
- info
- 4、修改配置不重启Redis会实时生效吗？
- 针对运行实例，有许多配置选项可以通过 CONFIG SET 命令进行修改，而无需执行任何形式的重启。 从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis。检索 ‘CONFIG GET *’ 命令获取更多信息。
- 但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前 CONFIG 命令还不支持的配置参数的时候。
- 5、是否使用过 Redis 集群，集群的原理是什么？
- 1、 Redis Sentinal 着眼于高可用， 在 master 宕机时会自动将 slave 提升为master， 继续提供服务。
- 2、 Redis Cluster 着眼于扩展性， 在单个 Redis 内存不足时， 使用 Cluster 进行分片存储。
- 6、缓存并发问题
- 这里的并发指的是多个Redis的client同时set key引起的并发问题。比较有效的解决方案就是把Redis.set操作放在队列中使其串行化，必须的一个一个执行，具体的代码就不上了，当然加锁也是可以的，至于为什么不用Redis中的事务，留给各位看官自己思考探究。
- 7、使用过Redis分布式锁么，它是什么回事？
- 先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。
- 这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？
- 这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。
- 8、Reids主从复制
- 复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。
- 9、Redis与Memcached相比有哪些优势？
- 1、 Memcached所有的值均是简单的字符串，Redis作为其替代者，支持更为丰富的数据类型
- 2、 Redis的速度比Memcached快很多Redis的速度比Memcached快很多
- 3、 Redis可以持久化其数据Redis可以持久化其数据
- 10、Redis 最适合的场景？
- 1、 会话缓存（ Session Cache）
- 最常用的一种使用 Redis 的情景是会话缓存（ session cache）。用 Redis 缓存会话比其他存储（ 如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时， 如果用户的购物车信息全部丢失， 大部分人都会不高兴的， 现在， 他们还会这样吗？ 幸运的是， 随着 Redis 这些年的改进， 很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台Magento 也提供 Redis 的插件。
- 2、 全页缓存（ FPC）
- 除基本的会话 token 之外， Redis 还提供很简便的 FPC 平台。回到一致性问题， 即使重启了 Redis 实例， 因为有磁盘的持久化， 用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。 再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。 此外， 对 WordPress 的用户来说， Pantheon 有一个非常好的插件 wp-Redis， 这个插件能帮助你以最快速度加载你曾浏览过的页面。
- 3、队列
- Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作， 这使得 Redis 能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（ 如 Python）对 list 的 push/pop 操作。 如果你快速的在 Google 中搜索“ Redis queues”， 你马上就能找到大量的开源项目， 这些项目的目的就是利用 Redis 创建非常好的后端工具， 以满足各种队列需求。例如， Celery 有一个后台就是使用 Redis 作为 broker， 你可以从这里去查看。
- 4， 排行榜/计数器
- Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（ Set） 和有序集合（ Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以， 我们要从排序集合中获取到排名最靠前的 10 个用户– 我们称之为“ user_scores”， 我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数， 你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games 就是一个很好的例子， 用 Ruby 实现的， 它的排行榜就是使用 Redis 来存储数据的， 你可以在这里看到。
- 5、 发布/订阅
- 最后（ 但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用， 还可作为基于发布/订阅的脚本触发器， 甚至用 Redis 的发布/订阅功能来建立聊天系统！
- 11、Redis对象有5种类型
- 12、Redis回收进程如何工作的？
- 13、Redis中的管道有什么用？
- 14、Reids持久化触发条件
- 15、Memcache与Redis的区别都有哪些？
- 16、Redis的同步机制了解么？
- 17、Redis 最适合的场景
- 18、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？
- 19、使用过 Redis 做异步队列么，你是怎么用的？
- 20、Redis相比Memcached有哪些优势？
- 21、都有哪些办法可以降低Redis的内存使用情况呢？
- 22、Redis主要消耗什么物理资源？
- 23、Redis事物的了解CAS(check-and-set 操作实现乐观锁 )?
- 24、为什么Redis需要把所有数据放到内存中?
- 25、MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？
- 26、SCAN系列命令注意事项
- 27、Redis 集群的主从复制模型是怎样的？
- 28、读写分离模型
- 29、Redis 开启AOF

### 2. Redis面试题

- 1、Redis集群最大节点个数是多少？
- 16384个
- 2、Reids的特点
- Redis本质上是一个Key-Value类型的内存数据库，很像Memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。
- 因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。
- Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 Memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。
- 比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的Memcached来用。
- Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
- 3、Redis最适合的场景？
- 1、 会话缓存（Session Cache）
- 最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。
- 2、 全页缓存（FPC）
- 除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。 再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。 此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-Redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。
- 3、队列
- Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。 如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。
- 4，排行榜/计数器
- Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。
- 5、 发布/订阅
- 最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！
- 4、使用Redis有哪些好处？
- 1、 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
- 2、 支持丰富数据类型，支持string，list，set，sorted set，hash
- 3、 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
- 4、 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除
- 5、为什么edis需要把所有数据放到内存中？
- Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以Redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响Redis的性能。在内存越来越便宜的今天，Redis将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。
- 6、Redis的内存用完了会发生什么？
- 如果达到设置的上限，Redis的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以将Redis当缓存来使用配置淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。
- 7、Redis 的回收策略（淘汰策略）
- volatile-lru：从已设置过期时间的数据集（ server.db[i].expires）中挑选最近最少使用的数据淘汰
- volatile-ttl： 从已设置过期时间的数据集（ server.db[i].expires） 中挑选将要过期的数据淘汰
- volatile-random： 从已设置过期时间的数据集（ server.db[i].expires） 中任意选择数据淘汰
- allkeys-lru： 从数据集（ server.db[i].dict） 中挑选最近最少使用的数据淘汰
- allkeys-random： 从数据集（ server.db[i].dict） 中任意选择数据淘汰
- no-enviction（ 驱逐） ： 禁止驱逐数据
- 注意这里的 6 种机制，volatile 和 allkeys 规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据， 后面的 lru、ttl 以及 random 是三种不同的淘汰策略， 再加上一种 no-enviction 永不回收的策略。
- 使用策略规则：
- 1、 如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率 低， 则使用 allkeys-lru
- 2、 如果数据呈现平等分布， 也就是所有的数据访问频率都相同， 则使用allkeys-random
- 8、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？
- 使用keys指令可以扫出指定模式的key列表。
- 对方接着追问：如果这个Redis正在给线上的业务提供服务，那使用keys指令会有什么问题？
- 这个时候你要回答Redis关键的一个特性：Redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。
- 9、Memcached 与Redis 的区别？
- 1、 Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset， hash 等数据结构的存储。而 memcache 只支持简单数据类型，需要客户端自己处理复杂对象
- 2、 Redis 支持数据的持久化， 可以将内存中的数据保持在磁盘中， 重启的时候可以再次加载进行使用（ PS： 持久化在 rdb、aof）。
- 10、Redis 常见性能问题和解决方案：
- 1、 Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave函数， 会阻塞主线程的工作， 当快照比较大时对性能影响是非常大的， 会间断性暂停服务
- 2、 如果数据比较重要， 某个 Slave 开启 AOF 备份数据， 策略设置为每秒同步一
- 3、 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网
- 4、 尽量避免在压力很大的主库上增加从
- 5、 主从复制不要用图状结构， 用单向链表结构更为稳定， 即：Master <- Slave1
- <- Slave2 <- Slave3… 这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了， 可以立刻启用 Slave1 做 Master， 其他不变。
- 11、Redis集群之间是如何复制的？
- 12、Jedis 与 Redisson 对比有什么优缺点？
- 13、你知道有哪些Redis分区实现方案？
- 14、Redis分区有什么缺点？
- 15、Redis是单进程单线程的？
- 16、Redis支持的Java客户端都有哪些？官方推荐用哪个？
- 17、Redis 持久化方案：
- 18、Redis哨兵
- 19、如何实现集群中的 session 共享存储？
- 20、Redis 中设置过期时间主要通过以下四种方式
- 21、一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？
- 22、缓存和数据库间数据一致性问题
- 23、Redis分布式
- 24、缓存雪崩问题
- 25、Redis常见的几种缓存策略
- 26、Redis前端启动命令
- 27、Redis 如何做内存优化？
- 28、如何选择合适的持久化方式？
- 29、Redis 相比Memcached 有哪些优势？

### 3. Redis面试题

- 1、一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？
- 理论上Redis可以处理多达232的keys，并且在实际中进行了测试，每个实例至少存放了2亿5千万的keys。我们正在测试一些较大的值。任何list、set、和sorted set都可以放232个元素。换句话说，Redis的存储极限是系统中的可用内存值。
- 2、为什么要做Redis分区？
- 分区可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。分区使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。
- 3、定时删除
- 优点：对内存友好，定时删除策略可以保证过期键会尽可能快地被删除，并释放国期间所占用的内存
- 缺点：对cpu时间不友好，在过期键比较多时，删除任务会占用很大一部分cpu时间，在内存不紧张但cpu时间紧张的情况下，将cpu时间用在删除和当前任务无关的过期键上，影响服务器的响应时间和吞吐量
- 4、怎么理解Redis事务？
- 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
- 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。
- 5、什么是Redis？
- Redis本质上是一个Key-Value类型的内存数据库，很像Memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。
- Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 Memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的Memcached来用。
- Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。
- 6、Redis分布式锁实现
- 先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！
- 7、Redis做异步队列
- 一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。缺点：在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。
- 8、Reids常用5种数据类型
- string，list，set，sorted set，hash
- 9、Redis 事务相关的命令有哪几个？
- MULTI、EXEC、DISCARD、WATCH
- 10、WATCH命令和基于CAS的乐观锁：
- 在Redis的事务中，WATCH命令可用于提供CAS(check-and-set)功能。假设我们通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回Null multi-bulk应答以通知调用者事务
- 执行失败。例如，我们再次假设Redis中并未提供incr命令来完成键值的原子性递增，如果要实现该功能，我们只能自行编写相应的代码。其伪码如下：
- val = GET mykey
- val = val + 1
- SET mykey $val
- 以上代码只有在单连接的情况下才可以保证执行结果是正确的，因为如果在同一时刻有多个客户端在同时执行该段代码，那么就会出现多线程程序中经常出现的一种错误场景--竞态争用(race condition)。
- 比如，客户端A和B都在同一时刻读取了mykey的原有值，假设该值为10，此后两个客户端又均将该值加一后set回Redis服务器，这样就会导致mykey的结果为11，而不是我们认为的12。为了解决类似的问题，我们需要借助WATCH命令的帮助，见如下代码：
- WATCH mykey
- val = GET mykey
- val = val + 1
- MULTI
- SET mykey $val
- EXEC
- 和此前代码不同的是，新代码在获取mykey的值之前先通过WATCH命令监控了该键，此后又将set命令包围在事务中，这样就可以有效的保证每个连接在执行EXEC之前，如果当前连接获取的mykey的值被其它连接的客户端修改，那么当前连接的EXEC命令将执行失败。这样调用者在判断返回值后就可以获悉val是否被重新设置成功。
- 11、怎么理解 Redis 事务？
- 12、MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证Redis 中的数据都是热点数据？
- 13、Redis的缓存失效策略和主键失效机制
- 14、布隆过滤器
- 15、判断key是否存在
- 16、Redis与其他key-value存储有什么不同？
- 17、Redis回收进程如何工作的？
- 18、RDB和AOF的优缺点
- 19、Redis是单进程单线程的
- 20、为什么需要持久化？
- 21、Redis 的数据类型？
- 22、Redis提供了哪几种持久化方式？
- 23、Redis内存模型
- 24、Redis缓存被击穿处理机制
- 25、Redis的全称是什么？
- 26、什么是Redis?
- 27、持久化策略选择
- 28、Redis中的管道有什么用？
- 29、Redis的内存占用情况怎么样？
- 30、手写一个 LRU 算法

### 4. Redis面试题

- 1、Redis集群方案应该怎么做？都有哪些方案？
- 1、 codis。
- 目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。
- 2、 Redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。
- 3、 在业务代码层实现，起几个毫无关联的Redis实例，在代码层，对key 进行hash计算，然后去对应的Redis实例操作数据。 这种方式对hash层代码要求比较高，考虑部分包
- 2、Reids支持的语言：
- java、C、C#、C++、php、Node.js、Go等。
- 3、怎么测试Redis的连通性？
- ping
- 4、Redis 集群会有写操作丢失吗？为什么？
- Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。
- 5、Redis回收使用的是什么算法？
- LRU算法
- 6、Redis的并发竞争问题如何解决?
- 单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，利用setnx实现锁。
- 7、AOF常用配置总结
- 下面是AOF常用的配置项，以及默认值；前面介绍过的这里不再详细介绍。
- 1、 appendonly no：是否开启AOF
- 2、 appendfilename "appendonly.aof"：AOF文件名
- 3、 dir ./：RDB文件和AOF文件所在目录
- 4、 appendfsync everysec：fsync持久化策略
- 5、 no-appendfsync-on-rewrite no：AOF重写期间是否禁止fsync；如果开启该选项，可以减轻文件重写时CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期间的数据；需要在负载和安全性之间进行平衡
- 6、 auto-aof-rewrite-percentage 100：文件重写触发条件之一
- 7、 auto-aof-rewrite-min-size 64mb：文件重写触发提交之一
- 8、 aof-load-truncated yes：如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件
- 8、Redis 管道 Pipeline
- 在某些场景下我们在一次操作中可能需要执行多个命令，而如果我们只是一个命令一个命令去执行则会浪费很多网络消耗时间，如果将命令一次性传输到 Redis中去再执行，则会减少很多开销时间。但是需要注意的是 pipeline中的命令并不是原子性执行的，也就是说管道中的命令到达 Redis服务器的时候可能会被其他的命令穿插
- 9、微信公众号：Java资讯库，回复“架构”
- 10、Redis集群方案什么情况下会导致整个集群不可用？
- 有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。
- 11、Reids三种不同删除策略
- 12、Redis集群的主从复制模型是怎样的？
- 13、Redis如何做大量数据插入？
- 14、都有哪些办法可以降低 Redis 的内存使用情况呢?
- 15、Redis常见性能问题和解决方案：
- 16、为什么Redis需要把所有数据放到内存中？
- 17、分布式Redis是前期做还是后期规模上来了再做好？为什么？
- 18、Redis 的持久化机制是什么？各自的优缺点？
- 19、如果有大量的key需要设置同一时间过期，一般需要注意什么？
- 20、缓冲内存
- 21、说说Redis哈希槽的概念？
- 22、Redis有哪几种数据淘汰策略？
- 23、Redis支持哪几种数据类型？
- 24、为什么Redis是单线程的？
- 25、Redis相比Memcached有哪些优势：
- 26、Redis 如何设置密码及验证密码？
- 27、，免费领取架构资料。
- 28、Redis 提供 6种数据淘汰策略：
- 29、Redis Module 实现布隆过滤器
- 30、Redis集群会有写操作丢失吗？为什么？

### 5. Redis面试题

- 1、Redis如何做内存优化？
- 尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面.
- 2、Pipeline有什么好处，为什么要用pipeline？
- 可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用Redis-benchmark进行压测的时候可以发现影响Redis的QPS峰值的一个重要因素是pipeline批次指令的数目。
- 3、Redis常用管理命令
- # dbsize 返回当前数据库 key 的数量。
- # info 返回当前 Redis 服务器状态和一些统计信息。
- # monitor 实时监听并返回Redis服务器接收到的所有请求信息。
- # shutdown 把数据同步保存到磁盘上，并关闭Redis服务。
- # config get parameter 获取一个 Redis 配置参数信息。（个别参数可能无法获取）
- # config set parameter value 设置一个 Redis 配置参数信息。（个别参数可能无法获取）
- # config resetstat 重置 info 命令的统计信息。（重置包括：keyspace 命中数、
- # keyspace 错误数、 处理命令数，接收连接数、过期 key 数）
- # debug object key 获取一个 key 的调试信息。
- # debug segfault 制造一次服务器当机。
- # flushdb 删除当前数据库中所有 key,此方法不会失败。小心慎用
- # flushall 删除全部数据库中所有 key，此方法不会失败。小心慎用
- 4、Redis持久化数据和缓存怎么做扩容？
- 如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。
- 如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。
- 5、Twemproxy是什么？
- Twemproxy是Twitter维护的（缓存）代理系统，代理Memcached的ASCII协议和Redis协议。它是单线程程序，使用c语言编写，运行起来非常快。它是采用Apache 2.0 license的开源软件。 Twemproxy支持自动分区，如果其代理的其中一个Redis节点不可用时，会自动将该节点排除（这将改变原来的keys-instances的映射关系，所以你应该仅在把Redis当缓存时使用Twemproxy)。 Twemproxy本身不存在单点问题，因为你可以启动多个Twemproxy实例，然后让你的客户端去连接任意一个Twemproxy实例。 Twemproxy是Redis客户端和服务器端的一个中间层，由它来处理分区功能应该不算复杂，并且应该算比较可靠的。
- 6、Redis没有直接使用C字符串
- (即以空字符’\0’结尾的字符数组)作为默认的字符串表示，而是使用了SDS。SDS是简单动态字符串(Simple Dynamic String)的缩写。
- 7、使用过 Redis 分布式锁么，它是什么回事？
- 先拿 setnx 来争抢锁， 抢到之后， 再用 expire 给锁加一个过期时间防止锁忘记了释放。
- 这时候对方会告诉你说你回答得不错， 然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了， 那会怎么样？
- 这时候你要给予惊讶的反馈： 唉， 是喔， 这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋， 故作思考片刻， 好像接下来的结果是你主动思考出来的， 然后回我记得 set 指令有非常复杂的参数， 这个应该是可以同时把 setnx 和expire 合成一条指令来用的！ 对方这时会显露笑容， 心里开始默念： 摁， 这小子还不错。
- 8、Redis如何设置密码及验证密码？
- 设置密码：config set requirepass 123456
- 授权密码：auth 123456
- 9、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素?
- 理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。我们正在测试一些较大的值。任何 list、set、和 sorted set 都可以放 232 个元素。换句话说， Redis 的存储极限是系统中的可用内存值。
- 10、Redis有哪些适合的场景？
- 会话缓存（Session Cache）
- 最常用的一种使用Redis的情景是会话缓存（sessioncache），用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？
- 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。
- 全页缓存（FPC）
- 除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。
- 再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。
- 此外，对WordPress的用户来说，Pantheon有一个非常好的插件wp-Redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。
- 队列
- Reids在内存存储引擎领域的一大优点是提供list和set操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。
- 如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。
- 排行榜/计数器
- Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（SortedSet）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。
- 所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：
- 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：
- ZRANGE user_scores 0 10 WITHSCORES
- Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。
- 发布/订阅
- 最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！
- 11、说说 Redis 哈希槽的概念？
- 12、使用Redis有哪些好处？
- 13、Redis 支持的Java 客户端都有哪些？官方推荐用哪个？
- 14、怎么测试 Redis 的连通性？
- 15、Redis过期键的删除策略？
- 16、Redis是单线程的，如何提高多核CPU的利用率？
- 17、Redis的持久化机制是什么？各自的优缺点？
- 18、Redis key的过期时间和永久有效分别怎么设置？
- 19、Redis通讯协议
- 20、是否使用过Redis集群，集群的原理是什么？
- 21、Redis相比Memcached有哪些优势？
- 22、惰性删除
- 23、怎么测试Redis的连通性？
- 24、Redis有哪几种数据淘汰策略？
- 25、Redis的数据类型？
- 26、Redis集群方案应该怎么做？都有哪些方案？
- 27、怎么理解Redis事务？
- 28、Redis和Redisson有什么关系？
- 29、Redis是单线程

## 第10章 Zookeeper（120道）

### 1. Zookeeper面试题

- 1、Stat记录了哪些版本相关数据？
- version:当前ZNode版本
- cversion:当前ZNode子节点版本
- aversion:当前ZNode的ACL版本
- 2、BASE理论？
- 1、 Basically Available(基本可用)、Soft state(软状态) 和 Eventuanlly consistent （最终一致性）3个短语的简写。
- 2、 基本可用：系统出现不可预知的故障时，允许损失部分可用性。
- 3、 弱（软）状态：数据的中间状态，并认为改状态存在不会一项系统整体可用性，允许不同节点数据副本数据同步过程中的延时。
- 4、 最终一致性：系统中所有数据副本，在一段时间的同步后，最终数据能够到一致性的状态。
- 3、Zookeeper Watcher 机制 – 数据变更通知
- Zookeeper 允许客户端向服务端的某个 Znode 注册一个 Watcher 监听，当服务端的一些指定事件触发了这个 Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类型做出业务上的改变。
- 工作机制：
- 1、 客户端注册 watcher
- 2、 服务端处理 watcher
- 3、 客户端回调 watcher
- 4、如何识别请求的先后顺序？
- ZooKeeper会给每个更新请求，分配一个全局唯一的递增编号（zxid)，编号的大小体现事务操作的先后顺序。
- 5、zk的命名服务（文件系统）
- 命名服务是指通过指定的名字来获取资源或者服务的地址，利用zk创建一个全局的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。
- 6、如何查看子节点？
- ls path [watch]
- path : 节点路径
- [zk: localhost:2181(CONNECTED) 5] ls /app
- [book]
- 7、chubby是什么，和zookeeper比你怎么看？
- chubby是google的，完全实现paxos算法，不开源。zookeeper是chubby的开源实现，使用zab协议，paxos算法的变种。
- 8、ZooKeeper 面试题？
- ZooKeeper是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。
- 分布式应用程序可以基于Zookeeper实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。
- Zookeeper保证了如下分布式一致性特性：
- 1、 顺序一致性
- 2、 原子性
- 3、 单一视图
- 4、 可靠性
- 5、 实时性（最终一致性）
- 客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的zookeeper机器来处理。对于写请求，这些请求会同时发给其他zookeeper机器并且达成一致后，请求才会返回成功。因此，随着zookeeper的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。
- 有序性是zookeeper中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个zookeeper最新的zxid。
- 9、Zookeeper 有哪几种几种部署模式？
- Zookeeper 有三种部署模式：
- 1、 单机部署：一台集群上运行；
- 2、 集群部署：多台集群运行；
- 3、 伪集群部署：一台集群启动多个 Zookeeper 实例运行。
- 10、服务端处理Watcher实现
- 1、 服务端接收Watcher并存储
- 接收到客户端请求，处理请求判断是否需要注册Watcher，需要的话将数据节点的节点路径和ServerCnxn（ServerCnxn代表一个客户端和服务端的连接，实现了Watcher的process接口，此时可以看成一个Watcher对象）存储在WatcherManager的WatchTable和watch2Paths中去。
- 2、 Watcher触发
- 以服务端接收到 setData() 事务请求触发NodeDataChanged事件为例：
- 2.1 封装WatchedEvent
- 将通知状态（SyncConnected）、事件类型（NodeDataChanged）以及节点路径封装成一个WatchedEvent对象
- 2.2 查询Watcher
- 从WatchTable中根据节点路径查找Watcher
- 2.3 没找到；说明没有客户端在该数据节点上注册过Watcher
- 2.4 找到；提取并从WatchTable和Watch2Paths中删除对应Watcher（从这里可以看出Watcher在服务端是一次性的，触发一次就失效了）
- 3、 调用process方法来触发Watcher
- 这里process主要就是通过ServerCnxn对应的TCP连接发送Watcher事件通知。
- 11、客户端注册 Watcher 实现
- 12、客户端回调 Watcher
- 13、为什么叫ZooKeeper?
- 14、在sessionTimeout之内的会话，因服务器压力大、网络故障或客户端主动断开情况下，之前的会话还有效吗？
- 15、Zookeeper 的典型应用场景
- 16、Zookeeper默认端口？
- 17、Zookeeper 都有哪些功能？
- 18、Zookeeper集群管理（文件系统、通知机制）
- 19、删除指定节点？注意？
- 20、CAP理论？
- 21、恢复模式
- 22、Quorum?
- 23、ZooKeeper是什么？
- 24、Zookeeper的java客户端都有哪些？
- 25、ZNode的类型？
- 26、集群最少要几台机器，集群规则是怎样的?
- 27、Zookeeper文件系统
- 28、ZooKeeper 提供了什么？
- 29、A是根节点，如何表达A子节点下的B节点？
- 30、Zookeeper队列管理（文件系统、通知机制）

### 2. Zookeeper面试题

- 1、ZAB和Paxos算法的联系与区别？
- 相同点：
- 1、 两者都存在一个类似于Leader进程的角色，由其负责协调多个Follower进程的运行
- 2、 Leader进程都会等待超过半数的Follower做出正确的反馈后，才会将一个提案进行提交
- 3、 ZAB协议中，每个Proposal中都包含一个 epoch 值来代表当前的Leader周期，Paxos中名字为Ballot
- 不同点：
- ZAB用来构建高可用的分布式数据主备系统（Zookeeper），Paxos是用来构建分布式一致性状态机系统。
- 2、什么是ZooKeeper?
- ZooKeeper是一个开源分布式协同服务系统，Zookeeper的设计目标是将那些复杂容易出错的分布式一致性服务封装起来，构成一个高效可用的原语集，并提供一系列简单接口给用户使用。
- 3、ZooKeeper的数据模型？
- 共享的、树形结构，由一系列的 ZNode数据节点组成，类似文件系统(目录不能存数据）。ZNode存有数据信息，如版本号等等。ZNode之间的层级关系，像文件系统中的目录结构一样。并且它是将数据存在内存中，这样可以提高吞吐、减少延迟。
- 4、集群最少要几台机器，集群规则是怎样的？集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗？
- 集群规则为 2N+1 台，N>0，即 3 台。可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。
- 5、数据发布/订阅？
- 发布者将数据发布到ZooKeeper上一个或多个节点上，订阅者从中订阅数据，从而动态获取数据的目的，实现配置信息的集中式管理和数据动态更新。
- 6、ACL权限控制机制
- UGO（User/Group/Others）
- 目前在Linux/Unix文件系统中使用，也是使用最广泛的权限控制方式。是一种粗粒度的文件系统权限控制模式。
- ACL（Access Control List）访问控制列表
- 包括三个方面：
- 权限模式（Scheme）
- 1、 IP：从IP地址粒度进行权限控制
- 2、 Digest：最常用，用类似于 username:password 的权限标识来进行权限配置，便于区分不同应用来进行权限控制
- 3、 World：最开放的权限控制方式，是一种特殊的digest模式，只有一个权限标识“world:anyone”
- 4、 Super：超级用户
- 授权对象
- 授权对象指的是权限赋予的用户或一个指定实体，例如IP地址或是机器灯。
- 权限 Permission
- 1、 CREATE：数据节点创建权限，允许授权对象在该Znode下创建子节点
- 2、 DELETE：子节点删除权限，允许授权对象删除该数据节点的子节点
- 3、 READ：数据节点的读取权限，允许授权对象访问该数据节点并读取其数据内容或子节点列表等
- 4、 WRITE：数据节点更新权限，允许授权对象对该数据节点进行更新操作
- 5、 ADMIN：数据节点管理权限，允许授权对象对该数据节点进行ACL相关设置操作
- 7、说几个zookeeper常用的命令。
- 常用命令：ls get set create delete等。
- 8、ZAB 和 Paxos 算法的联系与区别？
- 相同点：
- 1、 两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程的运行
- 2、 Leader 进程都会等待超过半数的 Follower 做出正确的反馈后，才会将一个提案进行提交
- 3、 ZAB 协议中，每个 Proposal 中都包含一个 epoch 值来代表当前的 Leader周期，Paxos 中名字为 Ballot
- 不同点：
- ZAB 用来构建高可用的分布式数据主备系统（Zookeeper），Paxos 是用来构建分布式一致性状态机系统。
- 9、ZooKeeper 是什么？
- 1、 ZooKeeper 是一个开源的分布式协调服务。它是一个为分布式应用提供一致性服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。
- 2、 ZooKeeper 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。
- Zookeeper 保证了如下分布式一致性特性：
- 1、 顺序一致性
- 2、 原子性
- 3、 单一视图
- 4、 可靠性
- 5、 实时性（最终一致性）
- 客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的 zookeeper 机器来处理。对于写请求，这些请求会同时发给其他 zookeeper 机器并且达成一致后，请求才会返回成功。因此，随着 zookeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。
- 有序性是 zookeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为 zxid（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个zookeeper 最新的 zxid。
- 10、集群支持动态添加机器吗？
- 其实就是水平扩容了，Zookeeper在这方面不太好。两种方式：
- 全部重启：关闭所有Zookeeper服务，修改配置之后启动。不影响之前客户端的会话。
- 逐个重启：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供服务。这是比较常用的方式。
- 3.5版本开始支持动态扩容。
- 11、集群支持动态添加机器吗？
- 12、服务器角色
- 13、广播模式
- 14、分布式集群中为什么会有 Master主节点？
- 15、哪些情况会导致ZAB进入恢复模式并选取新的Leader?
- 16、服务器角色
- 17、什么是会话Session?
- 18、负载均衡
- 19、ZooKeeper可以保证哪些分布式一致性特性？
- 20、zookeeper是如何选取主leader的？
- 21、zk节点宕机如何处理？
- 22、Zookeeper 专门设计的一种支持崩溃恢复的原子广 播协议是?
- 23、数据同步
- 24、Zookeeper 文件系统
- 25、Watcher事件监听器？
- 26、说几个 zookeeper 常用的命令。
- 27、ZooKeeper提供了什么？
- 28、服务器的3中角色？
- 29、Zookeeper 的 java 客户端都有哪些？
- 30、ZAB协议？

### 3. Zookeeper面试题

- 1、几种部署方式？
- 单机、伪集群、集群
- 2、发布订阅的两种设计模式？
- 推(Push) :服务端主动推数据给所有定于的客户端。
- 拉(Pull):客户端主动发请求来获取最新数据。
- 3、服务端处理 Watcher 实现
- 1、 服务端接收 Watcher 并存储 接收到客户端请求，处理请求判断是否需要注册 Watcher，需要的话将数据节点的节点路径和 ServerCnxn（ServerCnxn 代表一个客户端和服务端的连接，实现了 Watcher 的 process 接口，此时可以看成一个 Watcher 对象）存储在WatcherManager 的 WatchTable 和 watch2Paths 中去。
- 2、 Watcher 触发 以服务端接收到 setData() 事务请求触发 NodeDataChanged 事件为例：
- 2.1 封装 WatchedEvent 将通知状态（SyncConnected）、事件类型（NodeDataChanged）以及节点路径封装成一个 WatchedEvent 对象
- 2.2 查询 Watcher 从 WatchTable 中根据节点路径查找 Watcher
- 2.3 没找到；说明没有客户端在该数据节点上注册过 Watcher
- 2.4 找到；提取并从 WatchTable 和 Watch2Paths 中删除对应 Watcher（从这里可以看出 Watcher 在服务端是一次性的，触发一次就失效了）
- 3、  调用 process 方法来触发 Watcher 这里 process 主要就是通过 ServerCnxn 对应的 TCP 连接发送 Watcher 事件通知。
- 4、zk节点宕机如何处理？
- Zookeeper本身也是集群，推荐配置不少于3个服务器。Zookeeper自身也要保证当一个节点宕机时，其他节点会继续提供服务。
- 如果是一个Follower宕机，还有2台服务器提供访问，因为Zookeeper上的数据是有多个副本的，数据并不会丢失；
- 如果是一个Leader宕机，Zookeeper会选举出新的Leader。
- ZK集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在ZK节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。
- 所以
- 3个节点的cluster可以挂掉1个节点(leader可以得到2票>1.5)
- 2个节点的cluster就不能挂掉任何1个节点了(leader可以得到1票<=1)
- 5、Zookeeper 对节点的 watch 监听通知是永久的吗？为什么不是永久的?
- 1、 不是。官方声明：一个 Watch 事件是一个一次性的触发器，当被设置了 Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，以便通知它们。
- 2、 为什么不是永久的，举个例子，如果服务端变动频繁，而监听的客户端很多情况下，每次变动都要通知到所有的客户端，给网络和服务器造成很大压力。
- 3、 一般是客户端执行 getData(“/节点 A”,true)，如果节点 A 发生了变更或删除，客户端会得到它的 watch 事件，但是在之后节点 A 又发生了变更，而客户端又没有设置 watch 事件，就不再给客户端发送。
- 4、 在实际应用中，很多情况下，我们的客户端不需要知道服务端的每一次变动，我只要最新的数据即可。
- 6、Zookeeper 怎么保证主从节点的状态同步？
- Zookeeper 的核心是原子广播机制，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。
- 7、数据发布/订阅
- 介绍
- 数据发布/订阅系统，即所谓的配置中心，顾名思义就是发布者发布数据供订阅者进行数据订阅。
- 目的
- 1、 动态获取数据（配置信息）
- 2、 实现数据（配置信息）的集中式管理和数据的动态更新
- 设计模式
- 1、 Push 模式
- 2、 Pull 模式
- 数据（配置信息）特性
- 1、 数据量通常比较小
- 2、 数据内容在运行时会发生动态更新
- 3、 集群中各机器共享，配置一致
- 如：机器列表信息、运行时开关配置、数据库配置信息等
- 基于 Zookeeper 的实现方式
- 1、 数据存储：将数据（配置信息）存储到 Zookeeper 上的一个数据节点
- 2、 数据获取：应用在启动初始化节点从 Zookeeper 数据节点读取数据，并在该节点上注册一个数据变更 Watcher
- 3、 数据变更：当变更数据时，更新 Zookeeper 对应节点数据，Zookeeper会将数据变更通知发到各客户端，客户端接到通知后重新读取变更后的数据即可。
- 8、同进程组的两个进程消息网络通信有哪两个特性？
- 完整性： 如果进程a收到进程b的消息msg,那么b一定发送了消息msg。
- 前置性：如果msg1是msg2的前置消息，那么当前进程务必先接收到msg1,在接受msg2。
- 9、zookeeper 是如何保证事务的顺序一致性的？
- zookeeper 采用了全局递增的事务 Id 来标识，所有的 proposal（提议）都在被提出的时候加上了 zxid，zxid 实际上是一个 64 位的数字，高 32 位是 epoch（ 时期; 纪元; 世; 新时代）用来标识 leader 周期，如果有新的 leader 产生出来，epoch会自增，低 32 位用来递增计数。当新产生 proposal 的时候，会依据数据库的两阶段过程，首先会向其他的 server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。
- 10、Chroot特性
- 3.2.0版本后，添加了 Chroot特性，该特性允许每个客户端为自己设置一个命名空间。如果一个客户端设置了Chroot，那么该客户端对服务器的任何操作，都将会被限制在其自己的命名空间下。
- 通过设置Chroot，能够将一个客户端应用于Zookeeper服务端的一颗子树相对应，在那些多个应用公用一个Zookeeper进群的场景下，对实现不同应用间的相互隔离非常有帮助。
- 11、四种类型的数据节点 Znode
- 12、客户端回调Watcher
- 13、zookeeper 负载均衡和 nginx 负载均衡区别
- 14、ACL 权限控制机制
- 15、Chroot 特性
- 16、获取分布式锁的流程
- 17、zookeeper负载均衡和nginx负载均衡区别
- 18、Zookeeper通知机制
- 19、数据同步
- 20、zookeeper watch机制
- 21、Zookeeper同步流程
- 22、zk 节点宕机如何处理？
- 23、Zookeeper分布式锁（文件系统、通知机制）
- 24、机器中为什么会有leader？
- 25、zk的配置管理（文件系统、通知机制）
- 26、更新指定节点信息？
- 27、如何创建一个ZNode?
- 28、Zookeeper数据复制
- 29、Watcher 特性总结
- 30、ZooKeeper可以实现哪些功能？
- 31、Zookeeper对节点的watch监听通知是永久的吗？为什么不是永久的?

### 4. Zookeeper面试题

- 1、Zookeeper 下 Server工作状态
- 每个Server在工作过程中有三种状态：
- LOOKING：当前Server不知道leader是谁，正在搜寻
- LEADING：当前Server即为选举出来的leader
- FOLLOWING：leader已经选举出来，当前Server与之同步
- 2、ZooKeeper定义了几种权限？
- 1、 CREATE
- 2、 READ
- 3、 WRITE
- 4、 DELETE
- 5、 ADMIN
- 3、ZooKeeper用推/拉模式？
- 推拉结合
- 4、客户端如何获取配置信息？
- 启动时主动到服务端拉取信息，同时，在制定节点注册Watcher监听。一旦有配置变化，服务端就会实时通知订阅它的所有客户端。
- 5、会话管理
- 分桶策略：将类似的会话放在同一区块中进行管理，以便于 Zookeeper 对会话进行不同区块的隔离处理以及同一区块的统一处理。
- 分配原则：每个会话的“下次超时时间点”（ExpirationTime）
- 计算公式：
- ExpirationTime\_ = currentTime + sessionTimeout
- ExpirationTime = (ExpirationTime\_ / ExpirationInrerval + 1) \*
- ExpirationInterval , ExpirationInterval 是指 Zookeeper 会话超时检查时间间隔，默认 tickTime
- 6、四种类型的数据节点 Znode
- 1、 PERSISTENT-持久节点 除非手动删除，否则节点一直存在于 Zookeeper 上
- 2、 EPHEMERAL-临时节点 临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。
- 3、 PERSISTENT_SEQUENTIAL-持久顺序节点 基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。
- 4、 EPHEMERAL_SEQUENTIAL-临时顺序节点 基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。
- 7、zookeeper是如何保证事务的顺序一致性的？
- zookeeper采用了递增的事务Id来标识，所有的proposal（提议）都在被提出的时候加上了zxid，zxid实际上是一个64位的数字，高32位是epoch（时期; 纪元; 世; 新时代）用来标识leader是否发生改变，如果有新的leader产生出来，epoch会自增，低32位用来递增计数。当新产生proposal的时候，会依据数据库的两阶段过程，首先会向其他的server发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。
- 8、发现?
- Follower把自己最后的接受事务的Proposal值(CEPOCH(F.p)发送给Leader。
- 当收到过半Follower的消息后，Leader生成NEWEPOCH(e')给这些过半的Follower。
- tips: e' = Max((CEPOCH(F.p)) + 1
- Follower收到消息后，如果自己值小于e',则同步e'的值，同时向Leader发Ack消息。
- 9、客户端注册Watcher实现
- 1、 调用getData()/getChildren()/exist()三个API，传入Watcher对象
- 2、 标记请求request，封装Watcher到WatchRegistration
- 3、 封装成Packet对象，发服务端发送request
- 4、 收到服务端响应后，将Watcher注册到ZKWatcherManager中进行管理
- 5、 请求返回，完成注册。
- 10、Zookeeper文件系统
- Zookeeper提供一个多层级的节点命名空间（节点称为znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得Zookeeper不能用于存放大量的数据，每个节点的存放数据上限为1M。
- 11、Zookeeper有哪几种几种部署模式？
- 12、Zookeeper做了什么？
- 13、chubby 是什么，和 zookeeper 比你怎么看？
- 14、权限控制?
- 15、Zookeeper工作原理
- 16、说一下 Zookeeper 的通知机制？
- 17、ZAB的两种基本模式？
- 18、分布式集群中为什么会有Master？
- 19、四种类型的znode
- 20、Zookeeper 下 Server 工作状态
- 21、Zookeeper的典型应用场景
- 22、Zookeeper Watcher 机制 -- 数据变更通知
- 23、会话管理
- 24、集群角色？
- 25、Zookeeper 和 Dubbo 的关系？
- 26、zookeeper是如何保证事务的顺序一致性的？
- 27、ZAB三个阶段？
- 28、Zookeeper 下 Server工作状态
- 29、获取指定节点信息？
- 30、分布式通知和协调

## 第11章 Kafka（150道）

### 1. Kafka面试题

- 1、解释生产者是什么？
- 生产者的主要作用是将数据发布到他们选择的主题上。基本上，它的职责是选择要分配给主题内分区的记录。
- 2、什么是多租户？
- 我们可以轻松地将Kafka部署为多租户解决方案。但是，通过配置主题可以生成或使用数据，可以启用多租户。此外，它还为配额提供操作支持。
- 3、Kafka为什么不支持读写分离？
- 1、 这其实是分布式场景下的通用问题，因为我们知道CAP理论下，我们只能保证C（一致性）和A（可用性）取其一，如果支持读写分离，那其实对于一致性的要求可能就会有一定折扣，因为通常的场景下，副本之间都是通过同步来实现副本数据一致的，那同步过程中肯定会有时间的消耗，如果支持了读写分离，就意味着可能的数据不一致，或数据滞后。
- 2、 Leader/Follower模型并没有规定Follower副本不可以对外提供读服务。很多框架都是允许这么做的，只是 Kafka最初为了避免不一致性的问题，而采用了让Leader统一提供服务的方式。
- 3、 不过，自Kafka 2.4之后，Kafka提供了有限度的读写分离，也就是说，Follower副本能够对外提供读服务。
- 4、：35, 36, 37
- 5、：11,13,14,16,17,18,19Apache Kafka对于有经验的人的面试
- 6、Leader和Follower的概念是什么？
- 在Kafka的每个分区中，都有一个服务器充当leader，0到多个服务器充当follower的角色。
- 7、Kafka和Flume之间的主要区别是什么？
- 工具类型
- Apache Kafka 是面向多个生产商和消费者的通用工具。
- Apache Flume 是特定应用程序的专用工具。
- 复制功能
- Apache Kafka 可以复制事件；
- Apache Flume 不复制事件。
- 8、没有ZooKeeper可以使用Kafka吗？
- 绕过Zookeeper并直接连接到Kafka服务器是不可能的，所以答案是否定的。如果以某种方式，使ZooKeeper关闭，则无法为任何客户端请求提供服务。
- 9、为什么需要消息系统，MySQL不能满足需求吗？
- 1、 解耦：
- 允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。
- 2、 冗余：
- 消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。
- 3、 扩展性：
- 因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。
- 4、 灵活性 & 峰值处理能力：
- 在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。
- 5、 可恢复性：
- 系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。
- 6、 顺序保证：
- 在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。（Kafka 保证一个 Partition 内的消息的有序性）
- 7、 缓冲：
- 有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。
- 8、 异步通信：
- 很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。
- 10、为什么要使用 Kafka？为什么要使用消息队列？
- 缓冲和削峰：上游数据时有突发流量，下游可能扛不住，或者下游没有足够多的机器来保证冗余，Kafka在中间可以起到一个缓冲的作用，把消息暂存在Kafka中，下游服务就可以按照自己的节奏进行慢慢处理。
- 解耦和扩展性：项目开始的时候，并不能确定具体需求。消息队列可以作为一个接口层，解耦重要的业务流程。只需要遵守约定，针对数据编程即可获取扩展能力。
- 冗余：可以采用一对多的方式，一个生产者消息，可以被多个订阅topic的服务消费到，供多个毫无关联的业务使用。
- 健壮性：消息队列可以堆积请求，所以消费端业务即使短时间死掉，也不会影响主要业务的正常进行。
- 异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。
- 11、没有zookeeper可以使用Kafka吗？
- 12、Kafka 与传统MQ消息系统之间有三个关键区别
- 13、解释偏移的作用。
- 14、解释术语“Log Anatomy”
- 15、副本和ISR扮演什么角色？
- 16、比较RabbitMQ与Apache Kafka
- 17、Apache Kafka是什么？
- 18、consumer是推还是拉？
- 19、如果副本长时间不在ISR中，这意味着什么？
- 20、数据有序
- 21、怎么解决rebalance中遇到的问题呢？
- 22、Kafka分布式（不是单机）的情况下，如何保证消息的顺序消费?
- 23、能简单说一下rebalance过程吗？
- 24、讲一讲Kafka的ack的三种机制
- 25、Apache Kafka是分布式流处理平台吗？如果是，你能用它做什么？
- 26、什么是Kafka中的地域复制？
- 27、在Kafka集群中保留期的目的是什么？
- 28、Kafka的message格式是什么？

### 2. Kafka面试题

- 1、是什么确保了Kafka中服务器的负载平衡？
- 由于领导者的主要角色是执行分区的所有读写请求的任务，而追随者被动地复制领导者。因此，在领导者失败时，其中一个追随者接管了领导者的角色。基本上，整个过程可确保服务器的负载平衡。
- 2、消费者API的作用是什么？
- 允许应用程序订阅一个或多个主题并处理生成给它们的记录流的API，我们称之为消费者API。
- 3、解释流API的作用？
- 一种允许应用程序充当流处理器的API，它还使用一个或多个主题的输入流，并生成一个输出流到一个或多个输出主题，此外，有效地将输入流转换为输出流，我们称之为流API。
- 4、Kafka为什么那么快?
- Cache Filesystem Cache PageCache缓存
- 顺序写 由于现代的操作系统提供了预读和写技术，磁盘的顺序写大多数情况下比随机写内存还要快。
- Zero-copy 零拷技术减少拷贝次数
- Batching of Messages 批量量处理。合并小的请求，然后以流的方式进行交互，直顶网络上限。
- Pull 拉模式 使用拉模式进行消息的获取消费，与消费端处理能力相符。
- 5、Kafka系统工具有哪些类型？
- 1、 Kafka迁移工具：它有助于将代理从一个版本迁移到另一个版本。
- 2、 Mirror Maker：Mirror Maker工具有助于将一个Kafka集群的镜像提供给另一个。
- 3、 消费者检查:对于指定的主题集和消费者组，它显示主题，分区，所有者。
- 6、partition 的数据如何保存到硬盘
- topic 中的多个 partition 以文件夹的形式保存到 broker，每个分区序号从 0 递增，
- 且消息有序
- Partition 文件下有多个 segment（xxx.index，xxx.log）
- segment 文件里的 大小和配置文件大小一致可以根据要求修改 默认为 1g
- 如果大小大于 1g 时，会滚动一个新的 segment 并且以上一个 segment 最后一条消息的偏移
- 量命名
- 7、Zookeeper对于Kafka的作用是什么？
- 1、 Zookeeper是一个开放源码的、高性能的协调服务，它用于Kafka的分布式应用。
- 2、 Zookeeper主要用于在集群中不同节点之间进行通信
- 3、 在Kafka中，它被用于提交偏移量，因此如果节点在任何情况下都失败了，它都可以从之前提交的偏移量中获取
- 4、 除此之外，它还执行其他活动，如: leader检测、分布式同步、配置管理、识别新节点何时离开或连接、集群、节点实时状态等等。
- 8、流API的作用是什么？
- 一种允许应用程序充当流处理器的API，它还使用一个或多个主题的输入流，并生成一个输出流到一个或多个输出主题，此外，有效地将输入流转换为输出流，我们称之为流API。
- 9、Kafka的流处理是什么意思？
- 连续、实时、并发和以逐记录方式处理数据的类型，我们称之为Kafka流处理。
- 10、Kafka集群中保留期的目的是什么？
- 保留期限保留了Kafka群集中的所有已记录。它不会检查它们是否已被消耗。此外，可以通过使用保留期的配置设置来丢弃记录。而且，它可以释放一些空间。
- 11、Kafka 的 ack 机制
- 12、：31, 32, 33, 34, 38, 39, 40Apache Kafka对于有经验的人的面试
- 13、简述Follower副本消息同步的完整流程
- 14、解释一些Kafka流实时用例。
- 15、副本和 ISR 扮演什么角色？
- 16、简单说一下ack机制
- 17、producer 是否直接将数据发送到 broker 的 leader(主节点)？
- 18、Kafka如何不消费重复数据？比如扣款，我们不能重复的扣。
- 19、Kafka中有哪几个组件?
- 20、列出所有Apache Kafka业务
- 21、：3,5,6
- 22、什么是消费者组？
- 23、：1,2,4,7,8,9,10Apache Kafka对于有经验的人的面试
- 24、解释术语“主题复制因子”。
- 25、Kafka存在那些局限性？
- 26、如何调优Kafka？
- 27、如何控制消费的位置
- 28、Kafka提供的保证是什么？

### 3. Kafka面试题

- 1、在生产者中，何时发生QueueFullException？
- 每当Kafka生产者试图以代理的身份在当时无法处理的速度发送消息时，通常都会发生QueueFullException。但是，为了协作处理增加的负载，用户需要添加足够的代理，因为生产者不会阻止。
- 2、如何估算Kafka集群的机器数量？
- 1、 该题也算是SRE的送分题吧，对于SRE来讲，任何生产的系统第一步需要做的就是容量预估以及集群的架构规划，实际上也就是机器数量和所用资源之间的关联关系，资源通常来讲就是CPU，内存，磁盘容量，带宽。但需要注意的是，Kafka因为独有的设计，对于磁盘的要求并不是特别高，普通机械硬盘足够，而通常的瓶颈会出现在带宽上。
- 2、 在预估磁盘的占用时，你一定不要忘记计算副本同步的开销。如果一条消息占用1KB的磁盘空间，那么，在有3个副本的主题中，你就需要3KB的总空间来保存这条消息。同时，需要考虑到整个业务Topic数据保存的最大时间，以上几个因素，基本可以预估出来磁盘的容量需求。
- 3、 需要注意的是：对于磁盘来讲，一定要提前和业务沟通好场景，而不是等待真正有磁盘容量瓶颈了才去扩容磁盘或者找业务方沟通方案。
- 4、 对于带宽来说，常见的带宽有1Gbps和10Gbps，通常我们需要知道，当带宽占用接近总带宽的90%时，丢包情形就会发生。
- 3、分区Leader选举策略有几种？
- 分区的Leader副本选举对用户是完全透明的，它是由Controller独立完成的。你需要回答的是，在哪些场景下，需要执行分区Leader选举。每一种场景对应于一种选举策略。
- 1、 OfflinePartition Leader选举：每当有分区上线时，就需要执行Leader选举。所谓的分区上线，可能是创建了新分区，也可能是之前的下线分区重新上线。这是最常见的分区Leader选举场景。
- 2、 ReassignPartition Leader选举：当你手动运行Kafka-reassign-partitions命令，或者是调用Admin的alterPartitionReassignments方法执行分区副本重分配时，可能触发此类选举。假设原来的AR是[1，2，3]，Leader是1，当执行副本重分配后，副本集合AR被设置成[4，5，6]，显然，Leader必须要变更，此时会发生Reassign Partition Leader选举。
- 3、 PreferredReplicaPartition Leader选举：当你手动运行Kafka-preferred-replica-election命令，或自动触发了Preferred Leader选举时，该类策略被激活。所谓的Preferred Leader，指的是AR中的第一个副本。比如AR是[3，2，1]，那么，Preferred Leader就是3。
- 4、 ControlledShutdownPartition Leader选举：当Broker正常关闭时，该Broker上的所有Leader副本都会下线，因此，需要为受影响的分区执行相应的Leader选举。
- 这4类选举策略的大致思想是类似的，即从AR中挑选首个在ISR中的副本，作为新Leader。
- 4、Kafka中有哪几个组件?
- Kafka最重要的元素是：
- 主题：Kafka主题是一堆或一组消息。生产者：在Kafka，生产者发布通信以及向Kafka主题发布消息。消费者：Kafka消费者订阅了一个主题，并且还从主题中读取和处理消息。经纪人：在管理主题中的消息存储时，我们使用Kafka Brokers。
- 5、：24, 22
- 6、系统工具有哪些类型？
- 系统工具有三种类型：1.Kafka迁移工具：它有助于将代理从一个版本迁移到另一个版本。2.Mirror Maker：Mirror Maker工具有助于将一个Kafka集群的镜像提供给另一个。3.消费者检查:对于指定的主题集和消费者组，它显示主题，分区，所有者。
- 7、比较传统队列系统与Apache Kafka
- 让我们比较一下传统队列系统与Apache Kafka的功能：消息保留 传统的队列系统 - 它通常从队列末尾处理完成后删除消息。 Apache Kafka中，消息即使在处理后仍然存在。这意味着Kafka中的消息不会因消费者收到消息而被删除。基于逻辑的处理传统队列系统不允许基于类似消息或事件处理逻辑。Apache Kafka允许基于类似消息或事件处理逻辑。
- 8、连接器API的作用是什么？
- 一个允许运行和构建可重用的生产者或消费者的API，将Kafka主题连接到现有的应用程序或数据系统，我们称之为连接器API。Apache Kafka对于新手的面试
- 9、消息队列的作用
- 解耦
- 快递小哥手上有很多快递需要送，他每次都需要先电话一一确认收货人是否有空、哪个时间段有空，然后再确定好送货的方案。这样完全依赖收货人了！如果快递一多，快递小哥估计的忙疯了……
- 如果有了便利店，快递小哥只需要将同一个小区的快递放在同一个便利店，然后通知收货人来取货就可以了，这时候快递小哥和收货人就实现了解耦！
- 异步
- 快递小哥打电话给我后需要一直在你楼下等着，直到我拿走你的快递他才能去送其他人的。快递小哥将快递放在小芳便利店后，又可以干其他的活儿去了，不需要等待你到来而一直处于等待状态。提高了工作的效率。
- 削峰
- 假设双十一我买了不同店里的各种商品，而恰巧这些店发货的快递都不一样，有中通、圆通、申通、各种通等……
- 更巧的是他们都同时到货了！中通的小哥打来电话叫我去北门取快递、圆通小哥叫我去南门、申通小哥叫我去东门。我一时手忙脚乱……
- 我们能看到在系统需要交互的场景中，使用消息队列中间件真的是好处多多，基于这种思路，就有了丰巢、菜鸟驿站等比小芳便利店更专业的“中间件”了。
- 10、数据传输的事物定义有哪三种？
- 数据传输的事务定义通常有以下三种级别：
- 1、 最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输
- 2、 最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输、（3）精确的一次（Exactly once）: 不会漏传输也不会重复传输,每个消息都传输被一次而
- 3、 且仅仅被传输一次，这是大家所期望的
- 11、Kafka 存储在硬盘上的消息格式是什么？
- 12、在Kafka中，ZooKeeper的作用是什么？
- 13、Kafka能手动删除消息吗？
- 14、什么是复制工具及其类型？
- 15、什么是Kafka？
- 16、消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1?
- 17、Java Consumer为什么采用单线程来获取消息？
- 18、Kafka 中的消息是否会丢失和重复消费？
- 19、LEO、LSO、AR、ISR、HW都表示什么含义？
- 20、能说一下leader选举过程吗
- 21、解释多租户是什么？
- 22、Kafka一次reblance大概要多久
- 23、：12,15,20
- 24、什么情况下一个 Broker 会从ISR中踢出去?
- 25、启动Kafka服务器的过程是什么？
- 26、解释下Kafka中位移（offset）的作用
- 27、说明Kafka的一个最佳特征。
- 28、消费者负载均衡策略

### 4. Kafka面试题

- 1、3.它还可以在记录进入时对其进行处理。Apache Kafka对于新手的面试
- 2、Broker的Heap Size如何设置？
- 1、 其实对于SRE还是送分题，因为目前来讲大部分公司的业务系统都是使用Java开发，因此SRE对于基本的JVM相关的参数应该至少都是非常了解的，核心就在于JVM的配置以及GC相关的知识。
- 2、 标准答案：任何Java进程JVM堆大小的设置都需要仔细地进行考量和测试。一个常见的做法是，以默认的初始JVM堆大小运行程序，当系统达到稳定状态后，手动触发一次Full GC，然后通过JVM工具查看GC后的存活对象大小。之后，将堆大小设置成存活对象总大小的1.5~2倍。对于Kafka而言，这个方法也是适用的。不过，业界有个最佳实践，那就是将Broker的Heap Size固定为6GB。经过很多公司的验证，这个大小是足够且良好的。
- 3、Rebalance有什么影响
- Rebalance本身是Kafka集群的一个保护设定，用于剔除掉无法消费或者过慢的消费者，然后由于我们的数据量较大，同时后续消费后的数据写入需要走网络IO，很有可能存在依赖的第三方服务存在慢的情况而导致我们超时。Rebalance对我们数据的影响主要有以下几点：
- 数据重复消费: 消费过的数据由于提交offset任务也会失败，在partition被分配给其他消费者的时候，会造成重复消费，数据重复且增加集群压力
- Rebalance扩散到整个ConsumerGroup的所有消费者，因为一个消费者的退出，导致整个Group进行了Rebalance，并在一个比较慢的时间内达到稳定状态，影响面较大
- 频繁的Rebalance反而降低了消息的消费速度，大部分时间都在重复消费和Rebalance
- 数据不能及时消费，会累积lag，在Kafka的TTL之后会丢弃数据 上面的影响对于我们系统来说，都是致命的。
- 4、Kafka的高可用机制是什么？
- 这个问题比较系统，回答出Kafka的系统特点，leader和follower的关系，消息读写的顺序即可。
- https://www.cnblogs.com/qingyunzong/p/9004703.html
- https://www.tuicool.com/articles/BNRza2E
- https://yq.aliyun.com/articles/64703
- 5、解释Kafka可以接收的消息最大为多少？
- Kafka可以接收的最大消息大小约为1000000字节。
- 6、Kafka流的特点。
- Kafka流的一些最佳功能是Kafka Streams具有高度可扩展性和容错性。Kafka部署到容器，VM，裸机，云。我们可以说，Kafka流对于小型，中型和大型用例同样可行。此外，它完全与Kafka安全集成。编写标准Java应用程序。完全一次处理语义。而且，不需要单独的处理集群。
- 7、Kafka Follower如何与Leader同步数据?
- Kafka 的复制机制既不是完全的同步复制，也不是单纯的异步复制。完全同步复制要求 All Alive Follower 都复制完，这条消息才会被认为 commit，这种复制方式极大的影响了吞吐率。而异步复制方式下，Follower 异步的从 Leader 复制数据，数据只要被 Leader 写入 log 就被认为已经 commit，这种情况下，如果 leader 挂掉，会丢失数据，Kafka 使用 ISR 的方式很好的均衡了确保数据不丢失以及吞吐率。Follower 可以批量的从 Leader 复制数据，而且 Leader 充分利用磁盘顺序读以及 send file(zero copy) 机制，这样极大的提高复制性能，内部批量写磁盘，大幅减少了 Follower 与 Leader 的消息量差。
- 8、Kafka的哪些场景中使用了零拷贝（Zero Copy）？
- 1、 其实这道题对于SRE来讲，有点超纲了，不过既然Zero Copy是Kafka高性能的保证，我们需要了解它。
- 2、 Zero Copy是特别容易被问到的高阶题目。在Kafka中，体现Zero Copy使用场景的地方有两处：基于mmap的索引和日志文件读写所用的TransportLayer。
- 3、 先说第一个。索引都是基于MappedByteBuffer的，也就是让用户态和内核态共享内核态的数据缓冲区，此时，数据不需要复制到用户态空间。不过，mmap虽然避免了不必要的拷贝，但不一定就能保证很高的性能。在不同的操作系统下，mmap的创建和销毁成本可能是不一样的。很高的创建和销毁开销会抵消Zero Copy带来的性能优势。由于这种不确定性，在Kafka中，只有索引应用了mmap，最核心的日志并未使用mmap机制。
- 4、 再说第二个。TransportLayer是Kafka传输层的接口。它的某个实现类使用了FileChannel的transferTo方法。该方法底层使用sendfile实现了Zero Copy。对Kafka而言，如果I/O通道使用普通的PLAINTEXT，那么，Kafka就可以利用Zero Copy特性，直接将页缓存中的数据发送到网卡的Buffer中，避免中间的多次拷贝。相反，如果I/O通道启用了SSL，那么，Kafka便无法利用Zero Copy特性了。
- 9、副本长时间不在ISR中，这意味着什么？
- 意味着 follower 不能像 leader 收集数据那样快速地获取数据。
- 10、：46, 48
- 11、Kafka中的数据日志是什么？
- 12、Kafka为何这么快
- 13、Kafka 创建 Topic 时如何将分区放置到不同的 Broker 中
- 14、消费者故障，出现活锁问题如何解决？
- 15、什么是Apache Kafka?
- 16、传统的消息传递方法有哪些类型？
- 17、consumer_offsets是做什么用的？
- 18、解释Kafka Producer API的作用。
- 19、阐述下 Kafka 中的领导者副本（Leader Replica）和追随者副本（Follower Replica）的区别
- 20、讲讲Kafka维护消费状态跟踪的方法
- 21、Kafka 的消费者如何消费数据
- 22、为什么Kafka的复制至关重要？
- 23、如何保证Kafka顺序消费
- 24、Apache Kafka是分布式流处理平台吗？如果是，你能用它做什么？
- 25、为什么Kafka的复制至关重要？
- 26、消费者如何不自动提交偏移量，由应用提交？
- 27、Kafka 新建的分区会在哪个目录下创建
- 28、Kafka中的 zookeeper 起到什么作用？可以不用zookeeper吗？

### 5. Kafka面试题

- 1、Kafka Producer如何优化写入速度?
- 增加线程
- 提高 batch.size
- 增加更多 producer 实例
- 增加 partition 数
- 设置 acks=-1 时，如果延迟增大：可以增大 num.replica.fetchers（follower 同步数据的线程数）来调解；
- 跨数据中心的传输：增加 socket 缓冲区设置以及 OS tcp 缓冲区设置。
- 2、生产者中，什么情况下会发生 QueueFullException？
- 每当Kafka生产者试图以代理的身份在当时无法处理的速度发送消息时，通常都会发生QueueFullException。但是，为了协作处理增加的负载，用户需要添加足够的代理，因为生产者不会阻止。
- 3、数据传输的事务定义有哪三种？
- 和MQTT的事务定义一样都是3种
- 1、 最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输
- 2、 最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输.
- 3、 精确的一次（Exactly once）: 不会漏传输也不会重复传输,每个消息都传输被一次而且仅仅被传输一次，这是大家所期望的
- 4、Kafka Unclean 配置代表什么？会对 spark streaming 消费有什么影响？
- unclean.leader.election.enable 为 true 的话，意味着非 ISR 集合的 broker 也可以参与选举，这样有可能就会丢数据，spark streaming在消费过程中拿到的 end offset 会突然变小，导致 spark streaming job 挂掉。如果 unclean.leader.election.enable 参数设置为 true，就有可能发生数据丢失和数据不一致的情况，Kafka 的可靠性就会降低；而如果 unclean.leader.election.enable 参数设置为 false，Kafka 的可用性就会降低。
- 5、Kafka 中 Consumer Group 是什么概念？
- 同样是逻辑上的概念，是Kafka实现单播和广播两种消息模型的手段。同一个topic的数据，会广播给不同的group；同一个group中的worker，只有一个worker能拿到这个数据。换句话说，对于同一个topic，每个group都可以拿到同样的所有数据，但是数据进入group后只能被其中的一个worker消费。group内的worker可以使用多线程或多进程来实现，也可以将进程分散在多台机器上，worker的数量通常不超过partition的数量，且二者最好保持整数倍关系，因为Kafka在设计时假定了一个partition只能被一个worker消费（同一group内）。
- 6、什么是生产者？
- 生产者的主要作用是将数据到他们选择的主题上。基本上，它的职责是选择要分配给主题内分区的记录。
- 7、Kafka 与传统消息系统之间有三个关键区别
- 1、 Kafka 持久化日志，这些日志可以被重复读取和无限期保留
- 2、 Kafka 是一个分布式系统：它以集群的方式运行，可以灵活伸缩，在内部通过复制数据
- 3、 提升容错能力和高可用性
- 4、 Kafka 支持实时的流式处理
- 8、Kafka 中是怎么体现消息顺序性的？
- Kafka 每个 partition 中的消息在写入时都是有序的，消费时，每个 partition 只能被每一个 group 中的一个消费者消费，保证了消费时也是有序的。整个 topic 不保证有序。如果为了保证 topic 整个有序，那么将 partition 调整为1.
- 9、Apache Kafka的缺陷
- Kafka的局限性是：1.没有完整的监控工具集2.消息调整的
- 10、解释Apache Kafka用例？
- Apache Kafka有很多用例，例如：
- Kafka指标可以使用Kafka进行操作监测数据。此外，为了生成操作数据的集中提要，它涉及到从分布式应用程序聚合统计信息。Kafka日志聚合 从组织中的多个服务收集日志。流处理在流处理过程中，Kafka的强耐久性非常有用。Apache Kafka对于新手的面试
- 11、什么是消费者或用户？
- 12、Controller发生网络分区（Network Partitioning）时，Kafka会怎么样？
- 13、当ack为-1时，什么情况下，Leader 认为一条消息 Commit了？
- 14、Kafka判断一个节点是否还活着有那两个条件？
- 15、偏移的作用是什么？
- 16、Kafka 如何判断节点是否存活
- 17、ISR在Kafka环境中代表什么？
- 18、Java在Apache Kafka中的重要性是什么？
- 19、Kafka中的 Broker 是干什么的？
- 20、连接器API的作用是什么？
- 21、Kafka可以接收的消息最大为多少？
- 22、：41, 42, 43, 44, 45, 47, 49Apache Kafka对于有经验的人的面试
- 23、Kafka中有哪几个组件?
- 24、Kafka 高效文件存储设计特点：
- 25、如何设置Kafka能接收的最大消息的大小？
- 26、3.不支持通配符主题选择4.速度###
- 27、Kafka 判断一个节点是否还活着有那两个条件？

## 第12章 Netty （60道）

### 1. Netty面试题

- 1、NIO的组成？
- Buffer：与Channel进行交互，数据是从Channel读入缓冲区，从缓冲区写入Channel中的
- flip方法 ：反转此缓冲区，将position给limit，然后将position置为0，其实就是切换读写模式
- clear方法 ：清除此缓冲区，将position置为0，把capacity的值给limit。
- rewind方法 ：重绕此缓冲区，将position置为0
- DirectByteBuffer可减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，不可控，通常会用内存池来提高性能。直接缓冲区主要分配给那些易受基础系统的本机I/O 操作影响的大型、持久的缓冲区。如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer，由JVM进行管理。
- Channel：表示 IO 源与目标打开的连接，是双向的，但不能直接访问数据，只能与Buffer 进行交互。通过源码可知，FileChannel的read方法和write方法都导致数据复制了两次！
- Selector可使一个单独的线程管理多个Channel，open方法可创建Selector，register方法向多路复用器器注册通道，可以监听的事件类型：读、写、连接、accept。注册事件后会产生一个SelectionKey：它表示SelectableChannel 和Selector 之间的注册关系，wakeup方法：使尚未返回的第一个选择操作立即返回，唤醒的
- 原因是：注册了新的channel或者事件；channel关闭，取消注册；优先级更高的事件触发（如定时器事件），希望及时处理。
- Selector在Linux的实现类是EPollSelectorImpl，委托给EPollArrayWrapper实现，其中三个native方法是对epoll的封装，而EPollSelectorImpl、implRegister方法，通过调用epoll_ctl向epoll实例中注册事件，还将注册的文件描述符(fd)与SelectionKey的对应关系添加到fdToKey中，这个map维护了文件描述符与SelectionKey的映射。
- fdToKey有时会变得非常大，因为注册到Selector上的Channel非常多（百万连接）；过期或失效的Channel没有及时关闭。fdToKey总是串行读取的，而读取是在select方法中进行的，该方法是非线程安全的。
- Pipe：两个线程之间的单向数据连接，数据会被写到sink通道，从source通道读取
- NIO的服务端建立过程：Selector.open()：打开一个Selector；ServerSocketChannel.open()：创建服务端的Channel；bind()：绑定到某个端口上。并配置非阻塞模式；register()：注册Channel和关注的事件到Selector上；select()轮询拿到已经就绪的事件
- 2、Netty 的线程模型？
- Netty 通过 Reactor 模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss 线程池和 work 线程池，其中** boss 线程池**的线程负责处理请求的 accept 事件，当接收到 accept 事件的请求时，把对应的 socket 封装到一个 NioSocketChannel 中，并交给 work线程池，其中 work 线程池负责请求的 read 和 write 事件，由对应的 Handler 处理。
- **单线程模型：**所有 I/O 操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor 线程上完成的。既要接收客户端的连接请求,向服务端发起连接，又要发送/读取请求或应答/响应消息。一个 NIO线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。
- **多线程模型：**有一个 NIO 线程（Acceptor） 只负责监听服务端，接收客户端的 TCP 连接请求；NIO 线程池负责网络 IO 的操作，即消息的读取、解码、编码和发送；1 个 NIO 线程可以同时处理 N 条链路，但是 1 个链路只对应 1 个 NIO 线程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个 Acceptor 线程可能会存在性能不足问题。
- **主从多线程模型：**Acceptor线程用于绑定监听端口，接收客户端连接，将 SocketChannel从主线程池的 Reactor 线程的多路复用器上移除，重新注册到 Sub 线程池的线程上，用于处理 I/O 的读写等操作，从而保证 mainReactor 只负责接入认证、握手等操作；
- 3、Netty 核心组件有哪些？分别有什么作用？
- Netty 核心组件有哪些？分别有什么作用？
- Channel
- Channel 接口是 Netty 对网络操作抽象类，它除了包括基本的 I/O 操作，如 bind()、connect()、read()、write() 等。
- 比较常用的Channel接口实现类是NioServerSocketChannel（服务端）和NioSocketChannel（客户端），这两个 Channel 可以和 BIO 编程模型中的ServerSocket以及Socket两个概念对应上。Netty 的 Channel 接口所提供的 API，大大地降低了直接使用 Socket 类的复杂性。
- EventLoop
- 这么说吧！EventLoop（事件循环）接口可以说是 Netty 中最核心的概念了！
- 《Netty 实战》这本书是这样介绍它的：
- EventLoop 定义了 Netty 的核心抽象，用于处理连接的生命周期中所发生的事件。
- 是不是很难理解？说实话，我学习 Netty 的时候看到这句话是没太能理解的。
- 说白了，EventLoop 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。
- 那 Channel 和 EventLoop 直接有啥联系呢？
- Channel 为 Netty 网络操作(读写等操作)抽象类，EventLoop 负责处理注册到其上的Channel 处理 I/O 操作，两者配合参与 I/O 操作。
- ChannelFuture
- Netty 是异步非阻塞的，所有的 I/O 操作都为异步的。
- 因此，我们不能立刻得到操作是否执行成功，但是，你可以通过 ChannelFuture 接口的 addListener() 方法注册一个 ChannelFutureListener，当操作执行成功或者失败时，监听就会自动触发返回结果。
- 并且，你还可以通过ChannelFuture 的 channel() 方法获取关联的Channel
- public interface ChannelFuture extends Future<Void> {
-     Channel channel();
-     ChannelFuture addListener(GenericFutureListener<? extends Future<? super Void>> var1);
-      ......
-     ChannelFuture sync() throws InterruptedException;
- }
- 另外，我们还可以通过 ChannelFuture 接口的 sync()方法让异步的操作变成同步的。
- ChannelHandler 和 ChannelPipeline
- 下面这段代码使用过 Netty 的小伙伴应该不会陌生，我们指定了序列化编解码器以及自定义的 ChannelHandler 处理消息。
- b.group(eventLoopGroup)
-         .handler(new ChannelInitializer<SocketChannel>() {
-             @Override
-             protected void initChannel(SocketChannel ch) {
-                 ch.pipeline().addLast(new NettyKryoDecoder(kryoSerializer, RpcResponse.class));
-                 ch.pipeline().addLast(new NettyKryoEncoder(kryoSerializer, RpcRequest.class));
-                 ch.pipeline().addLast(new KryoClientHandler());
-             }
-         });
- ChannelHandler 是消息的具体处理器。他负责处理读写操作、客户端连接等事情。
- ChannelPipeline 为 ChannelHandler 的链，提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API 。当 Channel 被创建时，它会被自动地分配到它专属的 ChannelPipeline。
- 我们可以在 ChannelPipeline 上通过 addLast() 方法添加一个或者多个ChannelHandler ，因为一个数据或者事件可能会被多个 Handler 处理。当一个 ChannelHandler 处理完之后就将数据交给下一个 ChannelHandler 。
- 4、什么是 TCP 粘包/拆包?有什么解决办法呢？
- 什么是 TCP 粘包/拆包?
- TCP 粘包/拆包 就是你基于 TCP 发送数据的时候，出现了多个字符串“粘”在了一起或者一个字符串被“拆”开的问题。比如你多次发送：“你好,你真帅啊！哥哥！”，但是客户端接收到的可能是下面这样的：
- 那有什么解决办法呢?
- 使用 Netty 自带的解码器
- LineBasedFrameDecoder : 发送端发送数据包的时候，每个数据包之间以换行符作为分隔，LineBasedFrameDecoder 的工作原理是它依次遍历 ByteBuf 中的可读字节，判断是否有换行符，然后进行相应的截取。
- DelimiterBasedFrameDecoder : 可以自定义分隔符解码器，LineBasedFrameDecoder 实际上是一种特殊的 DelimiterBasedFrameDecoder 解码器。
- FixedLengthFrameDecoder: 固定长度解码器，它能够按照指定的长度对消息进行相应的拆包。
- LengthFieldBasedFrameDecoder：
- 自定义序列化编解码器
- 在 Java 中自带的有实现 Serializable 接口来实现序列化，但由于它性能、安全性等原因一般情况下是不会被使用到的。
- 通常情况下，我们使用 Protostuff、Hessian2、json 序列方式比较多，另外还有一些序列化性能非常好的序列化方式也是很好的选择：
- 专门针对 Java 语言的：Kryo，FST 等等
- 跨语言的：Protostuff（基于 protobuf 发展而来），ProtoBuf，Thrift，Avro，MsgPack 等等
- 5、Netty 的使用场景
- 1、 构建高性能、低时延的各种 Java 中间件，Netty 主要作为基础通信框架提供高性能、低时延的通信服务。例如：RocketMQ ，分布式消息队列。Dubbo ，服务调用框架。Spring WebFlux ，基于响应式的 Web 框架。
- 2、 公有或者私有协议栈的基础通信框架，例如可以基于 Netty 构建异步、高性能的 WebSocket、Protobuf 等协议的支持。
- 3、 各领域应用，例如大数据、游戏等，Netty 作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。
- 6、如何选择序列化协议？
- 具体场景
- 对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。
- 基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。
- 对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。
- 当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。
- 对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在hadoop子项目里，Avro会是更好的选择。
- 对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯。由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。
- 如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。
- 如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。
- protobuf的数据类型有多种：bool、double、float、int32、int64、string、bytes、enum、message。protobuf的限定符：required: 必须赋值，不能为空、optional:字段可以赋值，也可以不赋值、repeated: 该字段可以重复任意次数（包括0次）、枚举；只能用指定的常量集中的一个值作为其值；
- protobuf的基本规则：每个消息中必须至少留有一个required类型的字段、包含0个或多个optional类型的字段；repeated表示的字段可以包含0个或多个数据；[1,15]之内的标识号在编码的时候会占用一个字节（常用），[16,2047]之内的标识号则占用2个字节，标识号一定不能重复、使用消息类型，也可以将消息嵌套任意多层，可用嵌套消息类型来代替组。
- protobuf的消息升级原则：不要更改任何已有的字段的数值标识；不能移除已经存在的required字段，optional和repeated类型的字段可以被移除，但要保留标号不能被重用。新添加的字段必须是optional或repeated。因为旧版本程序无法读取或写入新增的required限定符的字段。
- 编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。如：UserProto.User.Builder builder = UserProto.User.newBuilder();builder.build()；
- Netty中的使用：ProtobufVarint32FrameDecoder 是用于处理半包消息的解码类；ProtobufDecoder(UserProto.User.getDefaultInstance())这是创建的UserProto.java文件中的解码类；ProtobufVarint32LengthFieldPrepender 对protobuf协议的消息头上加上一个长度为32的整形字段，用于标志这个消息的长度的类；ProtobufEncoder 是编码类
- 将StringBuilder转换为ByteBuf类型：copiedBuffer()方法
- 7、TCP 粘包/拆包的原因及解决方法？
- TCP 是以流的方式来处理数据，一个完整的包可能会被 TCP 拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。
- TCP 粘包/分包的原因：
- 应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；
- 进行 MSS 大小的 TCP 分段，当 TCP 报文长度-TCP 头部长度>MSS 的时候将发生拆包以太网帧的 payload（净荷）大于 MTU（1500 字节）进行 ip 分片。
- 解决方法
- **消息定长：**FixedLengthFrameDecoder 类
- **包尾增加特殊字符分割：**行分隔符类：LineBasedFrameDecoder 或自定义分隔符类
- **DelimiterBasedFrameDecoder：**将消息分为消息头和消息体：LengthFieldBasedFrameDecoder 类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。
- 8、Netty 的零拷贝实现？
- Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。堆内存多了一次内存拷贝，JVM 会将堆内存Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。ByteBuffer 由 ChannelConfig 分配，而 ChannelConfig 创建 ByteBufAllocator 默认使用 Direct Buffer
- CompositeByteBuf 类可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。addComponents 方法将header与 body 合并为一个逻辑上的 ByteBuf, 这两个 ByteBuf 在 CompositeByteBuf 内部都是单独存在的, CompositeByteBuf 只是逻辑上是一个整体。
- 通过 FileRegion 包装的 FileChannel.tranferTo 方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。
- 通过 wrap 方法, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer 等包装成一个 NettyByteBuf 对象, 进而避免了拷贝操作。
- Selector  BUG：若 Selector 的轮询结果为空，也没有 wakeup 或新消息处理，则发生空轮询，CPU 使用率 100%，
- Netty 的解决办法：对 Selector 的 select 操作周期进行统计，每完成一次空的 select 操作进行一次计数，若在某个周期内连续发生 N 次空轮询，则触发了 epoll 死循环 bug。重建Selector，判断是否是其他线程发起的重建请求，若不是则将原 SocketChannel 从旧的Selector 上去除注册，重新注册到新的 Selector 上，并将原来的 Selector 关闭。
- 9、Netty的线程模型？
- Netty通过Reactor模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件，由对应的Handler处理。
- 单线程模型：所有I/O操作都由一个线程完成，即多路复用、事件分发和处理都是在一个Reactor线程上完成的。既要接收客户端的连接请求,向服务端发起连接，又要发送/读取请求或应答/响应消息。一个NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、大并发的应用场景不合适。
- 多线程模型：有一个NIO 线程（Acceptor） 只负责监听服务端，接收客户端的TCP 连接请求；NIO 线程池负责网络IO 的操作，即消息的读取、解码、编码和发送；1 个NIO 线程可以同时处理N 条链路，但是1 个链路只对应1 个NIO 线程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个Acceptor 线程可能会存在性能不足问题。
- 主从多线程模型：Acceptor 线程用于绑定监听端口，接收客户端连接，将SocketChannel 从主线程池的Reactor 线程的多路复用器上移除，重新注册到Sub 线程池的线程上，用于处理I/O 的读写等操作，从而保证mainReactor只负责接入认证、握手等操作；
- 10、Netty 空闲检测
- IdleStateHandler ，用于检测连接的读写是否处于空闲状态。如果是，则会触发 IdleStateEvent 。
- 11、Netty 高性能表现在哪些方面？
- 12、Netty自己实现的ByteBuf有什么优点
- 13、NIO 的组成？
- 14、Bootstrap 和 ServerBootstrap 了解么？
- 15、NioEventLoopGroup 默认的构造函数会起多少线程？
- 16、Netty怎样实现零拷贝
- 17、NIOEventLoopGroup 源码？
- 18、Netty 如何实现高性能
- 19、Netty为什么说使用简单
- 20、TCP 粘包/拆包的原因及解决方法？
- 21、Netty 的高性能体现在哪方面
- 22、Netty 的优势有哪些？
- 23、Netty 和 Tomcat 的区别？
- 24、Netty的特点是什么（ 为什么选择 Netty ）
- 25、Netty 长连接、心跳机制了解么？
- 26、Netty 线程模型了解么？
- 27、Netty如何实现重连
- 28、Netty 的核心组件介绍下
- 29、Netty 是什么？
- 30、为什么要用 Netty？
- 31、默认情况 Netty 起多少线程？何时启动？
- 32、AIO 是什么？
- 33、什么是Netty
- 34、BIO、NIO和AIO的区别？

### 2. Netty面试题

- 1、Netty 是什么？
- Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。Netty是基于nio的，它封装了jdk的nio，让我们使用起来更加方法灵活。
- 2、NIOEventLoopGroup源码？
- NioEventLoopGroup(其实是MultithreadEventExecutorGroup) 内部维护一个类型为 EventExecutor children [], 默认大小是处理器核数 * 2, 这样就构成了一个线程池，初始化EventExecutor时NioEventLoopGroup重载newChild方法，所以children元素的实际类型为NioEventLoop。
- 线程启动时调用SingleThreadEventExecutor的构造方法，执行NioEventLoop类的run方法，首先会调用hasTasks()方法判断当前taskQueue是否有元素。如果taskQueue中有元素，执行 selectNow() 方法，最终执行selector.selectNow()，该方法会立即返回。如果taskQueue没有元素，执行 select(oldWakenUp) 方法
- select ( oldWakenUp) 方法解决了 Nio 中的 bug，selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()，若触发了epoll的空轮询bug，则会反复执行selector.select(timeoutMillis)，变量selectCnt 会逐渐变大，当selectCnt 达到阈值（默认512），则执行rebuildSelector方法，进行selector重建，解决cpu占用100%的bug。
- rebuildSelector方法先通过openSelector方法创建一个新的selector。然后将old selector的selectionKey执行cancel。最后将old selector的channel重新注册到新的selector中。rebuild后，需要重新执行方法selectNow，检查是否有已ready的selectionKey。
- 接下来调用processSelectedKeys 方法（处理I/O任务），当selectedKeys != null时，调用processSelectedKeysOptimized方法，迭代 selectedKeys 获取就绪的 IO 事件的selectkey存放在数组selectedKeys中, 然后为每个事件都调用 processSelectedKey 来处理它，processSelectedKey 中分别处理OP_READ；OP_WRITE；OP_CONNECT事件。
- 最后调用runAllTasks方法（非IO任务），该方法首先会调用fetchFromScheduledTaskQueue方法，把scheduledTaskQueue中已经超过延迟执行时间的任务移到taskQueue中等待被执行，然后依次从taskQueue中取任务执行，每执行64个任务，进行耗时检查，如果已执行时间超过预先设定的执行时间，则停止执行非IO任务，避免非IO任务太多，影响IO任务的执行。
- 每个NioEventLoop对应一个线程和一个Selector，NioServerSocketChannel会主动注册到某一个NioEventLoop的Selector上，NioEventLoop负责事件轮询。
- Outbound 事件都是请求事件, 发起者是 Channel，处理者是 unsafe，通过 Outbound 事件进行通知，传播方向是 tail到head。Inbound 事件发起者是 unsafe，事件的处理者是 Channel, 是通知事件，传播方向是从头到尾。
- 内存管理机制，首先会预申请一大块内存Arena，Arena由许多Chunk组成，而每个Chunk默认由2048个page组成。Chunk通过AVL树的形式组织Page，每个叶子节点表示一个Page，而中间节点表示内存区域，节点自己记录它在整个Arena中的偏移地址。当区域被分配出去后，中间节点上的标记位会被标记，这样就表示这个中间节点以下的所有节点都已被分配了。大于8k的内存分配在poolChunkList中，而PoolSubpage用于分配小于8k的内存，它会把一个page分割成多段，进行内存分配。
- ByteBuf的特点：支持自动扩容（4M），保证put方法不会抛出异常、通过内置的复合缓冲类型，实现零拷贝（zero-copy）；不需要调用flip()来切换读/写模式，读取和写入索引分开；方法链；引用计数基于AtomicIntegerFieldUpdater用于内存回收；PooledByteBuf采用二叉树来实现一个内存池，集中管理内存的分配和释放，不用每次使用都新建一个缓冲区对象。UnpooledHeapByteBuf每次都会新建一个缓冲区对象。
- 3、BIO 是什么？
- 1、 BIO ，全称 Block-IO ，是一种阻塞 + 同步的通信模式。一种比较传统的通信方式，模式简单，使用方便。但并发处理能力低，通信耗时，依赖网速。
- 2、 原理：服务器通过一个 Acceptor 线程，负责监听客户端请求和为每个客户端创建一个新的线程进行链路处理。典型的一请求一应答模式。若客户端数量增多，频繁地创建和销毁线程会给服务器打开很大的压力。后改良为用线程池的方式代替新增线程，被称为伪异步 IO 。
- 4、Netty 服务端和客户端的启动过程了解么？
- 服务端
-         // 1.bossGroup 用于接收连接，workerGroup 用于具体的处理
-         EventLoopGroup bossGroup = new NioEventLoopGroup(1);
-         EventLoopGroup workerGroup = new NioEventLoopGroup();
-         try {
-             //2.创建服务端启动引导/辅助类：ServerBootstrap
-             ServerBootstrap b = new ServerBootstrap();
-             //3.给引导类配置两大线程组,确定了线程模型
-             b.group(bossGroup, workerGroup)
-                     // (非必备)打印日志
-                     .handler(new LoggingHandler(LogLevel.INFO))
-                     // 4.指定 IO 模型
-                     .channel(NioServerSocketChannel.class)
-                     .childHandler(new ChannelInitializer<SocketChannel>() {
-                         @Override
-                         public void initChannel(SocketChannel ch) {
-                             ChannelPipeline p = ch.pipeline();
-                             //5.可以自定义客户端消息的业务处理逻辑
-                             p.addLast(new HelloServerHandler());
-                         }
-                     });
-             // 6.绑定端口,调用 sync 方法阻塞知道绑定完成
-             ChannelFuture f = b.bind(port).sync();
-             // 7.阻塞等待直到服务器Channel关闭(closeFuture()方法获取Channel 的CloseFuture对象,然后调用sync()方法)
-             f.channel().closeFuture().sync();
-         } finally {
-             //8.优雅关闭相关线程组资源
-             bossGroup.shutdownGracefully();
-             workerGroup.shutdownGracefully();
-         }
- 5、Netty 的高性能表现在哪些方面？
- **心跳，对服务端：**会定时清除闲置会话 inactive(netty5)，对客户端:用来检测会话是否断开，是否重来，检测网络延迟，其中 idleStateHandler 类 用来检测会话状态
- **串行无锁化设计，**即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。
- **可靠性，链路有效性检测：**链路空闲检测机制，读/写空闲超时机制；内存保护机制：通过内存池重用 ByteBuf;ByteBuf 的解码保护；优雅停机：不再接收新消息、退出前的预处理操作、资源的释放操作。
- **Netty 安全性：**支持的安全协议：SSL V2 和 V3，TLS，SSL 单向认证、双向认证和第三方 CA证。
- **高效并发编程的体现：**volatile 的大量、正确使用；CAS 和原子类的广泛使用；线程安全容器的使用；通过读写锁提升并发性能。IO 通信性能三原则：传输（AIO）、协议（Http）、线程（主从多线程）
- **流量整型的作用（变压器）：**防止由于上下游网元性能不均衡导致下游网元被压垮，业务流中断；防止由于通信模块接受消息过快，后端业务线程处理不及时导致撑死问题。
- **TCP 参数配置：**SO_RCVBUF 和 SO_SNDBUF：通常建议值为 128K 或者 256K；
- SO_TCPNODELAY：NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法；
- 6、Netty 的特点是什么？
- 1、 高并发：Netty 是一款基于 NIO（Nonblocking IO，非阻塞IO）开发的网络通信框架，对比于 BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高。
- 2、 传输快：Netty 的传输依赖于零拷贝特性，尽量减少不必要的内存拷贝，实现了更高效率的传输。
- 3、 封装好：Netty 封装了 NIO 操作的很多细节，提供了易于使用调用接口。
- 7、NIO 是什么？
- 1、 NIO ，全称 New IO ，也叫 Non-Block IO ，是一种非阻塞 + 同步的通信模式。Java NIO( New IO 或者 Non Blocking IO ) ，从 Java 1.4 版本开始引入的非阻塞 IO ，用于替换标准( 有些文章也称为传统，或者 Blocking IO 。下文统称为 BIO ) Java IO API 的 IO API 。
- 2、 NIO 相对于 BIO 来说一大进步。客户端和服务器之间通过 Channel 通信。NIO 可以在 Channel 进行读写操作。这些 Channel 都会被注册在 Selector 多路复用器上。Selector 通过一个线程不停的轮询这些 Channel 。找出已经准备就绪的 Channel 执行 IO 操作。
- 8、详细看说下 Netty 中的线程模型吧！
- 单线程模型 ：
- 一个线程需要执行处理所有的 accept、read、decode、process、encode、send 事件。对于高负载、高并发，并且对性能要求比较高的场景不适用。
- 对应到 Netty 代码是下面这样的
- 使用 NioEventLoopGroup 类的无参构造函数设置线程数量的默认值就是 **CPU 核心数 2 。
-   //1.eventGroup既用于处理客户端连接，又负责具体的处理。
-   EventLoopGroup eventGroup = new NioEventLoopGroup(1);
-   //2.创建服务端启动引导/辅助类：ServerBootstrap
-   ServerBootstrap b = new ServerBootstrap();
-             boobtstrap.group(eventGroup, eventGroup)
-             //......
- 多线程模型
- 一个 Acceptor 线程只负责监听客户端的连接，一个 NIO 线程池负责具体处理：accept、read、decode、process、encode、send 事件。满足绝大部分应用场景，并发连接量不大的时候没啥问题，但是遇到并发连接大的时候就可能会出现问题，成为性能瓶颈。
- 对应到 Netty 代码是下面这样的：
- // 1.bossGroup 用于接收连接，workerGroup 用于具体的处理
- EventLoopGroup bossGroup = new NioEventLoopGroup(1);
- EventLoopGroup workerGroup = new NioEventLoopGroup();
- try {
-   //2.创建服务端启动引导/辅助类：ServerBootstrap
-   ServerBootstrap b = new ServerBootstrap();
-   //3.给引导类配置两大线程组,确定了线程模型
-   b.group(bossGroup, workerGroup)
-     //......
- 主从多线程模型
- 从一个 主线程 NIO 线程池中选择一个线程作为 Acceptor 线程，绑定监听端口，接收客户端连接的连接，其他线程负责后续的接入认证等工作。连接建立完成后，Sub NIO 线程池负责具体处理 I/O 读写。如果多线程模型无法满足你的需求的时候，可以考虑使用主从多线程模型 。
- // 1.bossGroup 用于接收连接，workerGroup 用于具体的处理
- EventLoopGroup bossGroup = new NioEventLoopGroup();
- EventLoopGroup workerGroup = new NioEventLoopGroup();
- try {
-   //2.创建服务端启动引导/辅助类：ServerBootstrap
-   ServerBootstrap b = new ServerBootstrap();
-   //3.给引导类配置两大线程组,确定了线程模型
-   b.group(bossGroup, workerGroup)
-     //......
- 9、TCP 粘包 / 拆包的产生原因，应该这么解决
- 1、 TCP 是以流的方式来处理数据，所以会导致粘包 / 拆包。
- 2、 拆包：一个完整的包可能会被 TCP 拆分成多个包进行发送。
- 3、 粘包：也可能把小的封装成一个大的数据包发送。
- 4、 Netty中提供了多个 Decoder 解析类 用于解决上述问题：
- 5、 FixedLengthFrameDecoder 、LengthFieldBasedFrameDecoder ，固定长度是消息头指定消息长度的一种形式，进行粘包拆包处理的。
- 6、 LineBasedFrameDecoder 、DelimiterBasedFrameDecoder ，换行是于指定消息边界方式的一种形式，进行消息粘包拆包处理的。
- 10、BIO、NIO 和 AIO 的区别？
- **BIO：**一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。
- **伪异步 IO：**将请求连接放入线程池，一对多，但线程还是很宝贵的资源。
- **NIO：**一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求时才启动一个线程进行处理。
- **AIO：**一个有效请求一个线程，客户端的 I/O 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理。
- BIO 是面向流的，NIO 是面向缓冲区的；BIO 的各种流是阻塞的。而 NIO 是非阻塞的；BIO的 Stream 是单向的，而 NIO 的 channel 是双向的。
- **NIO 的特点：**事件驱动模型、单线程处理多任务、非阻塞 I/O，I/O 读写不再阻塞，而是返回 0、基于 block 的传输比基于流的传输更高效、更高级的 IO 函数 zero-copy、IO 多路复用大大提高了 Java 网络应用的可伸缩性和实用性。基于 Reactor 线程模型。
- 在 Reactor 模式中，事件分发器等待某个事件或者可应用或个操作的状态发生，事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。如在 Reactor 中实现读：注册读就绪事件和相应的事件处理器、事件分发器等待事件、事件到来，激活分发器，分发器调用事件对应的处理器、事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。
- 11、了解哪几种序列化协议？
- 12、Netty 中的零拷贝体现在几个方面：
- 13、Netty 支持哪些心跳类型设置？
- 14、了解哪几种序列化协议
- 15、什么是 Reactor 模型
- 16、Netty 的特点？
- 17、Netty 的零拷贝了解么？
- 18、Netty 中有哪种重要组件？
- 19、Netty 的可扩展如何体现
- 20、了解哪几种序列化协议？
- 21、为什么需要心跳机制？Netty 中心跳机制了解么？
- 22、JDK原生NIO程序的问题
- 23、Netty 应用场景了解么？
- 24、如何选择序列化协议？
- 25、Netty为什么要实现内存管理
- 26、原生的NIO存在Epoll Bug有什么BUG、Netty 是怎么解决的
- 27、EventloopGroup 了解么?和 EventLoop 啥关系?
- 28、简单解析一下服务端的创建过程具体是怎样的：
- 29、BIO、NIO 有什么区别？
- 30、Netty 发送消息有几种方式？
- 31、什么是 Netty 的零拷贝？
- 32、客户端代码
- 33、Netty的高可靠体现在哪几方面
- 34、Netty 的应用场景有哪些？

## 第13章 Dubbo （150道）

### 1. Dubbo面试题

- 1、说说核心的配置有哪些？
- 标签	用途	解释
- dubbo:service/	服务配置	用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心
- dubbo:reference/	引用配置	用于创建一个远程服务代理，一个引用可以指向多个注册中心
- dubbo:protocol/	协议配置	用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受
- dubbo:application/	应用配置	用于配置当前应用信息，不管该应用是提供者还是消费者
- dubbo:module/	模块配置	用于配置当前模块信息，可选
- dubbo:registry/	注册中心配置	用于配置连接注册中心相关信息
- dubbo:monitor/	监控中心配置	用于配置连接监控中心相关信息，可选
- dubbo:provider/	提供方配置	当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选
- dubbo:consumer/	消费方配置	当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选
- dubbo:method/	方法配置	用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息
- dubbo:argument	参数配置	用于指定方法参数配置
- 如果是SpringBoot项目就只需要注解，或者开Application配置文件！！！
- 2、Dubbo 支持哪些协议，每种协议的应用场景，优缺点？
- 1、 dubbo：单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步， Hessian 序列化；
- 2、 rmi：采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现Serializable 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。多个短连接， TCP 协议传输，同步传输，适用常规的远程服务调用和 rmi 互操作。在依赖低版本的 Common-Collections 包， java 序列化存在安全漏洞；
- 3、 http：基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用；
- 4、 webservice：基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用；
- 5、 hessian：集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输， Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；
- 6、 Redis：基于 Redis 实现的 RPC 协议
- 3、服务提供者能实现失效踢出是什么原理？
- 服务失效踢出基于zookeeper的临时节点原理。
- 4、PRC架构组件
- 一个基本的RPC架构里面应该至少包含以下4个组件：
- 1、 客户端（Client）:服务调用方（服务消费者）
- 2、 客户端存根（Client Stub）:存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端
- 3、 服务端存根（Server Stub）:接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理4、服务端（Server）:服务的真正提供者
- 具体调用过程：
- 1、 服务消费者（client客户端）通过调用本地服务的方式调用需要消费的服务；
- 2、 客户端存根（client stub）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体；
- 3、 客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端；
- 4、 服务端存根（server stub）收到消息后进行解码（反序列化操作）；
- 5、 服务端存根（server stub）根据解码结果调用本地的服务进行相关处理；
- 6、 本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）；
- 7、 服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方；
- 8、 客户端存根（client stub）接收到消息，并进行解码（反序列化）；
- 9、 服务消费方得到最终结果；
- 而RPC框架的实现目标则是将上面的第2-10步完好地封装起来，也就是把调用、编码/解码的过程给封装起来，让用户感觉上像调用本地服务一样的调用远程服务。
- 5、服务调用是阻塞的吗？
- 默认是阻塞的，可以异步调用，没有返回值的可以这么做。
- 6、dubbo 服务集群配置（集群容错模式）
- 在集群调用失败时， Dubbo 提供了多种容错方案，缺省为 failover 重试。可以自行扩展集群容错策略
- l Failover Cluster(默认)
- 失败自动切换，当出现失败，重试其它服务器。(缺省)通常用于读操作，
- 但重试会带来更长延迟。可通过 retries="2"来设置重试次数(不含第一次)。
- <dubbo:service retries="2" cluster="failover"/>或：<dubbo:reference retries="2" cluster="failover"/>cluster="failover"可以不用写,因为默认就是 failover
- Failfast Cluster
- 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，
- 比如新增记录。
- dubbo:service cluster="failfast" />
- 或：
- <dubbo:reference cluster="failfast" />
- cluster="failfast"和 把 cluster="failover"、 retries="0"是一样的效果,retries="0"就是不重
- Failsafe Cluster失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。
- <dubbo:service cluster="failsafe" />
- 或：
- <dubbo:reference cluster="failsafe" />
- Failback Cluster
- 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。
- <dubbo:service cluster="failback" />
- 或：
- <dubbo:reference cluster="failback" />
- Forking Cluster并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读
- 操作，但需要浪费更多服务资源。可通过 forks="2"来设置最大并行数。
- <dubbo:service cluster=“forking" forks="2"/>
- 或：
- <dubbo:reference cluster=“forking" forks="2"/>
- 7、Dubbo 核心功能有哪些？
- 1、 Remoting：网络通信框架，提供对多种NIO框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。
- 2、 Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。
- 3、 Registry：服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。
- 8、为什么要用Dubbo？
- 随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系(SOA)，
- 也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架。
- 就这样为分布式系统的服务治理框架就出现了，Dubbo也就这样产生了。
- 9、服务调用超时问题怎么解决
- dubbo在调用服务不成功时，默认是会重试两次的。这样在服务端的处理时间超过了设定的超时时间时，就会有重复请求，比如在发邮件时，可能就会发出多份重复邮件，执行注册请求时，就会插入多条重复的注册数据，那么怎么解决超时问题呢？如下
- 对于核心的服务中心，去除dubbo超时重试机制，并重新评估设置超时时间。 业务处理代码必须放在服务端，客户端只做参数验证和服务调用，不涉及业务流程处理 全局配置实例
- <dubbo:provider delay="-1" timeout="6000" retries="0"/>
- 当然Dubbo的重试机制其实是非常好的QOS保证，它的路由机制，是会帮你把超时的请求路由到其他机器上，而不是本机尝试，所以 dubbo的重试机器也能一定程度的保证服务的质量。但是请一定要综合线上的访问情况，给出综合的评估。
- 10、dubbo 通信协议 dubbo 协议为什么要消费者比提供者个数多？
- 因 dubbo 协议采用单一长连接，假设网络为千兆网卡(1024Mbit=128MByte)，根据测试经验数据每条连接最多只能压满 7MByte(不同的环境可能不一样，供参考)，理论上 1 个服务提供者需要 20个服务消费者才能压满网卡。
- 11、Dubbo服务降级，失败重试怎么做？
- 12、dubbo是什么
- 13、Dubbo 和 Spring Cloud 的区别？
- 14、RPC和SOA、SOAP、REST的区别
- 15、Dubbo 支持分布式事务吗？
- 16、RPC使用了哪些关键技术，序列化
- 17、Dubbo SPI 和 Java SPI 区别？
- 18、为什么要用 Dubbo？
- 19、dubbo 通信协议 dubbo 协议为什么采用异步单一长连接
- 20、Dubbo必须依赖的包有哪些？
- 21、你还了解别的分布式框架吗？
- 22、Dubbo 支持哪些协议，它们的优缺点有哪些？
- 23、Dubbo 使用的是什么通信框架?
- 24、Dubbo 集群的负载均衡有哪些策略?
- 25、Dubbo 推荐什么协议？
- 26、Dubbo 和 Spring Cloud 有什么哪些区别？
- 27、Dubbo telnet 命令能做什么？
- 28、Dubbo集群提供了哪些负载均衡策略？
- 29、dubbo 和 dubbox 之间的区别？
- 30、dubbo 在安全机制方面如何解决的？

### 2. Dubbo面试题

- 1、Dubbo 是什么？
- Dubbo 是一个分布式、高性能、透明化的 RPC 服务框架，提供服务自动注册、自动发现等高效服务治理方案， 可以和Spring 框架无缝集成
- 2、Dubbo 核心组件有哪些？
- 1、 Provider：暴露服务的服务提供方
- 2、 Consumer：调用远程服务消费方
- 3、 Registry：服务注册与发现注册中心
- 4、 Monitor：监控中心和访问调用统计
- 5、 Container：服务运行容器
- 3、说说核心的配置有哪些？
- 核心配置有：
- 1、 dubbo:service/
- 2、 dubbo:reference/
- 3、 dubbo:protocol/
- 4、 dubbo:registry/
- 5、 dubbo:application/
- 6、 dubbo:provider/
- 7、 dubbo:consumer/
- 8、 dubbo:method/
- 4、什么是RPC
- RPC（Remote Procedure Call Protocol）远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。简言之，RPC使得程序能够像访问本地系统资源一样，去访问远端系统资源。比较关键的一些方面包括：通讯协议、序列化、资源（接口）描述、服务框架、性能、语言支持等。
- 简单的说，RPC就是从一台机器(客户端)上通过参数传递的方式调用另一台机器(服务器)上的一个函数或方法(可以统称为服务)并得到返回的结果。
- 5、RPC使用了哪些关键技术，Thrift
- 是一种可伸缩的跨语言服务的软件框架。它拥有功能强大的代码生成引擎，无缝地支持C + +，C#，Java，Python和PHP和Ruby。thrift允许你定义一个描述文件，描述数据类型和服务接口。依据该文件，编译器方便地生成RPC客户端和服务器通信代码。
- 最初由facebook开发用做系统内个语言之间的RPC通信，2007年由facebook贡献到apache基金 ，现在是apache下的opensource之一 。支持多种语言之间的RPC方式的通信：php语言client可以构造一个对象，调用相应的服务方法来调用java语言的服务，跨越语言的C/S RPC调用。底层通讯基于SOCKET。
- 6、服务读写推荐的容错策略是怎样的？
- 读操作建议使用 Failover 失败自动切换，默认重试两次其他服务器。写操作建议使用 Failfast 快速失败，发一次调用失败就立即报错。
- 7、Dubbo 的默认集群容错方案？
- Failover Cluster
- 8、当一个服务接口有多种实现时怎么做？
- 当一个接口有多种实现时，可以用 group 属性来分组，服务提供方和消费方都指定同一个 group 即可。
- 9、服务调用超时问题怎么解决？
- dubbo 在调用服务不成功时，默认是会重试两次的。
- 10、同一个服务多个注册的情况下可以直连某一个服务吗？
- 可以点对点直连，修改配置即可，也可以通过 telnet 直接某个服务。
- 11、Dubbo 用到哪些设计模式？
- 12、Dubbo 和 Spring Cloud 有什么关系？
- 13、dubbo和dubbox之间的区别？
- 14、默认使用什么序列化框架，你知道的还有哪些？
- 15、Dubbo 使用的是什么通信框架?
- 16、说说核心的配置有哪些？
- 17、如何解决服务调用链过长的问题？
- 18、Dubbo 支持服务降级吗？
- 19、RPC使用了哪些关键技术，服务寻址
- 20、服务上线怎么兼容旧版本？
- 21、Dubbo 必须依赖的包有哪些？
- 22、在使用过程中都遇到了些什么问题？ 如何解决的？
- 23、为什么要有RPC
- 24、Dubbo服务之间的调用是阻塞的吗？
- 25、Dubbo 和 Spring Cloud 的区别？
- 26、Dubbo 在安全机制方面是如何解决的
- 27、RPC使用了哪些关键技术，protobuf-rpc-pro
- 28、Dubbo 的整体架构设计有哪些分层?
- 29、服务提供者能实现失效踢出的是什么原理？
- 30、Dubbo 使用过程中都遇到了些什么问题？
- 31、Dubbo 服务器注册与发现的流程？

### 3. Dubbo面试题

- 1、Dubbo 集群容错有几种方案？
- 集群容错方案	说明
- Failover Cluster	失败自动切换，自动重试其它服务器（默认）
- Failfast Cluster	快速失败，立即报错，只发起一次调用
- Failsafe Cluster	失败安全，出现异常时，直接忽略
- Failback Cluster	失败自动恢复，记录失败请求，定时重发
- Forking Cluster	并行调用多个服务器，只要一个成功即返回
- Broadcast Cluster	广播逐个调用所有提供者，任意一个报错则报错
- 2、Dubbo 的注册中心集群挂掉，发布者和订阅者之间还能通信么？
- 可以通讯。启动 Dubbo 时，消费者会从 Zookeeper 拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用。
- 3、Dubbo 能集成 SpringBoot 吗？
- 可以的
- 4、Dubbo 支持哪些协议，每种协议的应用场景，优缺点？
- 1、 dubbo：单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步， Hessian 序列化；
- 2、 rmi：采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现 Serializable 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。多个短连接， TCP 协议传输，同步传输，适用常规的远程服务调用和rmi 互操作。在依赖低版本的 Common-Collections包， java 序列化存在安全漏洞；
- 3、 webservice：基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用；
- 4、 http：基于 Http 表单提交的远程调用协议，使用 Spring 的HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用；
- 5、 hessian：集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务， Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输， Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；
- 6、 memcache：基于 Memcached 实现的 RPC 协议
- 7、 Redis：基于 Redis 实现的 RPC 协议
- 5、Dubbo 和 Spring Cloud 的关系？
- Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。而 Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了 Spirng、Spirng Boot 的优势之上，两个框架在开始目标就不一致， Dubbo定位服务治理、 Spirng Cloud 是一个生态。
- 6、dubbo 推荐用什么协议？
- 默认使用 dubbo 协议。
- 7、Dubbo 核心组件有哪些？
- 1、 Provider：暴露服务的服务提供方
- 2、 Consumer：调用远程服务消费方
- 3、 Registry：服务注册与发现注册中心
- 4、 Monitor：监控中心和访问调用统计
- 5、 Container：服务运行容器
- 8、如何解决服务调用链过长的问题？
- Dubbo 可以使用 Pinpoint 和 Apache Skywalking(Incubator) 实现分布式服务追踪，当然还有其他很多方案。
- 9、Dubbo 使用过程中都遇到了些什么问题？
- 在注册中心找不到对应的服务,检查service实现类是否添加了@service注解
- 无法连接到注册中心,检查配置文件中的对应的测试ip是否正确
- 10、同一个服务多个注册的情况下可以直连某一个服务吗？
- 可以直连，修改配置即可，也可以通过telnet直接某个服务。
- 11、画一画服务注册与发现的流程图？
- 12、Dubbo 有哪些注册中心？
- 13、一般使用什么注册中心？还有别的选择吗？
- 14、Dubbo 的整体架构设计有哪些分层?
- 15、Dubbo 有哪些注册中心？
- 16、服务调用是阻塞的吗？
- 17、Dubbo 和 Dubbox 之间的区别？
- 18、RPC使用了哪些关键技术，序列化和反序列化
- 19、Dubbo 集群的负载均衡有哪些策略
- 20、为什么需要服务治理？
- 21、RPC框架需要解决的问题？
- 22、服务调用是阻塞的吗？
- 23、Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，者和订阅者之间还能通信么？
- 24、你还了解别的分布式框架吗？
- 25、RPC使用了哪些关键技术，Avro
- 26、一般使用什么注册中心？还有别的选择吗？
- 27、Dubbo Monitor 实现原理？
- 28、同一个服务多个注册的情况下可以直连某一个服务吗？
- 29、Dubbo 服务降级，失败重试怎么做？
- 30、在使用过程中都遇到了些什么问题？
- 31、Dubbo 支持哪些序列化方式？

### 4. Dubbo面试题

- 1、Dubbo集群提供了哪些负载均衡策略？
- 1、 Random LoadBalance: 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀。
- 2、 RoundRobin LoadBalance: 轮循选取提供者策略，平均分布，但是存在请求累积的问题。
- 3、 LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收更少的请求。
- 4、 ConstantHash LoadBalance: 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动。
- 默认为 Random 随机调用。
- 2、Dubbo 服务器注册与发现的流程？
- 1、 Provider（提供者）绑定指定端口并启动服务。
- 2、 提供者连接注册中心，并发本机 IP、端口、应用信息和提供服务信息发送至注册中心存储。
- 3、 Consumer（消费者），连接注册中心 ，并发送应用信息、所求服务信息至注册中心。
- 4、 注册中心根据消费者所求服务信息匹配对应的提供者列表发送至 Consumer 应用缓存。
- 5、 Consumer 在发起远程调用时基于缓存的消费者列表择其一发起调用。
- 6、 Provider 状态变更会实时通知注册中心、在由注册中心实时推送至 Consumer。
- 3、同一个服务多个注册的情况下可以直连某一个服务吗？
- 可以直连，修改配置即可，也可以通过 telnet 直接某个服务。
- 4、默认使用什么序列化框架，你知道的还有哪些？
- 默认使用Hessian序列化，还有Duddo、FastJson、Java自带序列化。
- 5、你还了解别的分布式框架吗？
- 别的还有 spring 的 spring cloud，facebook 的 thrift，twitter 的 finagle 等。冲上云霄，Dubbo Go！GO语言版本都发布了～推荐阅读：Spring Cloud是什么，和Dubbo对比呢？
- 6、Dubbo 的使用场景有哪些？
- 1、 透明化的远程方法调用：就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。
- 2、 软负载均衡及容错机制：可在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。
- 3、 服务自动注册与发现：不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。
- 7、Dubbo 的注册中心集群挂掉，者和订阅者之间还能通信么？
- 可以的，启动 dubbo 时，消费者会从 zookeeper 拉取注册的生产者的地址接口等数据，缓存在本地。
- 每次调用时，按照本地存储的地址进行调用。
- 8、同一个服务多个注册的情况下可以直连某一个服务吗？
- 可以点对点直连，修改配置即可，也可以通过telnet直连某个服务。
- 9、默认使用什么序列化框架，你知道的还有哪些？
- 推荐使用Hessian序列化，还有Dubbo、FastJson、Java自带序列化。
- 10、Dubbo 和 Dubbox 之间的区别？
- dubbox 基于 dubbo 上做了一些扩展，如加了服务可 restful 调用，更新了开源组件等。
- 11、RPC使用了哪些关键技术，服务调用
- 12、RPC使用了哪些关键技术，RMI
- 13、RPC使用了哪些关键技术，从服务提供者的角度看：
- 14、服务提供者能实现失效踢出是什么原理？
- 15、RPC使用了哪些关键技术，Hessian
- 16、默认使用的是什么通信框架，还有别的选择吗?
- 17、RPC使用了哪些关键技术，服务注册中心
- 18、Dubbo有哪几种负载均衡策略，默认是哪种？
- 19、RPC使用了哪些关键技术，主流RPC框架有哪些
- 20、一般使用什么注册中心？还有别的选择吗？
- 21、RPC使用了哪些关键技术，RPC的实现原理架构图
- 22、Dubbo的管理控制台能做什么？
- 23、Dubbo 在安全方面有哪些措施？
- 24、Dubbo 支持哪些协议，它们的优缺点有哪些？
- 25、你还了解别的分布式框架吗？
- 26、Dubbo 超时设置有哪些方式？
- 27、dubbo能做什么
- 28、Dubbo 的集群容错方案有哪些？
- 29、默认使用什么序列化框架，你知道的还有哪些？
- 30、Dubbo有哪几种集群容错方案，默认是哪种？

### 5. Dubbo面试题

- 1、你觉得用 Dubbo 好还是 Spring Cloud 好？
- 扩展性的问题，没有好坏，只有适合不适合，不过我好像更倾向于使用 Dubbo, Spring Cloud 版本升级太快，组件更新替换太频繁，配置太繁琐，还有很多我觉得是没有 Dubbo 顺手的地方。
- 2、Dubbo Monitor 实现原理？
- Consumer端在发起调用之前会先走filter链；provider端在接收到请求时也是先走filter链，然后才进行真正的业务逻辑处理。
- 默认情况下，在consumer和provider的filter链中都会有Monitorfilter。
- 1、 MonitorFilter向DubboMonitor发送数据
- 2、 DubboMonitor将数据进行聚合后（默认聚合1min中的统计数据）暂存到ConcurrentMap<Statistics, AtomicReference> statisticsMap，然后使用一个含有3个线程（线程名字：DubboMonitorSendTimer）的线程池每隔1min钟，调用SimpleMonitorService遍历发送statisticsMap中的统计数据，每发送完毕一个，就重置当前的Statistics的AtomicReference
- 3、 SimpleMonitorService将这些聚合数据塞入BlockingQueue queue中（队列大写为100000）
- 4、 SimpleMonitorService使用一个后台线程（线程名为：DubboMonitorAsyncWriteLogThread）将queue中的数据写入文件（该线程以死循环的形式来写）
- 5、 SimpleMonitorService还会使用一个含有1个线程（线程名字：DubboMonitorTimer）的线程池每隔5min钟，将文件中的统计数据画成图表
- 3、RPC使用了哪些关键技术，从调用者的角度看：
- 服务的调用者启动的时候根据自己订阅的服务向服务注册中心查找服务提供者的地址等信息；
- 当服务调用者消费的服务上线或者下线的时候，注册中心会告知该服务的调用者；
- 服务调用者下线的时候，则取消订阅。
- 4、Dubbo 可以对结果进行缓存吗？
- 为了提高数据访问的速度。Dubbo 提供了声明式缓存，以减少用户加缓存的工作量<dubbo:reference cache=“true” />
- 其实比普通的配置文件就多了一个标签 cache=“true”
- 5、Dubbo 用到哪些设计模式？
- Dubbo框架在初始化和通信过程中使用了多种设计模式，可灵活控制类加载、权限控制等功能。
- 工厂模式
- Provider在export服务时，会调用ServiceConfig的export方法。ServiceConfig中有个字段：
- private static final Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();
- Dubbo里有很多这种代码。这也是一种工厂模式，只是实现类的获取采用了JDK SPI的机制。这么实现的优点是可扩展性强，想要扩展实现，只需要在classpath下增加个文件就可以了，代码零侵入。另外，像上面的Adaptive实现，可以做到调用时动态决定调用哪个实现，但是由于这种实现采用了动态代理，会造成代码调试比较麻烦，需要分析出实际调用的实现类。
- 装饰器模式
- Dubbo在启动和调用阶段都大量使用了装饰器模式。以Provider提供的调用链为例，具体的调用链代码是在ProtocolFilterWrapper的buildInvokerChain完成的，具体是将注解中含有group=provider的Filter实现，按照order排序，最后的调用顺序是：
- EchoFilter -> ClassLoaderFilter -> GenericFilter -> ContextFilter -> ExecuteLimitFilter -> TraceFilter -> TimeoutFilter -> MonitorFilter -> ExceptionFilter
- 更确切地说，这里是装饰器和责任链模式的混合使用。例如，EchoFilter的作用是判断是否是回声测试请求，是的话直接返回内容，这是一种责任链的体现。而像ClassLoaderFilter则只是在主功能上添加了功能，更改当前线程的ClassLoader，这是典型的装饰器模式。
- 观察者模式
- Dubbo的Provider启动时，需要与注册中心交互，先注册自己的服务，再订阅自己的服务，订阅时，采用了观察者模式，开启一个listener。注册中心会每5秒定时检查是否有服务更新，如果有更新，向该服务的提供者发送一个notify消息，provider接受到notify消息后，即运行NotifyListener的notify方法，执行监听器方法。
- 动态代理模式
- Dubbo扩展JDK SPI的类ExtensionLoader的Adaptive实现是典型的动态代理实现。Dubbo需要灵活地控制实现类，即在调用阶段动态地根据参数决定调用哪个实现类，所以采用先生成代理类的方法，能够做到灵活的调用。生成代理类的代码是ExtensionLoader的createAdaptiveExtensionClassCode方法。代理类的主要逻辑是，获取URL参数中指定参数的值作为获取实现类的key。
- 6、Dubbo 如何优雅停机？
- Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。
- 7、RPC使用了哪些关键技术，NIO通信
- 出于并发性能的考虑，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 IO，即 NIO。Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持。可以选择Netty或者MINA来解决NIO数据传输的问题。
- 8、在使用过程中都遇到了些什么问题？
- 如序列化问题。
- 9、集群容错怎么做？
- 读操作建议使用 Failover 失败自动切换，默认重试两次其他服务器。写操作建议使用 Failfast 快速失败，发一次调用失败就立即报错。
- 10、Dubbo 超时时间怎样设置？
- Dubbo 超时时间设置有两种方式：
- 服务提供者端设置超时时间，在 Dubbo 的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。
- 服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。
- 11、说说 Dubbo 服务暴露的过程。
- 12、注册了多个同一样的服务，如果测试指定的某一个服务呢？
- 13、Dubbo 服务降级，失败重试怎么做？
- 14、说说核心的配置有哪些？
- 15、RPC使用了哪些关键技术，Dubbo
- 16、服务上线怎么不影响旧版本？
- 17、dubbo推荐用什么协议？
- 18、Dubbo 支持服务降级吗？
- 19、Dubbo的集群容错方案有哪些？
- 20、dubbo 推荐用什么协议？
- 21、Dubbo 的主要应用场景？
- 22、集群容错怎么做？
- 23、Dubbo 支持哪些协议，每种协议的应用场景，优缺点？
- 24、RPC使用了哪些关键技术，建立通信
- 25、RPC使用了哪些关键技术，动态代理
- 26、服务调用超时会怎么样？
- 27、Dubbo支持服务多协议吗？
- 28、dubbo 服务负载均衡策略？
- 29、dubbo 连接注册中心和直连的区别
- 30、Dubbo 配置文件是如何加载到 Spring 中的？

## 第14章 ElasticSearch（150道）

### 1. ElasticSearch面试题

- 1、elasticsearch 读取数据
- 使用RestFul API向对应的node发送查询请求，根据did来判断在哪个shard上，返回的是primary和replica的node节点集合
- 这样会负载均衡地把查询发送到对应节点，之后对应节点接收到请求，将document数据返回协调节点，协调节点把document返回给客户端
- 2、您能解释一下X-Pack for Elasticsearch的功能和重要性吗？
- X-Pack 是与Elasticsearch一起安装的扩展程序。
- X-Pack的各种功能包括安全性（基于角色的访问，特权/权限，角色和用户安全性），监视，报告，警报等。
- 3、Elasticsearch 中的节点（比如共 20 个），其中的 10 个选了一个master，另外 10 个选了另一个 master，怎么办？
- 1、 当集群 master 候选数量不小于 3 个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题；
- 2、 当候选数量为两个时，只能修改为唯一的一个 master 候选，其他作为 data节点，避免脑裂问题。
- 4、解释一下 Elasticsearch集群中的 索引的概念 ？
- Elasticsearch 集群可以包含多个索引，与关系数据库相比，它们相当于数据库表
- 5、你可以列出 Elasticsearch 各种类型的分析器吗？
- Elasticsearch Analyzer 的类型为内置分析器和自定义分析器。
- Standard Analyzer
- 标准分析器是默认分词器，如果未指定，则使用该分词器。
- 它基于Unicode文本分割算法，适用于大多数语言。
- Whitespace Analyzer
- 基于空格字符切词。
- Stop Analyzer
- 在simple Analyzer的基础上，移除停用词。
- Keyword Analyzer
- 不切词，将输入的整个串一起返回。
- 自定义分词器的模板
- 自定义分词器的在Mapping的Setting部分设置：
- PUT my_custom_index
- {
-  "settings":{
-   "analysis":{
-   "char_filter":{},
-   "tokenizer":{},
-   "filter":{},
-   "analyzer":{}
-   }
-  }
- }
- 脑海中还是上面的三部分组成的图示。其中：
- “char_filter”:{},——对应字符过滤部分；
- “tokenizer”:{},——对应文本切分为分词部分；
- “filter”:{},——对应分词后再过滤部分；
- “analyzer”:{}——对应分词器组成部分，其中会包含：1. 2. 3。
- 6、解释一下 Elasticsearch Node？
- 节点是 Elasticsearch 的实例。实际业务中，我们会说：ES集群包含3个节点、7个节点。
- 这里节点实际就是：一个独立的 Elasticsearch 进程，一般将一个节点部署到一台独立的服务器或者虚拟机、容器中。
- 不同节点根据角色不同，可以划分为：
- 主节点
- 帮助配置和管理在整个集群中添加和删除节点。
- 数据节点
- 存储数据并执行诸如CRUD（创建/读取/更新/删除）操作，对数据进行搜索和聚合的操作。
- 1、 客户端节点（或者说：协调节点） 将集群请求转发到主节点，将与数据相关的请求转发到数据节点
- 2、 摄取节点
- 用于在索引之前对文档进行预处理。
- 7、在安装Elasticsearch时，请说明不同的软件包及其重要性？
- 这个貌似没什么好说的，去官方文档下载对应操作系统安装包即可。
- 部分功能是收费的，如机器学习、高级别 kerberos 认证安全等选型要知悉。
- 8、Elasticsearch在部署时，对Linux的设置有哪些优化方法
- 面试官：想了解对ES集群的运维能力。
- 1、 关闭缓存swap;
- 2、 堆内存设置为：Min（节点内存/2, 32GB）;
- 3、 设置最大文件句柄数；
- 4、 线程池+队列大小根据业务需要做调整；
- 5、 磁盘存储raid方式——存储有条件使用RAID10，增加单节点性能以及避免单节点存储故障。
- 9、请解释有关 Elasticsearch的 NRT？
- 从文档索引（写入）到可搜索到之间的延迟默认一秒钟，因此Elasticsearch是近实时（NRT）搜索平台。
- 也就是说：文档写入，最快一秒钟被索引到，不能再快了。
- 写入调优的时候，我们通常会动态调整：refresh_interval = 30s 或者更达值，以使得写入数据更晚一点时间被搜索到。
- 10、elasticsearch 的 document设计
- 在使用es时 避免使用复杂的查询语句（Join 、聚合），就是在建立索引时，
- 就根据查询语句建立好对应的元数据。
- 11、能列出 10 个使用 Elasticsearch 作为其搜索引擎或数据库的公司吗？
- 12、解释一下Elasticsearch Cluster？
- 13、elasticsearch 索引数据多了怎么办，如何调优，部署
- 14、对于GC方面，在使用Elasticsearch时要注意什么？
- 15、是否了解字典树？
- 16、Elasticsearch在部署时，对Linux的设置有哪些优化方法？
- 17、可以列出X-Pack API 吗？
- 18、Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？
- 19、elasticsearch 冷热分离
- 20、介绍下你们电商搜索的整体技术架构
- 21、详细描述一下Elasticsearch搜索的过程？
- 22、如何在 Elasticsearch中 搜索数据？
- 23、Elasticsearch的 文档是什么？
- 24、ElasticSearch中的倒排索引是什么？
- 25、介绍一下你们的个性化搜索方案？
- 26、Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法？

### 2. ElasticSearch面试题

- 1、详细描述一下Elasticsearch搜索的过程？
- 面试官：想了解ES搜索的底层原理，不再只关注业务层面了。
- 搜索拆解为“query then fetch” 两个阶段。
- query阶段的目的：定位到位置，但不取。
- 步骤拆解如下：
- 1、 假设一个索引数据有5主+1副本 共10分片，一次请求会命中（主或者副本分片中）的一个。
- 2、 每个分片在本地进行查询，结果返回到本地有序的优先队列中。
- 3、 第2）步骤的结果发送到协调节点，协调节点产生一个全局的排序列表。
- fetch阶段的目的：取数据。
- 路由节点获取所有文档，返回给客户端。
- 2、Beats 如何与 Elasticsearch 结合使用？
- Beats是一种开源工具，可以将数据直接传输到 Elasticsearch 或通过 logstash，在使用Kibana进行查看之前，可以对数据进行处理或过滤。
- 传输的数据类型包含：审核数据，日志文件，云数据，网络流量和窗口事件日志等。
- 3、解释一下 Elasticsearch 的 分片？
- 当文档数量增加，硬盘容量和处理能力不足时，对客户端请求的响应将延迟。
- 在这种情况下，将索引数据分成小块的过程称为分片，可改善数据搜索结果的获取。
- 4、精准匹配检索和全文检索匹配检索的不同？
- 两者的本质区别：
- 精确匹配用于：是否完全一致？
- 举例：邮编、身份证号的匹配往往是精准匹配。
- 全文检索用于：是否相关？
- 举例：类似B站搜索特定关键词如“马保国 视频”往往是模糊匹配，相关的都返回就可以。
- 5、您能否说明当前可下载的稳定Elasticsearch版本？
- Elasticsearch 当前最新版本是7.10（2020年11月21日）。
- 为什么问这个问题？ES 更新太快了，应聘者如果了解并使用最新版本，基本能说明他关注 ES 更新。甚至从更广维度讲，他关注技术的迭代和更新。
- 但，不信你可以问问，很多求职者只知道用了 ES，什么版本一概不知。
- 6、您能解释一下 Elasticsearch 中的 Explore API 吗？
- 没有用过，这是 Graph （收费功能）相关的API。
- 点到为止即可，类似问题实际开发现用现查，类似问题没有什么意义。
- https://www.elastic.co/guide/en/elasticsearch/reference/current/graph-explore-api.html
- 7、elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些调优手段 。
- 面试官：想了解应聘者之前公司接触的ES使用场景、规模，有没有做过比较大规模的索引设计、规划、调优。
- 如实结合自己的实践场景回答即可。
- 比如：ES集群架构13个节点，索引根据通道不同共20+索引，根据日期，每日递增20+，索引：10分片，每日递增1亿+数据，
- 每个通道每天索引大小控制：150GB之内。
- 仅索引层面调优手段：
- 设计阶段调优
- 1、 根据业务增量需求，采取基于日期模板创建索引，通过roll over API滚动索引；
- 2、 使用别名进行索引管理；
- 3、 每天凌晨定时对索引做force_merge操作，以释放空间；
- 4、 采取冷热分离机制，热数据存储到SSD，提高检索效率；冷数据定期进行shrink操作，以缩减存储；
- 5、 采取curator进行索引的生命周期管理；
- 6、 仅针对需要分词的字段，合理的设置分词器；
- 7、 Mapping阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。……..
- 写入调优
- 1、 写入前副本数设置为0；
- 2、 写入前关闭refresh_interval设置为-1，禁用刷新机制；
- 3、 写入过程中：采取bulk批量写入；
- 4、 写入后恢复副本数和刷新间隔；
- 5、 尽量使用自动生成的id。
- 查询调优
- 1、 禁用wildcard；
- 2、 禁用批量terms（成百上千的场景）；
- 3、 充分利用倒排索引机制，能keyword类型尽量keyword；
- 4、 数据量大时候，可以先基于时间敲定索引再检索；
- 5、 设置合理的路由机制。
- 1.4、其他调优
- 部署调优，业务调优等。
- 上面的提及一部分，面试者就基本对你之前的实践或者运维经验有所评估了。
- 8、能列举过你使用的 X-Pack 命令吗?
- 7.1 安全功能免费后，使用了：setup-passwords 为账号设置密码，确保集群安全。
- 9、elasticsearch 全文检索
- (1) 客户端使用RestFul API向对应的node发送查询请求
- (2)协调节点将请求转发到所有节点（primary或者replica）所有节点将对应的数据查询之后返回对应的doc id 返回给协调节点
- (3)协调节点将doc进行排序聚合
- (4) 协调节点再根据doc id 把查询请求发送到对应shard的node，返回document
- 10、你之前公司的ElasticSearch集群，一个Node一般会分配几个分片？
- 我们遵循官方建议，一个Node最好不要多于三个shards.
- 11、什么是ElasticSearch脑裂？
- 12、你能否列出与 Elasticsearch 有关的主要可用字段数据类型？
- 13、详细描述一下 Elasticsearch 索引文档的过程。
- 14、elasticsearch 分布式架构原理
- 15、logstash 如何与 Elasticsearch 结合使用？
- 16、介绍一下你们的个性化搜索方案？
- 17、您能否列出 与 ELK日志分析相关的应用场景？
- 18、简要介绍一下Elasticsearch？
- 19、Elasticsearch 支持哪些类型的查询？
- 20、elasticsearch 实际设计
- 21、拼写纠错是如何实现的？
- 22、Elasticsearch是如何实现master选举的？
- 23、lucence 内部结构是什么？
- 24、ElasticSearch中的副本是什么？
- 25、Elasticsearch 是如何实现 Master 选举的？
- 26、解释一下 Elasticsearch 集群中的 Type 的概念 ？

### 3. ElasticSearch面试题

- 1、elasticsearch的倒排索引是什么
- 面试官：想了解你对基础概念的认知。
- 通俗解释一下就可以。
- 传统的我们的检索是通过文章，逐个遍历找到对应关键词的位置。
- 而倒排索引，是通过分词策略，形成了词和文章的映射关系表，这种词典+映射表即为倒排索引。
- 有了倒排索引，就能实现o（1）时间复杂度的效率检索文章了，极大的提高了检索效率。
- 学术的解答方式：
- 倒排索引，相反于一篇文章包含了哪些词，它从词出发，记载了这个词在哪些文档中出现过，由两部分组成——词典和倒排表。
- 加分项：倒排索引的底层实现是基于：FST（Finite State Transducer）数据结构。
- lucene从4+版本后开始大量使用的数据结构是FST。FST有两个优点：
- 1、 空间占用小。通过对词典中单词前缀和后缀的重复利用，压缩了存储空间；
- 2、 查询速度快。O(len(str))的查询时间复杂度。
- 2、Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法
- 面试官：想了解对 ES 集群的运维能力。
- 解
- 1、 关闭缓存 swap;
- 2、 堆内存设置为：Min（节点内存/2, 32GB）;
- 3、 设置最大文件句柄数；
- 4、 线程池+队列大小根据业务需要做调整；
- 5、 磁盘存储 raid 方式——存储有条件使用 RAID10，增加单节点性能以及避免单
- 节点存储故障。
- 3、详细描述一下Elasticsearch索引文档的过程
- 面试官：想了解ES的底层原理，不再只关注业务层面了。
- 这里的索引文档应该理解为文档写入ES，创建索引的过程。
- 文档写入包含：单文档写入和批量bulk写入，这里只解释一下：单文档写入流程。
- 记住官方文档中的这个图。
- 第一步：客户写集群某节点写入数据，发送请求。（如果没有指定路由/协调节点，请求的节点扮演路由节点的角色。）
- 第二步：节点1接受到请求后，使用文档_id来确定文档属于分片0。请求会被转到另外的节点，假定节点3。因此分片0的主分片分配到节点3上。
- 第三步：节点3在主分片上执行写操作，如果成功，则将请求并行转发到节点1和节点2的副本分片上，等待结果返回。所有的副本分片都报告成功，节点3将向协调节点（节点1）报告成功，节点1向请求客户端报告写入成功。
- 如果面试官再问：第二步中的文档获取分片的过程？
- 回借助路由算法获取，路由算法就是根据路由和文档id计算目标的分片id的过程。
- 1shard = hash(_routing) % (num_of_primary_shards)
- 4、在并发情况下，Elasticsearch 如果保证读写一致？
- 1、 可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用
- 层来处理具体的冲突；
- 2、 另外对于写操作，一致性级别支持 quorum/one/all，默认为 quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点
- 上重建。
- 3、 对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜索请求参数_preference 为 primary 来查询主分片，确保文档是最新版本。
- 5、请解释在 Elasticsearch 集群中添加或创建索引的过程？
- 要添加新索引，应使用创建索引 API 选项。创建索引所需的参数是索引的配置Settings，索引中的字段 Mapping 以及索引别名 Alias。
- 也可以通过模板 Template 创建索引。
- 6、安装 Elasticsearch 需要依赖什么组件吗？
- ES 早期版本需要JDK，在7.X版本后已经集成了 JDK，已无需第三方依赖。
- 7、如何使用 Elastic Reporting ？
- 收费功能，只是了解，点到为止。
- Reporting API有助于将检索结果生成 PD F格式，图像 PNG 格式以及电子表格 CSV 格式的数据，并可根据需要进行共享或保存。
- 8、elasticsearch 是如何实现 master 选举的
- 面试官：想了解 ES 集群的底层原理，不再只关注业务层面了。
- 解
- 前置前提：
- 1、 只有候选主节点（master：true）的节点才能成为主节点。
- 2、 最小主节点数（min_master_nodes）的目的是防止脑裂。
- 这个我看了各种网上分析的版本和源码分析的书籍，云里雾里。核对了一下代码，核心入口为 findMaster，选择主节点成功返回对应 Master，否则返回 null。
- 选举流程大致描述如下：
- 第一步：确认候选主节点数达标，elasticsearch.yml 设置的值
- discovery.zen.minimum_master_nodes；
- 第二步：比较：先判定是否具备 master 资格，具备候选主节点资格的优先返回；
- 若两节点都为候选主节点，则 id 小的值会主节点。
- 注意这里的 id 为 string 类型。
- 题外话：获取节点 id 的方法。
- 1GET /_cat/nodes?v&h=ip,port,heapPercent,heapMax,id,name
- 2ip
- port heapPercent heapMax id
- name
- 9、在并发情况下，Elasticsearch如果保证读写一致？
- 1、 可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；
- 2、 另外对于写操作，一致性级别支持quorum/one/all，默认为quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。
- 3、 对于读操作，可以设置replication为sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置replication为async时，也可以通过设置搜索请求参数_preference为primary来查询主分片，确保文档是最新版本。
- 10、详细描述一下Elasticsearch更新和删除文档的过程。
- 1、 删除和更新也都是写操作，但是Elasticsearch中的文档是不可变的，因此不能被删除或者改动以展示其变更；
- 2、 磁盘上的每个段都有一个相应的.del文件。当删除请求发送后，文档并没有真的被删除，而是在.del文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del文件中被标记为删除的文档将不会被写入新段。
- 3、 在新的文档被创建时，Elasticsearch会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。
- 11、详细描述一下 Elasticsearch 更新和删除文档的过程。
- 12、在索引中更新 Mapping 的语法？
- 13、在Elasticsearch中 按 ID检索文档的语法是什么？
- 14、在 Elasticsearch 中删除索引的语法是什么？
- 15、详细描述一下Elasticsearch索引文档的过程。
- 16、Elasticsearch中的 Ingest 节点如何工作？
- 17、elasticsearch 索引数据多了怎么办，如何调优，部署
- 18、19、解释 Elasticsearch 中的相关性和得分？
- 19、ElasticSearch如何监控集群状态？
- 20、详细描述一下 Elasticsearch 索引文档的过程。
- 21、详细描述一下 Elasticsearch 搜索的过程？
- 22、定义副本、创建副本的好处是什么？
- 23、客户端在和集群连接时，如何选择特定的节点执行请求的？
- 24、您能否分步介绍如何启动 Elasticsearch 服务器？
- 25、Elasticsearch对于大数据量（上亿量级）的聚合如何实现？
- 26、Elasticsearch 中常用的 cat命令有哪些？

### 4. ElasticSearch面试题

- 1、我们可以在 Elasticsearch 中执行搜索的各种可能方式有哪些？
- 核心方式如下：
- 方式一：基于 DSL 检索（最常用） Elasticsearch提供基于JSON的完整查询DSL来定义查询。
- GET /shirts/_search
- {
-   "query": {
-     "bool": {
-       "filter": [
-         { "term": { "color": "red"   }},
-         { "term": { "brand": "gucci" }}
-       ]
-     }
-   }
- }
- 方式二：基于 URL 检索
- GET /my_index/_search?q=user:seina
- 方式三：类SQL 检索
- POST /_sql?format=txt
- {
-   "query": "SELECT * FROM uint-2020-08-17 ORDER BY itemid DESC LIMIT 5"
- }
- 功能还不完备，不推荐使用。
- 2、ElasticSearch对于大数据量（上亿量级）的聚合如何实现？
- ElasticSearch提供的首个近似聚合是cardinality度量。它提供一个字段的基数，即该字段的distinct或者unique值的数目。它是基于HLL算法的。HLL会先对我们的输入做哈希运算，然后根据哈希运算结果中的bits做概率估算从而得到基数。其特点是：
- 可配置的精度，用来控制内存的使用（更精确＝更多内存），小的数据集精度是非常高的；我们可以通过配置参数来设置去重需要的固定内存使用量，无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关 。
- 图片
- 3、详细描述一下 Elasticsearch 索引文档的过程
- 面试官：想了解 ES 的底层原理，不再只关注业务层面了。
- 解
- 这里的索引文档应该理解为文档写入 ES，创建索引的过程。文档写入包含：单文档写入和批量 bulk 写入，这里只解释一下：单文档写入流程。
- **第一步：**客户写集群某节点写入数据，发送请求。（如果没有指定路由/协调节点，请求的节点扮演路由节点的角色。）
- **第二步：**节点 1 接受到请求后，使用文档_id 来确定文档属于分片 0。请求会被转到另外的节点，假定节点 3。因此分片 0 的主分片分配到节点 3 上。
- **第三步：**节点 3 在主分片上执行写操作，如果成功，则将请求并行转发到节点 1和节点 2 的副本分片上，等待结果返回。所有的副本分片都报告成功，节点 3 将向协调节点（节点 1）报告成功，节点 1 向请求客户端报告写入成功。
- **如果面试官再问：**第二步中的文档获取分片的过程？
- 回借助路由算法获取，路由算法就是根据路由和文档 id 计算目标的分片 id 的
- 过程。
- 1shard = hash(_routing) % (num_of_primary_shards)
- 4、elasticsearch 数据预热
- 数据预热是指，每隔一段时间，将热数据
- 手动在后台查询一遍，将热数据刷新到fileSystem cache上
- 5、如何使用 Elasticsearch Tokenizer？
- Tokenizer 接收字符流（如果包含了字符过滤，则接收过滤后的字符流；否则，接收原始字符流），将其分词。同时记录分词后的顺序或位置(position)，以及开始值（start_offset）和偏移值(end_offset-start_offset)。
- 6、elasticsearch 数据的写入原理
- es数据写入原理主要可以分为4个操作：
- 1、 refresh
- 2、 commit
- 3、 flush
- 4、 merge
- 操作触发条件	操作过程
- refresh	1\、每隔1s进行一次refresh操作
- 2\、buffer已满，则进行一次refresh操作	
- 2\、清空buffer	
- commit	1\、每隔30分钟执行一次translog
- 2\、translog日志已满	
- 2\、生成一个 commit point 文件标识此次操作一件把buffer数据执行到了哪一个segment文件	
- 3\、执行flush操作	
- flush	commit操作中
- merge	后台检查
- 7、你是如何做 ElasticSearch 写入调优的？
- 1）写入前副本数设置为0；
- 2）写入前关闭refresh_interval设置为-1，禁用刷新机制；
- 3）写入过程中：采取bulk批量写入；
- 4） 写入后恢复副本数和刷新间隔；
- 5） 尽量使用自动生成的id。
- 8、Elasticsearch是如何实现Master选举的？
- 1、 Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通）这两部分；
- 2、 对所有可以成为master的节点（node.master: true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。
- 3、 如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。
- 4、 补充：master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http功能*。
- 9、ElasticSearch主分片数量可以在后期更改吗？为什么？
- 不可以，因为根据路由算法shard = hash(document_id) % (num_of_primary_shards)，当主分片数量变化时会影响数据被路由到哪个分片上。
- 10、如何监控 Elasticsearch 集群状态？
- Marvel 让你可以很简单的通过 Kibana 监控 Elasticsearch。你可以实时查看你的集群健康状态和性能，也可以分析过去的集群、索引和节点指标。
- 11、你能否在 Elasticsearch 中定义映射？
- 12、elasticsearch 的倒排索引是什么
- 13、lucence内部结构是什么？
- 14、详细描述一下ElasticSearch更新和删除文档的过程
- 15、在 Elasticsearch 中列出集群的所有索引的语法是什么？
- 16、elasticsearch 的 filesystem
- 17、Elasticsearch Analyzer 中的字符过滤器如何利用？
- 18、详细描述一下Elasticsearch搜索的过程。
- 19、什么是Elasticsearch Analyzer？
- 20、token filter 过滤器 在 Elasticsearch 中如何工作？
- 21、elasticsearch 数据的写入过程
- 22、迁移 Migration API 如何用作 Elasticsearch？
- 23、是否了解字典树？
- 24、详细说明ELK Stack及其内容？
- 25、ElasticSearch中的分析器是什么？

### 5. ElasticSearch面试题

- 1、Kibana在Elasticsearch的哪些地方以及如何使用？
- Kibana是ELK Stack –日志分析解决方案的一部分。
- 它是一种开放源代码的可视化工具，可以以拖拽、自定义图表的方式直观分析数据，极大降低的数据分析的门槛。
- 未来会向类似：商业智能和分析软件 - Tableau 发展。
- 2、elasticsearch是如何实现master选举的
- 面试官：想了解ES集群的底层原理，不再只关注业务层面了。
- 前置前提：
- 1、 只有候选主节点（master：true）的节点才能成为主节点。
- 2、 最小主节点数（min_master_nodes）的目的是防止脑裂。
- 这个我看了各种网上分析的版本和源码分析的书籍，云里雾里。
- 核对了一下代码，核心入口为findMaster，选择主节点成功返回对应Master，否则返回null。选举流程大致描述如下：
- 第一步：确认候选主节点数达标，elasticsearch.yml设置的值discovery.zen.minimum_master_nodes；
- 第二步：比较：先判定是否具备master资格，具备候选主节点资格的优先返回；若两节点都为候选主节点，则id小的值会主节点。注意这里的id为string类型。
- 题外话：获取节点id的方法。
-  1GET /_cat/nodes?v&h=ip,port,heapPercent,heapMax,id,name
- 2ip        port heapPercent heapMax id   name
- 3、客户端在和集群连接时，是如何选择特定的节点执行请求的？
- TransportClient利用transport模块远程连接一个ElasticSearch集群。它并不加入到集群中，只是简单的获得一个或者多个初始化的transport地址，并以轮询的方式与这些地址进行通信。
- 4、你能告诉我 Elasticsearch 中的数据存储功能吗？
- Elasticsearch是一个搜索引擎，输入写入ES的过程就是索引化的过程，数据按照既定的 Mapping 序列化为Json 文档实现存储。
- 5、Master 节点和 候选 Master节点有什么区别？
- 主节点负责集群相关的操作，例如创建或删除索引，跟踪哪些节点是集群的一部分，以及决定将哪些分片分配给哪些节点。
- 拥有稳定的主节点是衡量集群健康的重要标志。
- 而候选主节点是被选具备候选资格，可以被选为主节点的那些节点。
- 6、介绍下你们电商搜索的整体技术架构。
- 7、客户端在和集群连接时，如何选择特定的节点执行请求的？
- TransportClient 利用 transport 模块远程连接一个 elasticsearch 集群。它并不加入到集群中，只是简单的获得一个或者多个初始化的 transport 地址，并以 轮询 的方式与这些地址进行通信。
- 8、对于 GC 方面，在使用 Elasticsearch 时要注意什么？
- 1、 SEE
- 2、 倒排词典的索引需要常驻内存，无法 GC，需要监控 data node 上 segmentmemory 增长趋势。
- 3、 各类缓存，field cache, filter cache, indexing cache, bulk queue 等等，要设置合理的大小，并且要应该根据最坏的情况来看 heap 是否够用，也就是各类缓存全部占满的时候，还有 heap 空间可以分配给其他任务吗？避免采用 clear cache等“自欺欺人”的方式来释放内存。
- 4、 避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用scan & scroll api 来实现。
- 5、 cluster stats 驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集群通过 tribe node 连接。
- 6、 想知道 heap 够不够，必须结合实际应用场景，并对集群的 heap 使用情况做持续的监控。
- 9、拼写纠错是如何实现的？
- 1、拼写纠错是基于编辑距离来实现；编辑距离是一种标准的方法，它用来表示经过插入、删除和替换操作从一个字符串转换到另外一个字符串的最小操作步数；
- **2、编辑距离的计算过程：**比如要计算 batyu 和 beauty 的编辑距离，先创建一个7×8 的表（batyu 长度为 5，coffee 长度为 6，各加 2），接着，在如下位置填入
- 黑色数字。
- 其他格的计算过程是取以下三个值的最小值：
- 如果最上方的字符等于最左方的字符，则为左上方的数字。否则为左上方的数字 +1。（对于 3,3 来说为 0）左方数字+1（对于 3,3 格来说为 2）上方数字+1（对于 3,3 格来说为 2）
- 最终取右下角的值即为编辑距离的值 3。
- ![70_10.png][70_10.png]
- 对于拼写纠错，我们考虑构造一个度量空间（Metric Space），该空间内任何关
- 系满足以下三条基本条件：
- d(x,y) = 0 -- 假如 x 与 y 的距离为 0，则 x=y
- d(x,y) = d(y,x) -- x 到 y 的距离等同于 y 到 x 的距离
- d(x,y) + d(y,z) >= d(x,z) -- 三角不等式
- 1、 根据三角不等式，则满足与 query 距离在 n 范围内的另一个字符转 B，其与 A的距离最大为 d+n，最小为 d-n。
- 2、 BK 树的构造就过程如下：每个节点有任意个子节点，每条边有个值表示编辑距离。所有子节点到父节点的边上标注 n 表示编辑距离恰好为 n。比如，我们有棵树父节点是”book”和两个子
- 点”cake”和”books”，”book”到”books”的边标号 ：
- 1、 ”book”到”cake”的边上标号.
- 2、 从字典里构造好树后，无论何时你想插入新单词时.计算该单词与根节点的编辑距离，并且查找数值为 d(neweord, root)的边。递归得与各子节点进行比较，直到没有子节点，你就可以创建新的子节点并将新单词保存在那。比如，插入”boo”到刚才上述例子的树中，我们先检查根节点，查找 d(“book”, “boo”) = 1 的边，然后检查标号为1 的边的子节点，得到单词”books”。我们再计算距离 d(“books”, “boo”)=2，则将新单词插在”books”之后，边标号为 2。
- 3、 查询相似词如下：计算单词与根节点的编辑距离 d，然后递归查找每个子节点标号为 d-n 到 d+n（包含）的边。假如被检查的节点与搜索单词的距离 d 小于n，则返回该节点并继续查询。比如输入 cape 且最大容忍距离为 1，则先计算和根的编辑距离 d(“book”,“cape”)=4，然后接着找和根节点之间编辑距离为 3 到5 的，这个就找到了cake 这个节点，计算 d(“cake”, “cape”)=1，满足条件所以返回 cake，然后再找和 cake 节点编辑距离是 0 到 2 的，分别找到 cape 和cart 节点，这样就得到 cape 这个满足条件的结果。
- 10、在Elasticsearch中 cat API的功能是什么？
- cat API 命令提供了Elasticsearch 集群的分析、概述和运行状况，其中包括与别名，分配，索引，节点属性等有关的信息。
- 这些 cat 命令使用查询字符串作为其参数，并以J SON 文档格式返回结果信息。
- 11、在 Elasticsearch 中，是怎么根据一个词找到对应的倒排索引的？
- 12、ES更新数据的执行流程？
- 13、ElasticSearch是如何实现Master选举的？
- 14、ES在生产集群的部署架构是什么，每个索引有多大的数据量，每个索引有多少分片
- 15、elasticsearch 了解多少，说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段 。
- 16、REST API在 Elasticsearch 方面有哪些优势？
- 17、请解释一下 Elasticsearch 中聚合？
- 18、什么是ElasticSearch索引？
- 19、ElasticSearch如何避免脑裂？
- 20、Elasticsearch 支持哪些配置管理工具？
- 21、详细描述一下 Elasticsearch 搜索的过程。
- 22、Elasticsearch中的节点（比如共20个），其中的10个选了一个master，另外10个选了另一个master，怎么办？
- 23、Elasticsearch中的属性 enabled, index 和 store 的功能是什么？
- 24、Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？
- 25、如何监控Elasticsearch集群状态？

## 第15章 大数据（150道）

### 1. 大数据面试题

- 1、请用java实现非递归二分查询
- 2、是客户端还是Namenode决定输入的分片？
- 这并不是客户端决定的，在配置文件中以及决定分片细则。
- 3、mapred.job.tracker命令的作用？
- 可以让你知道哪个节点是Job Tracker。
- 4、全分布模式又有什么注意点？
- 全分布模式通常被用于生产环境，这里我们使用N台主机组成一个Hadoop集群，Hadoop守护进程运行在每台主机之上。这里会存在Namenode运行的主机，Datanode运行的主机，以及task tracker运行的主机。在分布式环境下，主节点和从节点会分开。
- 5、hive 跟hbase的区别
- 共同点都是用hadoop作为底层存储
- 区别：hive是为了减少mrjobs编写工作的批处理系统，处理速度慢。hive本身不存储数据和计算数据，依赖于hadoop，纯逻辑表
- hbase是为了hadoop对实时操作的缺陷的项目，处理速度快，是物理表，提供一个超大的内存hash表，方便查询操作
- 如果全表扫描用 hive+hadoop
- 如果用索引查询与hbase+hadoop
- 是处理数据库文件还是读取文本文件
- 先读取文本文件进行清洗，然后放入hdfs，进行处理
- 或者直接读取MySQL中格式化数据
- 6、请列出正常工作的hadoop集群中hadoop都需要启动哪些进程，他们的作用分别是什么？
- NameNode: HDFS的守护进程，负责记录文件是如何分割成数据块，以及这些数据块分别被存储到那些数据节点上，它的主要功能是对内存及IO进行集中管理
- Secondary NameNode：辅助后台程序，与NameNode进行通信，以便定期保存HDFS元数据的快照。
- DataNode：负责把HDFS数据块读写到本地的文件系统。
- JobTracker：负责分配task，并监控所有运行的task。
- TaskTracker：负责执行具体的task，并与JobTracker进行交互。
- 7、KafkaUtils.createDstream 和 KafkaUtils.createDirectstream 区别
- 使用一个 receiver 接收器接收数据，接收到的数据将会保存到executor中，然后通过sparkStreaming 启动job来处理数据，默认不会丢失，可启动WAL日志，保存到hdfs上
- spark.streaming.recever.writeAheadLog.enable=true 同时开启 StorageLevel.MeMORY_AND_DISK_SER_2
- KafkaUtils.createDirectstream方式，他定期从Kafka的分区中查询偏移量，再根据偏移量范围在每个batch里面处理数据
- 优点：简化并行 高效 恰好一次被消费
- hbase
- 8、Kafka与传统消息队列的区别
- RabbitMQ吞吐量稍差Kafka，支持对消息可靠的传递，支持事务，不支持批量的操作，存储于内存或者磁盘
- Kafka遵从一般的MQ结构，producer，broker，consumer，以consumer为中心，消费的消费信息保存在客户端consumer上，consumer根据消费的点，从broker批量pull数据；无消息确认机制
- Kafka具有搞得吞吐量，内部采用消息的批量处理，数据的存储和获取是本地磁盘顺序批量操作，消息处理的效率高
- Kafka 的broker支持主备模式
- Kafka 负载均衡 Zookeeper方向
- Kafka采用Zookeeper进行管理，可以注册topic到Zookeeper上，通过zoo的协调机制，生产者保存对应topic的broker消息，可以随机或者轮询发送到broker上；并且生产者可以基于予以定义指定分片，消息发送到broker的某分片上
- 9、Master文件是否提供了多个入口？
- 是的你可以拥有多个Master文件接口。
- 10、Spark的数据本地性有哪几种？
- Spark中的数据本地性有三种：
- 1、 PROCESS_LOCAL是指读取缓存在本地节点的数据
- 2、 NODE_LOCAL是指读取本地节点硬盘数据
- 3、 ANY是指读取非本地节点数据
- 通常读取数据PROCESS_LOCAL>NODE_LOCAL>ANY，尽量使数据以PROCESS_LOCAL或NODE_LOCAL方式读取。其中PROCESS_LOCAL还和cache有关，如果RDD经常用的话将该RDD cache到内存中，注意，由于cache是lazy的，所以必须通过一个action的触发，才能真正的将该RDD cache到内存中。
- 11、Spark的shuffle过程？
- 12、fsimage和edit的区别？
- 13、List与set的区别
- 14、海量日志数据，提取出某日访问百度次数最多的那个IP。
- 15、storm特点
- 16、Hbase宕机如何处理
- 17、Hbase行键列族的概念，物理模型，表的设计原则？
- 18、Spark为什么要持久化，一般什么场景下要进行persist操作？
- 19、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。
- 20、SSH中的注意点还包括？
- 21、存储特点
- 22、请简述hadoop怎样实现二级排序（就是对key和value双排序）
- 23、现场出问题测试mapreduce掌握情况和hive的ql语言掌握情况
- 24、hadoop数据倾斜及解决办法
- 25、HDFS读取文件的步骤
- 26、sqoop在导入到MySQL中，如果不重复导入数据，如果数据存在问题，sqoop如何处理？
- 27、什么是udf
- 28、hadoop的TextInputFormat作用是什么，如何自定义实现？
- 29、hbase内部机制是什么
- 30、如何退出输入模式？
- 31、简述hadoop spark storm hive的特点及使用场景
- 32、combine出现在哪个过程

### 2. 大数据面试题

- 1、datanode在什么情况下不会备份
- 强制关闭或非正常断电时
- 2、请列出你所知道的hadoop调度器，并简要说明其工作方法？
- 比较流行的三种调度器有：默认调度器FIFO，计算能力调度器CapacityScheduler，公平调度器Fair Scheduler
- 默认调度器FIFO
- hadoop中默认的调度器，采用先进先出的原则
- 计算能力调度器CapacityScheduler
- 选择占用资源小，优先级高的先执行
- 公平调度器FairScheduler
- 同一队列中的作业公平共享队列中所有资源
- 3、Hadoop安装在什么目录下？
- Cloudera和Apache使用相同的目录结构，Hadoop被安装在cdusrlibhadoop-0.20。
- 4、当你输入hadoopfsck 造成“connection refused java exception’”时，系统究竟发生了什么？
- 这意味着Namenode没有运行在你的VM之上。
- 5、spark调优
- 1、 避免创建重复RDD
- 2、 尽可能复用同一个RDD
- 3、 对多次使用的RDD进行持久化
- 4、 避免使用shuffle算子
- 5、 使用map-side预聚合shuffle操作
- 6、 使用高性能的算子
- 7、 广播大变量
- 8、 使用Kryo序列化
- 9、 优化数据结构
- 6、RAM的溢出因子是？
- 溢出因子（Spill factor）是临时文件中储存文件的大小，也就是Hadoop-temp目录。
- 7、hive sql知识点
- DML 数据操纵语言
- DDL 数据定义语言，用语定义和管理数据库中的对象
- 8、为什么hive的分区
- 为了避免select扫描全表，hive提出了分区表partitionedby的概念，给文件归类打上表示
- 静态分区：
- 单分区建表
- create table par_tab(name string,nation string) partitioned by (sex string) row format delimited fields terminated by ‘,’;
- 加载：load data local inpath ‘/hdfs/…’ into table par_tab partition(sex=‘man’)
- 在创建分区表的时候，系统会在hive数据仓库默认路径/user/hive/warehouse/创建目录，在创建sex=man的目录，最后在分区名下存放实际的数据文件
- 多分区建表
- create table par_tab(name string,nation string) partitioned by (sex string,dt string) row format delimited fields terminated by ',';
- load data local inpath '/hdfs/...' into table par_tab partition(sex='man',dt="2019-08-08")
- 当我们查询所有的man时候，man一下的所有日期下的数据都会被查出来；如果只查询日期分区，那么hive会对路径进行修剪，从而只扫描日期分区，性别分区不做过滤
- 动态分区
- 动态分区与静态分区区别就是不指定分区目录，有系统自己选择
- 开启动态分区 set hive.exec.dynamic.partition=true
- 9、当前日志采样格式为
- a , b , c , d
- b , b , f , e
- a , a , c , f
- 10、Namenode、Job tracker和task tracker的端口号是？
- Namenode，70；Job tracker，30；Task tracker，60。
- 11、为什么要用flume导入hdfs，hdfs的构架是怎样的
- 12、Redis，传统数据库，hbase，hive每个之间的区别
- 13、Kafka 各组件介绍
- 14、etc init.d命令的作用是？
- 15、Hive生产环境中为什么建议使用外部表？
- 16、简要描述如何安装配置apache的一个开源hadoop，只描述即可，无需列出具体步骤，列出具体步骤更好。
- 17、给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？
- 18、fs.mapr.working.dir只是单一的目录？
- 19、Slaves由什么组成？
- 20、“jps”命令的用处？
- 21、数据本地性是在哪个环节确定的？
- 22、MapReduce如何优化
- 23、HBase写数据的原理是什么？
- 24、如何确认hadoop集群的健康状况
- 25、是否可以在Windows上运行Hadoop？
- 26、启动和关闭命令会用到哪些文件？
- 27、HDFS存储机制
- 28、hadoop和spark都是并行计算，那么他们有什么相同和区别？
- 29、MapReduce的map数量和reduce数量怎么确定，怎么配置
- 30、如何在浏览器中查找Namenode？
- 31、我们在开发分布式计算job的时候，是否可以去掉reduce阶段
- 32、hive底层与数据库交互原理

### 3. 大数据面试题

- 1、过滤器有什么用途：
- 增强hbase查询数据的功能
- 减少服务端返回给客户端的数据量
- reduce之后数据的输出量有多大（结合具体场景，比如pi）
- Sca阶段的增强日志（1.5T—2T）
- 过滤性质的mr程序，输出比输入少
- 解析性质的mr程序，输出比输入多（找共同朋友）
- 2、RDD缓存
- rdd.cache
- rdd.persist
- 3、什么是spark
- 基于内存计算发数据分析引擎，提高在大数据环境下数处理的实时性，spark仅涉及数据计算
- 4、假如Namenode中没有数据会怎么样？
- 没有数据的Namenode就不能称之为Namenode，通常情况下，Namenode肯定会有数据。
- 5、假如一个分区的数据逐步错误怎么通过hivesql删除
- alter table ptable drop partition(daytime=‘20140921’,city=‘bj’);全部删除，文件夹还在
- 6、storm怎么保障消息不丢失
- nimbus 告诉 Zookeeper 调度接收数据 ，spout接收数据 ack响应，其他节点进程 在spout消费拉去数据，每个tuple发送个bolt进行处理，如果成功处理则发送ack消息给zookeeper，发送消息 tuple消费失败则标记为fail，Zookeeper根据偏移量从新发送数据直到消费为止
- Kafka
- 7、解释下hbase实时查询原理
- 实时查询，可疑人物是从内存中查询，一般响应为1秒内。
- Hbase机制是数据先写入到内存中，当数据达到一定量，再写入磁盘中，在内存中不进行数据的更新和合并操作，值增加数据，使得用户的写操作值进入内存中可以立即返回，保证了Hasee的高性能
- 8、RDD 是什么
- 弹性分布式数据集，是spark中最基本的数据抽象，可以存于内存中或者磁盘中，分布式存储可用于分布式计算
- 一个不可变，可分区，里面的数据可并行计算的集合
- 9、描述Hbase的rowkey的设计原则
- 1、 rowkey长度原则：设计为定长，如果rowkey过长，内存使用率降低，会降低检索效率
- 2、 rowkey散列原则：将rowkey的高位作为散列字段，有程序随机生成，这样将提高数据均衡分布在每个RegionServer上，以实现负载均衡。
- 如果没有散列字段，所有数据就会集中在一个RegionServer上，数据检索时负载会集中在个别RegionServer上，造成热点问题，降低效率
- 3、 rowkey唯一原则：必须在设计上保证唯一性，rowkey是按照字段顺序排序存储的，设计rowkey时，充分利用排序这个特点，将经常读取的数据存在一块，可能被访问的数据放在一起
- 10、Sqoop工作原理是什么？
- hadoop生态圈上的数据传输工具。
- 可以将关系型数据库的数据导入非结构化的hdfs、hive或者bbase中，也可以将hdfs中的数据导出到关系型数据库或者文本文件中。
- 使用的是mr程序来执行任务，使用jdbc和关系型数据库进行交互。
- import原理：通过指定的分隔符进行数据切分，将分片传入各个map中，在map任务中在每行数据进行写入处理没有reduce。
- export原理：根据要操作的表名生成一个java类，并读取其元数据信息和分隔符对非结构化的数据进行匹配，多个map作业同时执行写入关系型数据库
- 11、hive数仓开发的基本流程
- 12、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。
- 13、VM是否可以称为Pseudo？
- 14、map-reduce程序运行的时候会有什么比较常见的问题
- 15、数据的三范式
- 16、hive底层与数据库交互原理
- 17、为什么要用flume导入hdfs，hdfs的架构是怎样的？
- 18、请列出你在工作中使用过的开发mapreduce的语言
- 19、单机（本地）模式中的注意点？
- 20、请说明hive中Sort By、Order By、Cluster By，Distribute By各代表什么意思？
- 21、生产环境为什么建议使用外部表
- 22、3个datanode中有一个datanode出现错误会怎样？
- 23、简单说一下hadoop的map-reduce模型
- 24、Hive与关系型数据库的关系？
- 25、我们开发Job是否能去掉reduce阶段
- 26、请你用最熟悉的语言编写mapreduce，计算第四列每个元素出现的个数
- 27、MapReduce运行原理
- 28、假设公司要建一个数据中心，你会如何处理？
- 29、hadoop中常用的数据压缩算法
- 30、伪分布模式中的注意点？
- 31、RDD的弹性表现在哪几点？
- 32、Hive中存放是什么？

### 4. 大数据面试题

- 1、过滤器有什么用途：
- 增强hbase查询数据的功能
- 减少服务端返回给客户端的数据量
- reduce之后数据的输出量有多大（结合具体场景，比如pi）
- Sca阶段的增强日志（1.5T—2T）
- 过滤性质的mr程序，输出比输入少
- 解析性质的mr程序，输出比输入多（找共同朋友）
- 2、RDD缓存
- rdd.cache
- rdd.persist
- 3、什么是spark
- 基于内存计算发数据分析引擎，提高在大数据环境下数处理的实时性，spark仅涉及数据计算
- 4、假如Namenode中没有数据会怎么样？
- 没有数据的Namenode就不能称之为Namenode，通常情况下，Namenode肯定会有数据。
- 5、假如一个分区的数据逐步错误怎么通过hivesql删除
- alter table ptable drop partition(daytime=‘20140921’,city=‘bj’);全部删除，文件夹还在
- 6、storm怎么保障消息不丢失
- nimbus 告诉 Zookeeper 调度接收数据 ，spout接收数据 ack响应，其他节点进程 在spout消费拉去数据，每个tuple发送个bolt进行处理，如果成功处理则发送ack消息给zookeeper，发送消息 tuple消费失败则标记为fail，Zookeeper根据偏移量从新发送数据直到消费为止
- Kafka
- 7、解释下hbase实时查询原理
- 实时查询，可疑人物是从内存中查询，一般响应为1秒内。
- Hbase机制是数据先写入到内存中，当数据达到一定量，再写入磁盘中，在内存中不进行数据的更新和合并操作，值增加数据，使得用户的写操作值进入内存中可以立即返回，保证了Hasee的高性能
- 8、RDD 是什么
- 弹性分布式数据集，是spark中最基本的数据抽象，可以存于内存中或者磁盘中，分布式存储可用于分布式计算
- 一个不可变，可分区，里面的数据可并行计算的集合
- 9、描述Hbase的rowkey的设计原则
- 1、 rowkey长度原则：设计为定长，如果rowkey过长，内存使用率降低，会降低检索效率
- 2、 rowkey散列原则：将rowkey的高位作为散列字段，有程序随机生成，这样将提高数据均衡分布在每个RegionServer上，以实现负载均衡。
- 如果没有散列字段，所有数据就会集中在一个RegionServer上，数据检索时负载会集中在个别RegionServer上，造成热点问题，降低效率
- 3、 rowkey唯一原则：必须在设计上保证唯一性，rowkey是按照字段顺序排序存储的，设计rowkey时，充分利用排序这个特点，将经常读取的数据存在一块，可能被访问的数据放在一起
- 10、Sqoop工作原理是什么？
- hadoop生态圈上的数据传输工具。
- 可以将关系型数据库的数据导入非结构化的hdfs、hive或者bbase中，也可以将hdfs中的数据导出到关系型数据库或者文本文件中。
- 使用的是mr程序来执行任务，使用jdbc和关系型数据库进行交互。
- import原理：通过指定的分隔符进行数据切分，将分片传入各个map中，在map任务中在每行数据进行写入处理没有reduce。
- export原理：根据要操作的表名生成一个java类，并读取其元数据信息和分隔符对非结构化的数据进行匹配，多个map作业同时执行写入关系型数据库
- 11、hive数仓开发的基本流程
- 12、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。
- 13、VM是否可以称为Pseudo？
- 14、map-reduce程序运行的时候会有什么比较常见的问题
- 15、数据的三范式
- 16、hive底层与数据库交互原理
- 17、为什么要用flume导入hdfs，hdfs的架构是怎样的？
- 18、请列出你在工作中使用过的开发mapreduce的语言
- 19、单机（本地）模式中的注意点？
- 20、请说明hive中Sort By、Order By、Cluster By，Distribute By各代表什么意思？
- 21、生产环境为什么建议使用外部表
- 22、3个datanode中有一个datanode出现错误会怎样？
- 23、简单说一下hadoop的map-reduce模型
- 24、Hive与关系型数据库的关系？
- 25、我们开发Job是否能去掉reduce阶段
- 26、请你用最熟悉的语言编写mapreduce，计算第四列每个元素出现的个数
- 27、MapReduce运行原理
- 28、假设公司要建一个数据中心，你会如何处理？
- 29、hadoop中常用的数据压缩算法
- 30、伪分布模式中的注意点？
- 31、RDD的弹性表现在哪几点？
- 32、Hive中存放是什么？

### 5. 大数据面试题

- 1、谈谈Zookeeper理解
- Zookeeper 作为一个分布式的服务框架，主要用来解决分布式集群中应用系统的一致性问题( 解决单点故障问题 )。
- Zookeeper 并不是用来专门存储数据的，它的作用主要是用来维护和监控你存储的数据的状态变化，通过监控这些数据状态的变化，从而可以达到基于数据的集群管理
- 总结: Zookeeper=文件系统+通知机制
- spark
- 2、请列举出曾经修改过的/etc/下面的文件，并说明修改要解决什么问题？
- /etc/profile这个文件，主要是用来配置环境变量。让hadoop命令可以在任意目录下面执行。
- /ect/sudoers
- /etc/hosts
- /etc/sysconfig/network
- /etc/inittab
- 3、宕机分为HMaster宕机和HRegisoner宕机，如果是HRegisoner宕机，HMaster会将其所管理的region重新分布到其他活动的RegionServer上，由于数据和日志都持久在HDFS中，该操作不会导致数据丢失。所以数据的一致性和安全性是有保障的。
- 如果是HMaster宕机，HMaster没有单点问题，HBase中可以启动多个HMaster，通过Zookeeper的Master Election机制保证总有一个Master运行。即ZooKeeper会保证总会有一个HMaster在对外提供服务。
- 4、offset是每天消息的偏移量
- 每个日志文件都有一个offset来唯一标记一条信息，由8个自己数字表示，表示此消息在分区中所处的起始位置
- 每个分区再物理存储层面，由多个logfile组成（segment）
- 最小的offset表示segment中起始消息的offset
- 5、hbase中表的特点
- 大：上亿行，上百万列
- 无模式：每行都有一个可排序的主键和任意多的列，列可以根据需要动态增加，同一张表中不同的行可以有截然不同的列
- 面向列的存储和权限控制，列族独立索引
- 对于为null的列，并不占用存储空间，因此表可以设置的非常稀疏
- 数据多版本：可以有多个版本，系统自动分配，时间戳为版本号
- 数据类型单一：只有字节数组 byte[]
- 129.hbase 表逻辑结构
- 表有 行 和 列组成，列划分为若干个列族cloumn
- 表明 test
- rowkey 列族1：base_info 列族2：xxx_info
- 0001 name:zhangsan age:20 address:bj
- 0002 name:lishi age:50 sex:male address:shanghai hoppies:sing
- rowkey:hbase的行索引，按照rowkey字典顺序排序
- cell可以锁定一个值：Rowkey+列族+列族下的列的名字+值+时间戳
- 6、请写出以下的shell命令
- 1、 杀死一个job
- 2、 删除hdfs上的 /tmp/aaa目录
- 3、 加入一个新的存储节点和删除一个节点需要执行的命令
- 4、 hadoop job –list 得到job的id，然后执 行 hadoop job -kill jobId就可以杀死一个指定jobId的job工作了。
- 5、 hadoopfs -rmr /tmp/aaa
- 6、 增加一个新的节点在新的几点上执行
- Hadoop  daemon.sh start  datanode
- Hadooop daemon.sh  start  tasktracker/nodemanager
- 下线时，要在conf目录下的excludes文件中列出要下线的datanode机器主机名
- 然后在主节点中执行  hadoop  dfsadmin  -refreshnodes  à下线一个datanode
- 删除一个节点的时候，只需要在主节点执行
- hadoop mradmin -refreshnodes —下线一个tasktracker/nodemanager
- 7、简答说一下hadoop的map-reduce编程模型
- 首先map task会从本地文件系统读取数据，转换成key-value形式的键值对集合
- 使用的是hadoop内置的数据类型，比如longwritable、text等
- 将键值对集合输入mapper进行业务处理过程，将其转换成需要的key-value在输出
- 之后会进行一个partition分区操作，默认使用的是hashpartitioner，可以通过重写hashpartitioner的getpartition方法来自定义分区规则
- 之后会对key进行进行sort排序，grouping分组操作将相同key的value合并分组输出，在这里可以使用自定义的数据类型，重写WritableComparator的Comparator方法来自定义排序规则，重写RawComparator的compara方法来自定义分组规则
- 之后进行一个combiner归约操作，其实就是一个本地段的reduce预处理，以减小后面shufle和reducer的工作量
- reduce task会通过网络将各个数据收集进行reduce处理，最后将数据保存或者显示，结束整个job
- 8、MR程序运行的时候会有什么比较常见的问题？
- 比如说作业中大部分都完成了，但是总有几个reduce一直在运行。
- 这是因为这几个reduce中的处理的数据要远远大于其他的reduce，可能是对键值对任务划分的不均匀造成的数据倾斜。
- 解决的方法可以在分区的时候重新定义分区规则对于value数据很多的key可以进行拆分、均匀打散等处理，或者是在map端的combiner中进行数据预处理的操作。
- 9、hive能像关系型数据库那样建多个库吗？
- 当然能了。
- 10、请列出你所知道的hadoop调度器，并简要说明其工作方法
- Fifo schedular :默认，先进先出的原则
- Capacity schedular :计算能力调度器，选择占用最小、优先级高的先执行，依此类推。
- Fair schedular:公平调度，所有的 job 具有相同的资源。
- 11、请描述如何解决Hbase中region太小和region太大带来的结果。
- 12、hive如何优化
- 13、怎么设置RDD cache
- 14、你们数据库如何导入hive的出现什么错误
- 15、hadoop 的 namenode 宕机怎么解决
- 16、shuffle阶段你怎么理解
- 17、数据导入hive的方式
- 18、如何从SU转到Cloudera？
- 19、数据库 OLAP OLTP的介绍和比较
- 20、hive与传统DB的区别
- 21、搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。
- 22、为什么SSH本地主机需要密码？
- 23、全分布式环境下为什么需求password-less SSH？
- 24、为什么会出现hadoop
- 25、运行hadoop集群需要哪些守护进程？
- 26、HBase简单读写流程？
- 27、hive是什么
- 28、怎么样才能实现去掉reduce阶段
- 29、使用zk来连接集群
- 30、上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。
- 31、hive中存放的是什么？
- 32、举一个例子说明mapreduce是怎么运行的。

*XMind - Trial Version*