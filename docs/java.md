# JAVA高级面试题

## 第1章 JAVA相关面试题

### 1. JAVA面试题1

- 1、创建socket通讯的步骤？

- 1、 服务器程序创建一个ServerSocket，然后再用accept方法等待客户来连接
- 2、 客户端程序创建一个Socket并请求与服务器建立连接
- 3、 服务器接收客户的连接请求,并创建一个新的Socket与该客户建立专线连接
- 4、 刚才建立了连接的两个Socket在一个线程上对话
- 5、 服务器开始等待新的连接请求

- 2、Java 中 sleep 方法和 wait 方法的区别？

- 虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。

- 3、程序计数器(线程私有)

- 一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有” 的内存。
- 正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址） 。如果还是 Native 方法，则为空。
- 这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。

- 4、什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？

- 线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。

- 5、迭代器 Iterator 是什么？

- Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。
- 因为所有Collection接继承了Iterator迭代器

- 6、线程的 sleep()方法和 yield()方法有什么区别？

- 1、 sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
- 2、 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；
- 3、 sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；
- 4、 sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。

- 7、Java 中能创建 volatile 数组吗？

- 能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。

- 8、java中equals方法的用法以及==的用法
- 9、如何创建一个json对象？

- 使用{}实例化一个json对象，json对象多个元素使用逗号隔开，每个元素都是一个键值对

- 10、如何判断对象是否是垃圾？

- **引用计数：**在对象中添加一个引用计数器，如果被引用计数器加 1，引用失效时计数器减 1，如果计数器为 0 则被标记为垃圾。原理简单，效率高，但是在 Java 中很少使用，因为存在对象间循环引用的问题，导致计数器无法清零。
- **可达性分析：**主流语言的内存管理都使用可达性分析判断对象是否存活。基本思路是通过一系列称为 GC Roots 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为引用链，如果某个对象到 GC Roots 没有任何引用链相连，则会被标记为垃圾。可作为 GC Roots 的对象包括虚拟机栈和本地方法栈中引用的对象、类静态属性引用的对象、常量引用的对象。

- 11、GC是什么？为什么要有GC？
- 12、线程池四种创建方式？
- 13、形成死锁的四个必要条件是什么
- 14、java 面向对象编程三大特性------封装、继承、多态
- 15、什么是IoC和DI？DI是如何实现的？
- 16、假设数组内有5个元素，如果对数组进行反序，该如何做？
- 17、Java的内存模型是什么？（JMM是什么？）
- 18、什么时候用断言（assert）？
- 19、对象在哪块内存分配？
- 20、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？
- 21、怎么将 byte 转换为 String？
- 22、Swing 是线程安全的？
- 23、线程B怎么知道线程A修改了变量
- 24、notify() 和 notifyAll() 有什么区别？
- 25、Java 中的 LinkedList 是单向链表还是双向链表？
- 26、Java中垃圾回收有什么目的？什么时候进行垃圾回收？
- 27、你对线程优先级的理解是什么？
- 28、JVM内存模型
- 29、解释servlet如何完成生命周期?
- 30、Java中是如何支持正则表达式操作的？
- 31、接口有什么特点？
- 32、什么是过滤器？怎么创建一个过滤器
- 33、在 Java 程序中怎么保证多线程的运行安全？
- 34、直接内存是什么？
- 35、Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型
- 36、解释何时在Tomcat使用SSL ?
- 37、堆（Heap-线程共享） -运行时数据区
- 38、SWAP会影响性能么？
- 39、什么是方法内联？
- 40、谈一谈Hibernate的一级缓存、二级缓存和查询缓存。

### 2. JAVA面试题2

- 1、抽象工厂模式和原型模式之间的区别？

- 抽象工厂模式：通常由工厂方法模式来实现。但一个工厂中往往含有多个工厂方法生成一系列的产品。这个模式强调的是客户代码一次保证只使用一个系列的产品。当要切换为另一个系列的产品，换一个工厂类即可。
- 原型模式：工厂方法的最大缺点就是，对应一个继承体系的产品类，要有一个同样复杂的工厂类的继承体系。我们可以把工厂类中的工厂方法放到产品类自身之中吗？如果这样的话，就可以将两个继承体系为一个。这也就是原型模式的思想，原型模式中的工厂方法为clone，它会返回一个拷贝（可以是浅拷贝，也可以是深拷贝，由设计者决定）。为了保证用户代码中到时可以通过指针调用clone来动态绑定地生成所需的具体的类。这些原型对象必须事先构造好。
- 原型模式想对工厂方法模式的另一个好处是，拷贝的效率一般对构造的效率要高。

- 2、在 Java 程序中怎么保证多线程的运行安全？

- 出现线程安全问题的原因一般都是三个原因：
- 1、 线程切换带来的原子性问题 解决办法：使用多线程之间同步synchronized或使用锁(lock)。
- 2、 缓存导致的可见性问题 解决办法：synchronized、volatile、LOCK，可以解决可见性问题
- 3、 编译优化带来的有序性问题 解决办法：Happens-Before 规则可以解决有序性问题

- 3、volatile 修饰符的有过什么实践？

- 一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。

- 4、Java中各种数据默认值

- 1、 Byte,short,int,long默认是都是0
- 2、 Boolean默认值是false
- 3、 Char类型的默认值是’’
- 4、 Float与double类型的默认是0.0
- 5、 对象类型的默认值是null

- 5、说说Java 垃圾回收机制

- 在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

- 6、有没有可能两个不相等的对象有有相同的 hashcode？

- 有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。

- 7、synchronized 和 Lock 有什么区别？

- 1、 首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；
- 2、 synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。
- 3、 synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。
- 4、 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。

- 8、什么是Vector

- Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，访问它比访问ArrayList慢很多
- ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。ArrayList的缺点是每个元素之间不能有间隔。

- 9、对象的访问定位有哪几种方式?

- 建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针2种：
- 句柄：如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
- 直接指针：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。
- 这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。

- 10、equals 和 == 的区别？#

- 通俗点讲：是看看左右是不是一个东西。equals是看看左右是不是长得一样。如何记住嘛。如果单纯是想记住，：等于。equals：相同。两个长得一样的人，只能说长的相同(equals)，但是不等于他们俩是一个人。你只要记住equals，==就不用记了。
- 术语来讲的区别：
- 1、 ==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同
- 2、 ==是指对内存地址进行比较 equals()是对字符串的内容进行比较3.==指引用是否相同 equals()指的是值是否相同

- 11、Servlet中如何获取用户提交的查询参数或表单数据？
- 12、堆溢出的原因？
- 13、Java 中，怎么获取一个文件中单词出现的最高频率？
- 14、你知道哪些JVM性能调优
- 15、抽象类必须要有抽象方法吗？
- 16、串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？
- 17、React的请求应该放在哪个生命周期中?
- 18、volatile关键字的作用
- 19、我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？
- 20、什么是Java虚拟机
- 21、CMS 收集器（多线程标记清除算法）
- 22、接口和抽象类的区别是什么？
- 23、如何合理分配线程池大小?
- 24、什么是线程组，为什么在Java中不推荐使用？
- 25、类加载器
- 26、JVM 如何确定垃圾对象？
- 27、字符型常量和字符串常量的区别
- 28、G1 收集器
- 29、Java 中，直接缓冲区与非直接缓冲器有什么区别？
- 30、如何决定使用 HashMap 还是 TreeMap？
- 31、说一下 ArrayList 的优缺点
- 32、构造方法能不能重写？能不能重载？
- 33、什么是红黑树
- 34、什么是逃逸分析？
- 35、栈帧里面包含哪些东西？
- 36、Tomcat是怎么打破双亲委派机制的呢？
- 37、WeakHashMap 是怎么工作的？
- 38、java 中操作字符串都有哪些类？它们之间有什么区别？
- 39、什么是JVM？java虚拟机包括什么？
- 40、Java 的引用有哪些类型？

### 3. JAVA面试题3

- 1、什么是ThreadPoolExecutor？

ThreadPoolExecutor就是线程池
ThreadPoolExecutor其实也是JAVA的一个类，我们一般通过Executors工厂类的方法，通过传入不同的参数，就可以构造出适用于不同应用场景下的ThreadPoolExecutor（线程池）
构造参数图：
构造参数参数介绍：
corePoolSize 核心线程数量
maximumPoolSize 最大线程数量
keepAliveTime 线程保持时间，N个时间单位
unit 时间单位（比如秒，分）
workQueue 阻塞队列
threadFactory 线程工厂
handler 线程池拒绝策略


- 2、invokedynamic 指令是干什么的？

Java 7 开始，新引入的字节码指令，可以实现一些动态类型语言的功能。Java 8 的 Lambda 表达式就是通过 invokedynamic 指令实现，使用方法句柄实现。


- 3、synchronized、volatile、CAS 比较

1、 synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。
2、 volatile 提供多线程共享变量可见性和禁止指令重排序优化。
3、 CAS 是基于冲突检测的乐观锁（非阻塞）
4、Iterator 怎么使用？有什么特点？
Iterator 使用代码如下：
List<String> list = new ArrayList<>();
    Iterator<String> it = list、iterator();
        while(it、hasNext()){
        String obj = it、next();
        System、out、println(obj);
        }
        Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。


        - 5、被引用的对象就一定能存活吗？

        不一定，看 Reference 类型，弱引用在 GC 时会被回收，软引用在内存不足的时候，即 OOM 前会被回收，但如果没有在 Reference Chain 中的对象就一定会被回收。


        - 6、列出一些你常见的运行时异常？

        1、 ArithmeticException（算术异常）
        2、 ClassCastException （类转换异常）
        3、 IllegalArgumentException （非法参数异常）
        4、 IndexOutOfBoundsException （下标越界异常）
        5、 NullPointerException （空指针异常）
        6、 SecurityException （安全异常）


        - 7、Servlet生命周期内调用的方法过程？

        1、 Init()
        2、 Service()
        3、 doGet或者doPost
        4、 destroy


        - 8、阐述静态变量和实例变量的区别。

        静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。
        补充：在Java开发中，上下文类和工具类中通常会有大量的静态成员。


        - 9、类加载器双亲委派模型机制？

        基本定义：
        双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器没有找到所需的类时，子加载器才会尝试去加载该类。
        双亲委派机制:
        1、 当 AppClassLoader 加载一个 class 时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器 ExtClassLoader 去完成。
        2、 当 ExtClassLoader 加载一个 class 时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给 BootStrapClassLoader 去完成。
        3、 如果 BootStrapClassLoader 加载失败，会使用 ExtClassLoader 来尝试加载；
        4、 若 ExtClassLoader 也加载失败，则会使用 AppClassLoader 来加载，如果 AppClassLoader 也加载失败，则会报出异常 ClassNotFoundException。
        如下图所示：
        双亲委派作用：
        1、 通过带有优先级的层级关可以避免类的重复加载；
        2、 保证 Java 程序安全稳定运行，Java 核心 API 定义类型不会被随意替换。


        - 10、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？

        都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。


        - 11、老年代
        - 12、如何停止一个正在运行的线程？
        - 13、常用JVM基本配置参数
        - 14、线程池都有哪些状态？
        - 15、怎么确保一个集合不能被修改？
        - 16、怎么检测一个线程是否拥有锁？
        - 17、启动一个线程是调用run()还是start()方法？
        - 18、React组件通信如何实现?
        - 19、Java 中 WeakReference 与 SoftReference的区别？
        - 20、常用并发列队的介绍：
        - 21、什么是数据结构？
        - 22、遇到过堆外内存溢出吗？
        - 23、会话跟踪技术有那些？
        - 24、抽象类和接口的区别?
        - 25、Java中用到的线程调度算法是什么？
        - 26、如何使session失效
        - 27、存储过程与函数的区别
        - 28、Spring支持的事务管理类型有哪些？你在项目中使用哪种方式？
        - 29、用Java写一个折半查找。
        - 30、对象都是优先分配在年轻代上的吗？
        - 31、本地方法区(线程私有)
        - 32、单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！”
        - 33、JVM 有哪些运行时内存区域？
        - 34、为什么Thread类的sleep()和yield ()方法是静态的？
        - 35、如何用Java代码列出一个目录下所有的文件？
        - 36、Java中notify 和 notifyAll有什么区别？
        - 37、为什么使用Executor框架？
        - 38、如何判断两个类是否相等？
        - 39、虚拟DOM实现原理?
        - 40、a = a + b 与 a += b 的区别

        ### 4. JAVA面试题4

        - 1、如何判断一个对象是否存活

        判断一个对象是否存活有两种方法：
        1、 引用计数法
        所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收、
        引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，对象 B 又引用者对象 A，那么此时 A、B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。
        2、 可达性算法（引用链法）
        该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。
        在 Java 中可以作为 GC Roots 的对象有以下几种：
        1、 虚拟机栈中引用的对象
        2、 方法区类静态属性引用的对象
        3、 方法区常量池引用的对象
        4、 本地方法栈JNI引用的对象
        虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记、
        如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法或者已被虚拟机调用过，那么就认为是没必要的。 如果该对象有必要执行 finalize() 方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize() 线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize() 执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除” 即将回收” 集合，等待回收。


        - 2、Int与integer的区别

        Integer是int的包装类型。
        Int的默认值是0，integer的默认值是null


        - 3、Servlet的生命周期？

        1、 加载：判断servlet实例是否存在，如果不存在，就加载serlvet
        2、 实例化：
        3、 初始化
        4、服务
        5、销毁


        - 4、怎么唤醒一个阻塞的线程

        如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。


        - 5、虚拟DOM的优劣如何?

        优点:
        1、 保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限
        2、 无需手动操作DOM: 虚拟DOM的diff和patch都是在一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率
        3、 跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等
        缺点:
        无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化,比如VScode采用直接手动操作DOM的方式进行极端的性能优化


        - 6、双亲委派模型是什么？

        类加载器具有等级制度但非继承关系，以组合的方式复用父加载器的功能。双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应该有自己的父加载器。
        一个类加载器收到了类加载请求，它不会自己去尝试加载，而将该请求委派给父加载器，每层的类加载器都是如此，因此所有加载请求最终都应该传送到启动类加载器，只有当父加载器反馈无法完成请求时，子加载器才会尝试。
        类跟随它的加载器一起具备了有优先级的层次关系，确保某个类在各个类加载器环境中都是同一个，保证程序的稳定性。


        - 7、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？
        - 8、如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？

        1、 不会，在下一个垃圾回调周期中，这个对象将是被可回收的。
        2、 也就是说并不会立即被垃圾收集器立刻回收，而是在下一次垃圾回收时才会释放其占用的内存。


        - 9、JVM 出现 fullGC 很频繁，怎么去线上排查问题

        这题就依据full GC的触发条件来做：
        1、 如果有perm gen的话(jdk1.8就没了)，要给perm gen分配空间，但没有足够的空间时，会触发full gc。
        2、 所以看看是不是perm gen区的值设置得太小了。
        3、 System.gc()方法的调用
        4、 这个一般没人去调用吧~~~
        5、 当统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间，则会触发full gc(这就可以从多个角度上看了)
        6、 是不是频繁创建了大对象(也有可能eden区设置过小)(大对象直接分配在老年代中，导致老年代空间不足--->从而频繁gc)
        7、 是不是老年代的空间设置过小了(Minor GC几个对象就大于老年代的剩余空间了)


        - 10、JVM 内存区域

        JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。
        线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。
        线程共享区域随虚拟机的启动/关闭而创建/销毁。
        直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于Channel与 Buffer的IO方式, 它可以使用Native函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。


        - 11、原型模式的使用方式
        - 12、简述一下你了解的设计模式。
        - 13、Java中有几种类型的流？
        - 14、Try.catch.finally是必须要存在的吗？
        - 15、你熟悉哪些垃圾收集算法？
        - 16、为什么HashTable是线程安全的？
        - 17、finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？
        - 18、用最有效率的方法计算2乘以8？
        - 19、多线程应用场景
        - 20、List 和 Set 的区别
        - 21、实现可见性的方法有哪些？
        - 22、堆
        - 23、什么是JDK?什么是JRE？
        - 24、在 Java 中，对象什么时候可以被垃圾回收？
        - 25、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?
        - 26、如何将字符串反转？
        - 27、如何通过反射获取和设置对象私有字段的值？
        - 28、并发队列的常用方法
        - 29、Set接口有什么特点
        - 30、说说你知道的几种主要的JVM参数
        - 31、“a==b”和”a.equals(b)”有什么区别？
        - 32、什么是并发队列：
        - 33、Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？
        - 34、Linux环境下如何查找哪个线程使用CPU最长
        - 35、并发编程三要素？
        - 36、四种线程池的创建：
        - 37、说说CMS垃圾收集器的工作原理
        - 38、请解释如何配置Tomcat来使用IIS和NTLM ?
        - 39、线程的sleep()方法和yield()方法有什么区别？
        - 40、JAVA弱引用
        - 41、方法区

        ### 5. JAVA面试题5

        - 1、Parallel Old 收集器（多线程标记整理算法）

        Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6才开始提供。
        在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量， Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器， 如果系统对吞吐量要求比较高，可以优先考虑新生代Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。


        - 2、对象分配内存是否线程安全？

        对象创建十分频繁，即使修改一个指针的位置在并发下也不是线程安全的，可能正给对象 A 分配内存，指针还没来得及修改，对象 B 又使用了指针来分配内存。
        解决方法：① CAS 加失败重试保证更新原子性。② 把内存分配按线程划分在不同空间，即每个线程在 Java 堆中预先分配一小块内存，叫做本地线程分配缓冲 TLAB，哪个线程要分配内存就在对应的 TLAB 分配，TLAB 用完了再进行同步。


        - 3、当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？

        如果其他方法没有synchronized的话，其他线程是可以进入的。
        所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。


        - 4、Serial 与 Parallel GC 之间的不同之处？

        Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而parallel 收集器使用多个 GC 线程来执行。


        - 5、为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？

        因为Java所有类的都继承了Object，Java想让任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。
        有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。


        - 6、redux异步中间件之间的优劣?

        redux-thunk优点:
        1、 体积小: redux-thunk的实现方式很简单,只有不到20行代码
        2、 使用简单: redux-thunk没有引入像redux-saga或者redux-observable额外的范式,上手简单
        redux-thunk缺陷:
        1、 样板代码过多: 与redux本身一样,通常一个请求需要大量的代码,而且很多都是重复性质的
        2、 耦合严重: 异步操作与redux的action偶合在一起,不方便管理
        3、 功能孱弱: 有一些实际开发中常用的功能需要自己进行封装
        redux-saga优点:
        1、 异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中
        2、 action摆脱thunk function: dispatch 的参数依然是一个纯粹的 action (FSA)，而不是充满 “黑魔法” thunk function
        3、 异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过 try/catch 语法直接捕获处理
        4、 功能强大: redux-saga提供了大量的Saga 辅助函数和Effect 创建器供开发者使用,开发者无须封装或者简单封装即可使用
        5、 灵活: redux-saga可以将多个Saga可以串行/并行组合起来,形成一个非常实用的异步flow
        6、 易测试，提供了各种case的测试方案，包括mock task，分支覆盖等等
        redux-saga缺陷:
        1、 额外的学习成本: redux-saga不仅在使用难以理解的 generator function,而且有数十个API,学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和一整套思想
        2、 体积庞大: 体积略大,代码近2000行，min版25KB左右
        3、 功能过剩: 实际上并发控制等功能很难用到,但是我们依然需要引入这些代码
        4、 ts支持不友好: yield无法返回TS类型
        redux-observable优点:
        1、 功能最强: 由于背靠rxjs这个强大的响应式编程的库,借助rxjs的操作符,你可以几乎做任何你能想到的异步处理
        2、 背靠rxjs: 由于有rxjs的加持,如果你已经学习了rxjs,redux-observable的学习成本并不高,而且随着rxjs的升级redux-observable也会变得更强大
        redux-observable缺陷:
        1、 学习成本奇高: 如果你不会rxjs,则需要额外学习两个复杂的库
        2、 社区一般: redux-observable的下载量只有redux-saga的1/5,社区也不够活跃,在复杂异步流中间件这个层面redux-saga仍处于领导地位
        关于redux-saga与redux-observable的详细比较可见此链接


        - 7、类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？

        双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。
        1、 假设有一个开发者自己编写了一个名为java.lang.Object的类，想借此欺骗JVM。现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类。
        2、 然而幸运的是，双亲委托模型不会让他成功。因为JVM会优先在Bootstrap ClassLoader的路径下找到java.lang.Object类，并载入它
        Java的类加载是否一定遵循双亲委托模型？
        1、 在实际开发中，我们可以通过自定义ClassLoader，并重写父类的loadClass方法，来打破这一机制。
        2、 SPI就是打破了双亲委托机制的(SPI：服务提供发现)。


        - 8、Hibernate中Session的load和get方法的区别是什么？

        如果没有找到符合条件的记录，get方法返回null，load方法抛出异常。
        get方法直接返回实体类对象，load方法返回实体类对象的代理。
        在Hibernate 3之前，get方法只在一级缓存中进行数据查找，如果没有找到对应的数据则越过二级缓存，直接发出SQL语句完成数据读取；load方法则可以从二级缓存中获取数据；从Hibernate 3开始，get方法不再是对二级缓存只写不读，它也是可以访问二级缓存的。


        - 9、说一下堆内存中对象的分配的基本策略

        eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区->Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。另外，大对象和长期存活的对象会直接进入老年代。


        - 10、Java 中如何将字符串转换为整数？

        String s="123";
        int i;
        第一种方法：i=Integer.parseInt(s);
        第二种方法：i=Integer.valueOf(s).intValue();


        - 11、Tcp协议的特点
        - 12、如何在两个线程间共享数据？
        - 13、java中有没有指针？
        - 14、什么是多线程
        - 15、a.hashCode() 有什么用？与 a.equals(b) 有什么关系？
        - 16、堆和栈的区别
        - 17、JDBC能否处理Blob和Clob？
        - 18、什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？
        - 19、简述一下面向对象的”六原则一法则”。
        - 20、MinorGC，MajorGC、FullGC都什么时候发生？
        - 21、JVM 运行时内存
        - 22、如何自定义一个异常
        - 23、synchronized、volatile、CAS比较
        - 24、JVM有哪些内存区域？(JVM的内存布局是什么？)
        - 25、强引用、软引用、弱引用、虚引用是什么？
        - 26、Java 中垃圾收集的方法有哪些
        - 27、CMS都有哪些问题？
        - 28、redux中如何进行异步操作?
        - 29、什么是多线程的上下文切换
        - 30、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？
        - 31、谈谈你知道的垃圾回收算法
        - 32、重载与重写
        - 33、Java 线程数过多会造成什么异常？
        - 34、Java 中 ++ 操作符是线程安全的吗？
        - 35、三种代理的区别
        - 36、在不使用 StringBuffer 的前提下，怎么反转一个字符串？
        - 37、什么叫线程安全？servlet 是线程安全吗?
        - 38、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？
        - 39、如果你提交任务时，线程池队列已满，这时会发生什么
        - 40、什么情况下会发生栈溢出？
        - 41、死锁与活锁的区别，死锁与饥饿的区别？

        ### 6. JAVA面试题6

        - 1、讲讲什么情况下会出现内存溢出，内存泄漏？

        解决这个内存泄漏问题也很简单，将set设置为null，那就可以避免上述内存泄漏问题了。其他内存泄漏得一步一步分析了。
        内存溢出的原因：
        1、 内存泄露导致堆栈内存不断增大，从而引发内存溢出。
        2、 大量的jar，class文件加载，装载类的空间不够，溢出
        3、 操作大量的对象导致堆内存空间已经用满了，溢出
        4、 nio直接操作内存，内存过大导致溢出
        解决：
        1、 查看程序是否存在内存泄漏的问题
        2、 设置参数加大空间
        3、 代码中是否存在死循环或循环产生过多重复的对象实体、
        4、 查看是否使用了nio直接操作内存。


        - 2、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？

        悲观锁：
        总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。
        乐观锁：
        顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。


        - 3、线程与进程的区别？

        进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。
        一个程序至少有一个进程,一个进程至少有一个线程。


        - 4、Session的save()、update()、merge()、lock()、saveOrUpdate()和persist()方法分别是做什么的？有什么区别？

        瞬时态的实例可以通过调用save()、persist()或者saveOrUpdate()方法变成持久态；游离态的实例可以通过调用 update()、saveOrUpdate()、lock()或者replicate()变成持久态。save()和persist()将会引发SQL的INSERT语句，而update()或merge()会引发UPDATE语句。save()和update()的区别在于一个是将瞬时态对象变成持久态，一个是将游离态对象变为持久态。merge()方法可以完成save()和update()方法的功能，它的意图是将新的状态合并到已有的持久化对象上或创建新的持久化对象。
        对于persist()方法，
        persist()方法把一个瞬时态的实例持久化，但是并不保证标识符被立刻填入到持久化实例中，标识符的填入可能被推迟到flush的时间；
        persist()方法保证当它在一个事务外部被调用的时候并不触发一个INSERT语句，当需要封装一个长会话流程的时候，persist()方法是很有必要的；
        save()方法不保证第②条，它要返回标识符，所以它会立即执行INSERT语句，不管是在事务内部还是外部。至于lock()方法和update()方法的区别，update()方法是把一个已经更改过的脱管状态的对象变成持久状态；lock()方法是把一个没有更改过的脱管状态的对象变成持久状态。


        - 5、用代码演示三种代理
        - 6、stackoverflow错误，permgen space错误

        stackoverflow错误主要出现：
        在虚拟机栈中(线程请求的栈深度大于虚拟机栈锁允许的最大深度)
        permgen space错误(针对jdk之前1.7版本)：
        1、 大量加载class文件
        2、 常量池内存溢出


        - 7、分代收集算法

        当前主流 VM 垃圾收集都采用”分代收集” (Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如 JVM 中的新生代、老年代、永久代， 这样就可以根据各年代特点分别采用最适当的 GC 算法


        - 8、同步方法和同步块，哪个是更好的选择？

        同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。
        同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。
        请知道一条原则：同步的范围越小越好。


        - 9、Java 中的编译期常量是什么？使用它又什么风险？

        公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。


        - 10、Java死锁以及如何避免？

        Java中的死锁是一种编程情况，其中两个或多个线程被永久阻塞，Java死锁情况出现至少两个线程和两个或更多资源。
        Java发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。


        - 11、为什么 Thread 类的 sleep()和 yield ()方法是静态的？
        - 12、Java都有那些开发平台？
        - 13、Java 中能创建 volatile 数组吗？
        - 14、线程 B 怎么知道线程 A 修改了变量
        - 15、GC日志的real、user、sys是什么意思？
        - 16、你说你做过JVM参数调优和参数配置，请问如何查看JVM系统默认值
        - 17、什么是ORM？
        - 18、串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？
        - 19、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用
        - 20、Java对象创建过程
        - 21、java 中 IO 流分为几种？
        - 22、在Java中Executor和Executors的区别？
        - 23、说说 JVM 如何执行 class 中的字节码。
        - 24、构造方法有哪些特性？
        - 25、final不可变对象，它对写并发应用有什么帮助？
        - 26、Java中操作字符串使用哪个类？
        - 27、在 Java 程序中怎么保证多线程的运行安全？
        - 28、JIT是什么？
        - 29、类加载有几个过程？
        - 30、JSP中的静态包含和动态包含有什么区别？
        - 31、线程池的优点？
        - 32、Java 中，怎么在格式化的日期中显示时区？
        - 33、什么是原型模式
        - 34、Javascript中常用的事件有哪些？
        - 35、32 位和 64 位的 JVM，int 类型变量的长度是多数？
        - 36、常用的并发工具类有哪些？
        - 37、什么是不可变对象，它对写并发应用有什么帮助？
        - 38、单例模式的线程安全性
        - 39、什么是阻塞式方法？
        - 40、调优工具
        - 41、创建线程的三种方式的对比？

        ### 7. JAVA面试题7

        ### 8. JAVA面试题8

        ### 9. JAVA面试题9

        ### 10. JAVA面试题10

        *XMind - Trial Version*